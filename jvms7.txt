--------------------------------------- 1
The Java Virtual
Machine Specification
Java SE 7 Edition
Tim Lindholm
Frank Yellin
Gilad Bracha
Alex Buckley
2012-07-27
--------------------------------------- 2
Specification: JSR-000924 Java Virtual Machine Specification ("Specification")
Version: 7
Status: Final Release
Release: July 2011
Copyright  2011 Oracle America, Inc. and/or its affiliates. All rights reserved.
500 Oracle Parkway M/S 5op7, California 94065, U.S.A.
LIMITED LICENSE GRANTS
1. License for Evaluation Purposes. Oracle hereby grants you a fully-paid, non-exclusive,
non-transferable, worldwide, limited license (without the right to sublicense), under
Oracle's applicable intellectual property rights to view, download, use and reproduce the
Specification only for the purpose of internal evaluation. This includes (i) developing
applications intended to run on an implementation of the Specification, provided that
such applications do not themselves implement any portion(s) of the Specification, and
(ii) discussing the Specification with any third party; and (iii) excerpting brief portions
of the Specification in oral or written communications which discuss the Specification
provided that such excerpts do not in the aggregate constitute a significant portion of the
Specification.
2. License for the Distribution of Compliant Implementations. Oracle also grants you a
perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited
license (without the right to sublicense) under any applicable copyrights or, subject to the
provisions of subsection 4 below, patent rights it may have covering the Specification to
create and/or distribute an Independent Implementation of the Specification that: (a) fully
implements the Specification including all its required interfaces and functionality; (b) does
not modify, subset, superset or otherwise extend the Licensor Name Space, or include any
public or protected packages, classes, Java interfaces, fields or methods within the Licensor
Name Space other than those required/authorized by the Specification or Specifications
being implemented; and (c) passes the Technology Compatibility Kit (including satisfying
the requirements of the applicable TCK Users Guide) for such Specification ("Compliant
Implementation"). In addition, the foregoing license is expressly conditioned on your not
acting outside its scope. No license is granted hereunder for any other purpose (including,
for example, modifying the Specification, other than to the extent of your fair use rights,
or distributing the Specification to third parties). Also, no right, title, or interest in or to
any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted
hereunder. Java, and Java-related logos, marks and names are trademarks or registered
trademarks of Oracle in the U.S. and other countries.
3. Pass-through Conditions. You need not include limitations (a)-(c) from the previous
paragraph or any other particular "pass through" requirements in any license You grant
concerning the use of your Independent Implementation or products derived from it.
However, except with respect to Independent Implementations (and products derived from
them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a)
grant or otherwise pass through to your licensees any licenses under Oracle's applicable
intellectual property rights; nor (b) authorize your licensees to make any claims concerning
their implementation's compliance with the Specification in question.
--------------------------------------- 3
4. Reciprocity Concerning Patent Licenses.
a. With respect to any patent claims covered by the license granted under subparagraph
2 above that would be infringed by all technically feasible implementations of the
Specification, such license is conditioned upon your offering on fair, reasonable and non-
discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-
transferable, worldwide license under Your patent rights which are or would be infringed
by all technically feasible implementations of the Specification to develop, distribute and
use a Compliant Implementation.
b. With respect to any patent claims owned by Oracle and covered by the license granted
under subparagraph 2, whether or not their infringement can be avoided in a technically
feasible manner when implementing the Specification, such license shall terminate with
respect to such claims if You initiate a claim against Oracle that it has, in the course of
performing its responsibilities as the Specification Lead, induced any other entity to infringe
Your patent rights.
c. Also with respect to any patent claims owned by Oracle and covered by the license
granted under subparagraph 2 above, where the infringement of such claims can be avoided
in a technically feasible manner when implementing the Specification such license, with
respect to such claims, shall terminate if You initiate a claim against Oracle that its making,
having made, using, offering to sell, selling or importing a Compliant Implementation
infringes Your patent rights.
5. Definitions. For the purposes of this Agreement: "Independent Implementation" shall
mean an implementation of the Specification that neither derives from any of Oracle's
source code or binary code materials nor, except with an appropriate and separate license
from Oracle, includes any of Oracle's source code or binary code materials; "Licensor
Name Space" shall mean the public class or interface declarations whose names begin
with "java", "javax", "com.sun" or their equivalents in any subsequent naming convention
adopted by Oracle through the Java Community Process, or any recognized successors or
replacements thereof; and "Technology Compatibility Kit" or "TCK" shall mean the test
suite and accompanying TCK User's Guide provided by Oracle which corresponds to the
Specification and that was available either (i) from Oracle 120 days before the first release
of Your Independent Implementation that allows its use for commercial purposes, or (ii)
more recently than 120 days from such release but against which You elect to test Your
implementation of the Specification.
This Agreement will terminate immediately without notice from Oracle if you breach the
Agreement or act outside the scope of the licenses granted above.
DISCLAIMER OF WARRANTIES
THE SPECIFICATION IS PROVIDED "AS IS". ORACLE MAKES NO
REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT (INCLUDING
AS A CONSEQUENCE OF ANY PRACTICE OR IMPLEMENTATION OF THE
SPECIFICATION), OR THAT THE CONTENTS OF THE SPECIFICATION ARE
SUITABLE FOR ANY PURPOSE. This document does not represent any commitment
to release or implement any portion of the Specification in any product. In addition, the
Specification could include technical inaccuracies or typographical errors.
--------------------------------------- 4
LIMITATION OF LIABILITY
TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ORACLE
OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT
LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL,
INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES,
HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY,
ARISING OUT OF OR RELATED IN ANY WAY TO YOUR HAVING,
IMPLEMENTING OR OTHERWISE USING THE SPECIFICATION, EVEN IF
ORACLE AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY
OF SUCH DAMAGES.
You will indemnify, hold harmless, and defend Oracle and its licensors from any claims
arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your
Java application, applet and/or implementation; and/or (iii) any claims that later versions
or releases of any Specification furnished to you are incompatible with the Specification
provided to you under this license.
RESTRICTED RIGHTS LEGEND
U.S. Government: If this Specification is being acquired by or on behalf of the U.S.
Government or by a U.S. Government prime contractor or subcontractor (at any tier), then
the Government's rights in the Software and accompanying documentation shall be only as
set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4
(for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for
non-DoD acquisitions).
REPORT
If you provide Oracle with any comments or suggestions concerning the Specification
("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary
and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide,
fully paid-up, irrevocable license, with the right to sublicense through multiple levels of
sublicensees, to incorporate, disclose, and use without limitation the Feedback for any
purpose.
GENERAL TERMS
Any action related to this Agreement will be governed by California law and controlling
U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice
of law rules of any jurisdiction will not apply.
The Specification is subject to U.S. export control laws and may be subject to export or
import regulations in other countries. Licensee agrees to comply strictly with all such laws
and regulations and acknowledges that it has the responsibility to obtain such licenses to
export, re-export or import as may be required after delivery to Licensee.
This Agreement is the parties' entire agreement relating to its subject matter. It supersedes
all prior or contemporaneous oral or written communications, proposals, conditions,
representations and warranties and prevails over any conflicting or additional terms of any
quote, order, acknowledgment, or other communication between the parties relating to its
subject matter during the term of this Agreement. No modification to this Agreement will
be binding, unless in writing and signed by an authorized representative of each party.
--------------------------------------- 5
Table of Contents
Preface to the First Editionxi
Preface to the Second Editionxiii
Preface to the Java SE 7 Editionxv
1Introduction1
1.1 A Bit of History1
1.2 The Java Virtual Machine2
1.3 Summary of Chapters3
1.4 Notation3
2The Structure of the Java Virtual Machine5
2.1 The class File Format5
2.2 Data Types6
2.3 Primitive Types and Values6
2.3.1 Integral Types and Values7
2.3.2 Floating-Point Types, Value Sets, and Values8
2.3.3 The returnAddress Type and Values10
2.3.4 The boolean Type10
2.4 Reference Types and Values11
2.5 Runtime Data Areas11
2.5.1 The pc Register12
2.5.2 Java Virtual Machine Stacks12
2.5.3 Heap 13
2.5.4 Method Area13
2.5.5 Runtime Constant Pool14
2.5.6 Native Method Stacks14
2.6 Frames15
2.6.1 Local Variables16
2.6.2 Operand Stacks17
2.6.3 Dynamic Linking18
2.6.4 Normal Method Invocation Completion18
2.6.5 Abrupt Method Invocation Completion18
2.7 Representation of Objects19
2.8 Floating-Point Arithmetic19
2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE
754 19
2.8.2 Floating-Point Modes20
iii
--------------------------------------- 6
The Java Virtual Machine Specification
2.8.3 Value Set Conversion20
2.9 Special Methods21
2.10 Exceptions23
2.11 Instruction Set Summary25
2.11.1Types and the Java Virtual Machine26
2.11.2Load and Store Instructions29
2.11.3Arithmetic Instructions30
2.11.4Type Conversion Instructions32
2.11.5Object Creation and Manipulation34
2.11.6Operand Stack Management Instructions34
2.11.7Control Transfer Instructions34
2.11.8Method Invocation and Return Instructions35
2.11.9Throwing Exceptions36
2.11.10Synchronization36
2.12 Class Libraries37
2.13 Public Design, Private Implementation37
3Compiling for the Java Virtual Machine39
3.1 Format of Examples39
3.2 Use of Constants, Local Variables, and Control Constructs40
3.3 Arithmetic45
3.4 Accessing the Runtime Constant Pool46
3.5 More Control Examples47
3.6 Receiving Arguments49
3.7 Invoking Methods50
3.8 Working with Class Instances53
3.9 Arrays55
3.10 Compiling Switches57
3.11 Operations on the Operand Stack58
3.12 Throwing and Handling Exceptions59
3.13 Compiling finally 63
3.14 Synchronization66
3.15 Annotations67
4The class File Format69
4.1 The ClassFile Structure70
4.2 The Internal Form of Names75
4.2.1 Binary Class and Interface Names75
4.2.2 Unqualified Names75
4.3 Descriptors and Signatures75
4.3.1 Grammar Notation76
4.3.2 Field Descriptors76
4.3.3 Method Descriptors78
4.3.4 Signatures79
4.4 The Constant Pool83
4.4.1 The CONSTANT_Class_info Structure84
iv
--------------------------------------- 7
The Java Virtual Machine Specification
4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
CONSTANT_InterfaceMethodref_info Structures85
4.4.3 The CONSTANT_String_info Structure87
4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info
Structures87
4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info
Structures89
4.4.6 The CONSTANT_NameAndType_info Structure90
4.4.7 The CONSTANT_Utf8_info Structure91
4.4.8 The CONSTANT_MethodHandle_info Structure93
4.4.9 The CONSTANT_MethodType_info Structure94
4.4.10The CONSTANT_InvokeDynamic_info Structure95
4.5 Fields96
4.6 Methods98
4.7 Attributes101
4.7.1 Defining and Naming New Attributes103
4.7.2 The ConstantValue Attribute104
4.7.3 The Code Attribute105
4.7.4 The StackMapTable Attribute108
4.7.5 The Exceptions Attribute116
4.7.6 The InnerClasses Attribute117
4.7.7 The EnclosingMethod Attribute120
4.7.8 The Synthetic Attribute121
4.7.9 The Signature Attribute121
4.7.10The SourceFile Attribute122
4.7.11The SourceDebugExtension Attribute123
4.7.12The LineNumberTable Attribute124
4.7.13The LocalVariableTable Attribute125
4.7.14The LocalVariableTypeTable Attribute127
4.7.15The Deprecated Attribute129
4.7.16The RuntimeVisibleAnnotations attribute129
4.7.16.1The element_value structure131
4.7.17The RuntimeInvisibleAnnotations attribute134
4.7.18The RuntimeVisibleParameterAnnotations attribute135
4.7.19The RuntimeInvisibleParameterAnnotations attribute136
4.7.20The AnnotationDefault attribute138
4.7.21The BootstrapMethods attribute139
4.8 Format Checking141
4.9 Constraints on Java virtual machine code141
4.9.1 Static Constraints141
4.9.2 Structural Constraints145
4.10 Verification of class Files148
4.10.1Verification by Type Checking150
4.10.1.1The Type Hierarchy154
4.10.1.2Subtyping Rules155
4.10.1.3Typechecking Rules159
4.10.1.4Instructions170
4.10.2Verification by Type Inference324
v
--------------------------------------- 8
The Java Virtual Machine Specification
4.10.2.1The Process of Verification by Type Inference324
4.10.2.2The Bytecode Verifier325
4.10.2.3Values of Types long and double 328
4.10.2.4Instance Initialization Methods and Newly Created
Objects329
4.10.2.5Exceptions and finally 330
4.11 Limitations of the Java virtual machine332
5Loading, Linking, and Initializing335
5.1 The Runtime Constant Pool335
5.2 Virtual Machine Start-up338
5.3 Creation and Loading338
5.3.1 Loading Using the Bootstrap Class Loader340
5.3.2 Loading Using a User-defined Class Loader341
5.3.3 Creating Array Classes342
5.3.4 Loading Constraints342
5.3.5 Deriving a Class from a class File Representation344
5.4 Linking345
5.4.1 Verification346
5.4.2 Preparation346
5.4.3 Resolution347
5.4.3.1 Class and Interface Resolution348
5.4.3.2 Field Resolution349
5.4.3.3 Method Resolution350
5.4.3.4 Interface Method Resolution351
5.4.3.5 Method Type and Method Handle Resolution352
5.4.3.6 Call Site Specifier Resolution355
5.4.4 Access Control356
5.4.5 Method overriding357
5.5 Initialization357
5.6 Binding Native Method Implementations360
5.7 Virtual Machine Exit360
6The Java Virtual Machine Instruction Set361
6.1 Assumptions: The Meaning of "Must"361
6.2 Reserved Opcodes362
6.3 Virtual Machine Errors362
6.4 Format of Instruction Descriptions363
mnemonic364
6.5 Instructions366
aaload367
aastore368
aconst_null370
aload371
aload_<n>372
anewarray373
areturn374
vi
--------------------------------------- 9
The Java Virtual Machine Specification
arraylength375
astore376
astore_<n>377
athrow378
baload380
bastore381
bipush382
caload383
castore384
checkcast385
d2f387
d2i388
d2l389
dadd390
daload392
dastore393
dcmp<op>394
dconst_<d>396
ddiv397
dload399
dload_<n>400
dmul401
dneg403
drem404
dreturn406
dstore407
dstore_<n>408
dsub409
dup410
dup_x1411
dup_x2412
dup2413
dup2_x1414
dup2_x2415
f2d417
f2i418
f2l419
fadd420
faload422
fastore423
fcmp<op>424
fconst_<f>426
fdiv427
fload429
fload_<n>430
fmul431
fneg433
frem434
vii
--------------------------------------- 10
The Java Virtual Machine Specification
freturn436
fstore437
fstore_<n>438
fsub439
getfield440
getstatic442
goto444
goto_w445
i2b446
i2c447
i2d448
i2f449
i2l450
i2s451
iadd452
iaload453
iand454
iastore455
iconst_<i>456
idiv457
if_acmp<cond>458
if_icmp<cond>459
if<cond>461
ifnonnull463
ifnull464
iinc465
iload466
iload_<n>467
imul468
ineg469
instanceof470
invokedynamic472
invokeinterface477
invokespecial480
invokestatic484
invokevirtual487
ior492
irem493
ireturn494
ishl495
ishr496
istore497
istore_<n>498
isub499
iushr500
ixor501
jsr502
jsr_w503
viii
--------------------------------------- 11
The Java Virtual Machine Specification
l2d504
l2f505
l2i506
ladd507
laload508
land509
lastore510
lcmp511
lconst_<l>512
ldc513
ldc_w515
ldc2_w517
ldiv518
lload519
lload_<n>520
lmul521
lneg522
lookupswitch523
lor525
lrem526
lreturn527
lshl528
lshr529
lstore530
lstore_<n>531
lsub532
lushr533
lxor534
monitorenter535
monitorexit537
multianewarray539
new 541
newarray543
nop545
pop546
pop2547
putfield548
putstatic550
ret552
return553
saload554
sastore555
sipush556
swap557
tableswitch558
wide560
7Opcode Mnemonics by Opcode563
ix
--------------------------------------- 12
The Java Virtual Machine SpecificationIndex567
x
--------------------------------------- 13
Preface to the First Edition
THE Java virtual machine specification has been written to fully document the
design of the Java virtual machine. It is essential for compiler writers who wish
to target the Java virtual machine and for programmers who want to implement a
compatible Java virtual machine.
The Java virtual machine is an abstract machine. Java References virtualto the 
machine throughout this specification refer to this abstract machine rather than
to Oracle's or any other specific implementation. This specification serves as
documentation for a concrete implementation of the Java virtual machine only as
a blueprint documents a house. An implementation of the Java virtual machine
(known as a runtime interpreter) must embody this specification, but is constrained
by it only where absolutely necessary.
The Java virtual machine specified here is compatible with the Java Platform,
Standard Edition 7, and supports the Java programming Thelanguage specified in 
Java Language Specification, Java SE 7 Edition.
We intend that this specification should sufficiently document the Java virtual
machine to make possible compatible clean-room implementations. If you are
considering constructing your own Java virtual machine implementation, feel
free to contact us to obtain assistance to ensure the 100% compatibility of your
implementation.
The virtual machine that evolved into the Java virtual machine was originally
designed by James Gosling in 1992 to support the Oak programming language.
The evolution into its present form occurred through the direct and indirect efforts
of many people and spanned Sun's Green project, FirstPerson, Inc., the LiveOak
project, the Java Products Group, JavaSoft, and today, Oracle's Java Platform
Group. The authors are grateful to the many contributors and supporters.
This book began as internal project documentation. Kathy Walrath edited that early
draft, helping to give the world its first look at the internals of the Java programming
language. It was then converted to HTML by Mary Campione and was made
available on our Web site before being expanded into book form.
The creation The of Java Virtual Machine Specification owes much to the
support of the Java Products Group led by General Manager Ruth Hennigar, to the
efforts of series editor Lisa Friendly, and to editor Mike Hendrickson and his group
xi
--------------------------------------- 14
PREFACE TO THE FIRST EDITION
at Addison-Wesley. The many criticisms and suggestions received from reviewers
of early online drafts, as well as drafts of the printed book, improved its quality
immensely. We owe special thanks to Richard Tuck for his careful review of the
manuscript. Particular thanks to Bill Joy whose comments, reviews, and guidance
have contributed greatly to the completeness and accuracy of this book.
Tim Lindholm
Frank Yellin
xii
--------------------------------------- 15
Preface to the Second Edition
THE second edition The of Java Virtual Machine Specification brings the
specification of the Java virtual machine up to date with the Java 2 platform, v1.2.
It also includes many corrections and clarifications that update the presentation
of the specification without changing the logical specification itself. We have
attempted to correct typos and errata (hopefully without introducing new ones)
and to add more detail to the specification where it was vague or ambiguous. In
particular, we corrected a number of inconsistencies Thebetween the first edition of 
Java Virtual Machine Specification and The Java Language Specification.
We thank the many readers who combed through the first edition of this book and
brought problems to our attention. Several individuals and groups deserve special
thanks for pointing out problems or contributing directly to the new material:
Carla Schroer and her teams of compatibility testers in Cupertino, California,
and Novosibirsk, Russia (with special thanks to Leonid Arbouzov and Alexei
Kaigorodov), painstakingly wrote compatibility tests for each testable assertion in
the first edition. In the process they uncovered many places where the original
specification was unclear or incomplete.
Jeroen Vermeulen, Janice Shepherd, Peter Bertelsen, Roly Perera, Joe Darcy,
and Sandra Loosemore have all contributed comments and feedback that have
improved this edition.
Marilyn Rash and Hilary Selby Polk of Addison Wesley Longman helped us to
improve the readability and layout of this edition at the same time as we were
incorporating all the technical changes.
Special thanks go to Gilad Bracha, who has brought a new level of rigor to
the presentation and has been a major contributor to much of the new material,
especially chapters 4 and 5. His dedication to "computational theology" and his
commitment to resolving inconsistencies The Java between Virtual Machine
Specification and The Java Language Specification have benefited this book
tremendously.
Tim Lindholm
Frank Yellin
xiii
--------------------------------------- 16
PREFACE TO THE SECOND EDITION
xiv
--------------------------------------- 17
Preface to the Java SE 7 Edition
THE Java SE 7 Edition The Java of Virtual Machine Specification incorporates
all the changes that have been made to the specification since the Second Edition
in 1999. In addition, numerous corrections and clarifications have been made over
time to align with popular implementations of the Java virtual machine, and with
concepts common to the Java virtual machine and the Java programming language.
The Java SE 5.0 platform in 2004 brought momentous changes to the Java
programming language but had a relatively muted effect on the design of the Java
virtual machine. Additions were classmade  file to format the to support new Java
programming language features such as generics and variable arity methods.
The Java SE 6 platform in 2006 saw no changes to the Java programming language
but an entirely new approach to bytecode verification in the Java virtual machine.
It was Eva Rose who, in her Master's Thesis, first proposed a radical revision of
JVM bytecode verification, in the context of the Java Card platform. This led
first to an implementation for Java ME CLDC, and eventually to the revision of
the Java SE verification process documented in Chapter 4.
Sheng Liang implemented the Java ME CLDC verifier. Antero Taivalsaari led
the overall specification of Java ME CLDC and Gilad Bracha was responsible for
specifying the verifier. Alessandro Coglio's analysis of JVM bytecode verification
was the most extensive, realistic, and thorough study of the topic, and contributed
greatly to the specification. Wei Tao, together with Frank Yellin, Tim Lindholm,
and Gilad Bracha, implemented the Prolog verifier that formed the basis for the
specification in both Java ME and Java SE. Wei then implemented the specification
"for real" in the HotSpot JVM. Later, Mingyao Yang improved the design and
specification, and implemented the final version that shipped in the Reference
Implementation of Java SE 6. The specification also benefited from the efforts
of the JSR 202 Expert Group: Peter Burka, Alessandro Coglio, Sanghoon Jin,
Christian Kemper, Larry Rau, Eva Rose, and Mark Stolz.
The Java SE 7 platform in 2011 made good on the promise given in the first
edition The of Java Virtual Machine Specification in 1997: "In the future,
we will consider bounded extensions to the Java virtual machine to provide
better support for other languages." It was Gilad Bracha who, in his work on
hotswapping, anticipated the burden of the Java virtual machine's static type
system on implementers of dynamically-typed languages. Consequently, the
xv
--------------------------------------- 18
PREFACE TO THE JAVA SE 7 EDITION
invokedynamic instruction and its supporting infrastructure were developed by
John Rose and the JSR 292 Expert Group: Ola Bini, Rmi Forax, Dan Heidinga,
Fredrik hrstrm, and Jochen Theodorou, with special contributions from Charlie
Nutter and Christian Thalinger.
More people than we can mention here have, over time, contributed to the design
and implementation of the Java virtual machine. The excellent performance we see
in the JVMs of today would never have been possible without the technological
foundation laid by David Ungar and his colleagues at the Self project at Sun Labs.
This technology took a convoluted path, from Self on through the Animorphic
Smalltalk VM to eventually become the Oracle HotSpot JVM. Lars Bak and Urs
Hlzle are the two people who were present through all these stages, and are more
responsible than anyone else for the high performance we take for granted in JVMs
today.
This specification has been significantly improved thanks to contributions from
Martin Buchholz, Brian Goetz, Paul Hohensee, David Holmes, Karen Kinnear,
Keith McGuigan, Jeff Nisewanger, Mark Reinhold, Naoto Sato, and Bill Pugh,
as well as Uday Dhanikonda, Janet Koenig, Adam Messinger, John Pampuch,
Georges Saab, and Bernard Traversat. Jon Courtney and Roger Riggs helped to
ensure this specification is applicable to Java ME as much as Java SE. Leonid
Arbouzov, Stanislav Avzan, Yuri Gaevsky, Ilya Mukhin, Sergey Reznick, and
Kirill Shirokov have done outstanding work in the Java Compatibility Kit to ensure
this specification is both testable and tested.
Gilad Bracha
Alex Buckley
Java Platform Group, Oracle
xvi
--------------------------------------- 19
CHAPTER1
Introduction
1.1 A Bit of History
The Java programming language is a general-purpose, concurrent, object-
oriented language. Its syntax is similar to C and C++, but it omits many of the
features that make C and C++ complex, confusing, and unsafe. The Java platform
was initially developed to address the problems of building software for networked
consumer devices. It was designed to support multiple host architectures and
to allow secure delivery of software components. To meet these requirements,
compiled code had to survive transport across networks, operate on any client, and
assure the client that it was safe to run.
The popularization of the World Wide Web made these attributes much more
interesting. Web browsers enabled millions of people to surf the Net and access
media-rich content in simple ways. At last there was a medium where what you
saw and heard was essentially the same regardless of the machine you were using
and whether it was connected to a fast network or a slow modem.
Web enthusiasts soon discovered that the content supported by the Web's HTML
document format was too limited. HTML extensions, such as forms, only
highlighted those limitations, while making it clear that no browser could include
all the features users wanted. Extensibility was the answer.
Sun's HotJava browser first showcased the interesting properties of the Java
programming language and platform by making it possible to embed programs
inside HTML pages. Programs are transparently downloaded into the browser
along with the HTML pages in which they appear. Before being accepted by the
browser, programs are carefully checked to make sure they are safe. Like HTML
pages, compiled programs are network- and host-independent. The programs
behave the same way regardless of where they come from or what kind of machine
they are being loaded into and run on.
1
--------------------------------------- 20
1.2The Java Virtual MachineINTRODUCTION
A Web browser incorporating the Java platform is no longer limited to a
predetermined set of capabilities. Visitors to Web pages incorporating dynamic
content can be assured that their machines cannot be damaged by that content.
Programmers can write a program once, and it will run on any machine supplying
a Java runtime environment.
1.2 The Java Virtual Machine
The Java virtual machine is the cornerstone of the Java platform. It is the
component of the technology responsible for its hardware- and operating system-
independence, the small size of its compiled code, and its ability to protect users
from malicious programs.
The Java virtual machine is an abstract computing machine. Like a real computing
machine, it has an instruction set and manipulates various memory areas at runtime.
It is reasonably common to implement a programming language using a virtual
machine; the best-known virtual machine may be the P-Code machine of UCSD
Pascal.
The first prototype implementation of the Java virtual machine, done at Sun
Microsystems, Inc., emulated the Java virtual machine instruction set in software
hosted by a handheld device that resembled a contemporary Personal Digital
Assistant (PDA). Oracle's current implementations emulate the Java virtual
machine on mobile, desktop and server devices, but the Java virtual machine
does not assume any particular implementation technology, host hardware, or
host operating system. It is not inherently interpreted, but can just as well be
implemented by compiling its instruction set to that of a silicon CPU. It may also
be implemented in microcode or directly in silicon.
The Java virtual machine knows nothing of the Java programming language, only
of a particular binary classformat,  file the format. classA  file contains Java
virtual machine instructions bytecodes) (or and a symbol table, as well as other
ancillary information.
For the sake of security, the Java virtual machine imposes strong syntactic and
structural constraints on the class code file. in However, a any language with
functionality that can be expressed in classterms  file of can a valid be hosted by
the Java virtual machine. Attracted by a generally available, machine-independent
platform, implementors of other languages can turn to the Java virtual machine as
a delivery vehicle for their languages.
2
--------------------------------------- 21
INTRODUCTIONSummary of Chapters1.3
1.3 Summary of Chapters
The rest of this book is structured as follows:
 Chapter 2 gives an overview of the Java virtual machine architecture.
 Chapter 3 introduces compilation of code written in the Java programming
language into the instruction set of the Java virtual machine.
 Chapter 4 specifies class the file format, the hardware- and operating system-
independent binary format used to represent compiled classes and interfaces.
 Chapter 5 specifies the start-up of the Java virtual machine and the loading,
linking, and initialization of classes and interfaces.
 Chapter 6 specifies the instruction set of the Java virtual machine, presenting the
instructions in alphabetical order of opcode mnemonics.
 Chapter 7 gives a table of Java virtual machine opcode mnemonics indexed by
opcode value.
In The Java Virtual Machine Specification, , Second Chapter Edition2 gave an
overview of the Java programming language intended to support the specification
of the Java virtual machine, but was not itself a part The of that specification. In 
Java Virtual Machine Specification, Java , the SE reader 7 Editionis referred to
The Java Language Specification, Java  for SE information 7 Editionabout the
Java programming language. References of the form: (JLS x.y) indicate where
this is necessary.
In The Java Virtual Machine Specification, , Second Chapter Edition8 detailed
the low-level actions that explained the interaction of Java virtual machine threads
with a shared main memory. It was adapted from Chapter 17 of the first edition
of The Java Language Specification. Chapter 17 The in Java Language
Specification, Java SE  reflects 7 EditionThe Java Memory Model and Thread
Specification produced by the JSR-133 Expert Group, and the reader is referred to
that chapter for information about threads and locks.
1.4 Notation
Throughout this book we refer to classes and interfaces drawn from the Java SE
platform API. Whenever we refer to a class or interface N, using a single identifier 
the intended reference is to the java.lang.class or N. interface We use the fully
qualified name for classes from packages other than java.lang.
3
--------------------------------------- 22
1.4NotationINTRODUCTION
Whenever we refer to a class or interface that is javadeclared  orin the package 
any of its subpackages, the intended reference is to that class or interface as loaded
by the bootstrap class loader (5.3.1).
Whenever we refer to a subpackage of a javapackage , the named intended
reference is to that subpackage as determined by the bootstrap class loader.
The use of fonts in this specification is as follows:
 A fixed width font is used for code examples written in the Java programming
language, Java virtual machine data types, exceptions, and errors.
 Italic is used for Java virtual machine "assembly language", its opcodes and
operands, as well as items in the Java virtual machine's runtime data areas. It is
also used to introduce new terms and simply for emphasis.
4
--------------------------------------- 23
CHAPTER2
The Structure of the Java
Virtual Machine
THIS document specifies an abstract machine. It does not describe any particular
implementation of the Java virtual machine.
To implement the Java virtual machine correctly, you need only be able to read
the class file format and correctly perform the operations specified therein.
Implementation details that are not part of the Java virtual machine's specification
would unnecessarily constrain the creativity of implementors. For example, the
memory layout of runtime data areas, the garbage-collection algorithm used, and
any internal optimization of the Java virtual machine instructions (for example,
translating them into machine code) are left to the discretion of the implementor.
All references to Unicode in this specification are Thegiven with respect to 
Unicode Standard, Version 6.0.0, available at http://www.unicode.org/.
2.1 The class File Format
Compiled code to be executed by the Java virtual machine is represented using
a hardware- and operating system-independent binary format, typically (but not
necessarily) stored in a file, classknown  file as format. the classThe  file format
precisely defines the representation of a class or interface, including details such
as byte ordering that might be taken for granted in a platform-specific object file
format.
Chapter 4, "The class File Format", covers the class file format in detail.
5
--------------------------------------- 24
2.2Data TypesTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
2.2 Data Types
Like the Java programming language, the Java virtual machine operates on two
kinds of types: primitive  typesand reference types. There are, correspondingly, two
kinds of values that can be stored in variables, passed as arguments, returned by
methods, and operated upon: primitive values and reference values.
The Java virtual machine expects that nearly all type checking is done prior to
runtime, typically by a compiler, and does not have to be done by the Java virtual
machine itself. Values of primitive types need not be tagged or otherwise be
inspectable to determine their types at runtime, or to be distinguished from values of
reference types. Instead, the instruction set of the Java virtual machine distinguishes
its operand types using instructions intended to operate on values of specific types.
For instance, iadd, ladd, fadd, and dadd are all Java virtual machine instructions
that add two numeric values and produce numeric results, but each is specialized
for its operand inttype: , long, float, and double, respectively. For a summary
of type support in the Java virtual machine instruction set, see 2.11.1.
The Java virtual machine contains explicit support for objects. An object is either
a dynamically allocated class instance or an array. A reference to an object
is considered to have Java virtual referencemachine . Values type of type
reference can be thought of as pointers to objects. More than one reference to an
object may exist. Objects are always operated on, passed, and tested via values of
type reference.
2.3 Primitive Types and Values
The primitive data types supported by the Java virtual numericmachine are the 
types, the boolean type (2.3.4), and the returnAddress type (2.3.3).
The numeric types consist integral of the types (2.3.1) and the floating-point types
(2.3.2).
The integral types are:
byte, whose values are 8-bit signed two's-complement integers, and whose
default value is zero
short, whose values are 16-bit signed two's-complement integers, and whose
default value is zero
6
--------------------------------------- 25
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEIntegral Types and Values2.3.1
int, whose values are 32-bit signed two's-complement integers, and whose
default value is zero
long, whose values are 64-bit signed two's-complement integers, and whose
default value is zero
char, whose values are 16-bit unsigned integers representing Unicode code
points in the Basic Multilingual Plane, encoded with UTF-16, and whose default
value is the null code point ('\u0000')
The floating-point types are:
float, whose values are elements of the float value set or, where supported, the
float-extended-exponent value set, and whose default value is positive zero
double, whose values are elements of the double value set or, where supported,
the double-extended-exponent value set, and whose default value is positive zero
The values of booleanthe  type encode the truth true values and false, and the
default value is false.
The first edition The Java of Virtual Machine Specification did not consider boolean to
be a Java virtual machine type. booleanHowever,  values do have limited support in the
Java virtual machine. The Java Virtual Machine Specification,  clarifiedSecond Edition
the issue by treating boolean as a type.
The values of returnAddressthe  type are pointers to the opcodes of Java virtual
machine instructions. Of the primitive returnAddresstypes, only  type the is not
directly associated with a Java programming language type.
2.3.1Integral Types and Values
The values of the integral types of the Java virtual machine are:
77
 For byte, from -128 to 127 (-2 to 2 - 1), inclusive
1515
 For short, from -32768 to 32767 (-2 to 2 - 1), inclusive
3131
 For int, from -2147483648 to 2147483647 (-2 to 2 - 1), inclusive
6363
 For long, from -9223372036854775808 to 9223372036854775807  to 2(-2
- 1), inclusive
 For char, from 0 to 65535 inclusive
7
--------------------------------------- 26
2.3.2 Floating-Point Types, Value Sets, and ValuesTHE STRUCTURE OF THE JAVA VIRTUAL
MACHINE
2.3.2Floating-Point Types, Value Sets, and Values
The floating-point floattypes  and are double, which are conceptually associated
with the 32-bit single-precision and 64-bit double-precision format IEEE 754
values and operations as specified IEEE Standard in for Binary Floating-Point
Arithmetic (ANSI/IEEE Std. 754-1985, New York).
The IEEE 754 standard includes not only positive and negative sign-magnitude
numbers, but also positive and negative zeros, infinitiespositive , andand negative 
a special Not-a-Number value (hereafter abbreviated as "NaN"). The NaN value
is used to represent the result of certain invalid operations such as dividing zero
by zero.
Every implementation of the Java virtual machine is required to support two
standard sets of floating-point float values, value called  and setthe double the value
set. In addition, an implementation of the Java virtual machine may, at its option,
support either or both of two extended-exponent floating-point value sets, called
the float-extended-exponent  and value the double-extended-exponent set. value set
These extended-exponent value sets may, under certain circumstances, be used
instead of the standard value sets to represent the values of type float or double.
The finite nonzero values of any floating-point value set can all be expressed in
(e - N + 1)
the form s  m  2, where s is +1 or m -1, is a positive integer less than
K-1K-1
2N, and e is an integer between Emin = -(2-2) and Emax = 2-1, inclusive,
and where N and K are parameters that depend on the value set. Some values can
be represented in this form in more than one way; for example, supposing that a
value v in a value set might be represented in this form using certain values for
K-1
s, m, and e, then if it happened m were that even eand  were less than , one2
could halve m and increase e by 1 to produce a second representation for the same
N-1
value v. A representation in this normalizedform is  if called m e 2; otherwise
the representation is denormalizedsaid to . be If a value in a value set cannot be
N-1
represented in such a m eway  2 that , then the value is denormalizedsaid to be a 
value, because it has no normalized representation.
The constraints on the Nparameters  and K (and on the derived parameters Emin
and Emax) for the two required and two optional floating-point value sets are
summarized in Table 2.1.
8
--------------------------------------- 27
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEFloating-Point Types, Value Sets, and2.3.2
Values
Table 2.1. Floating-point value set parameters
Parameterfloatfloat-extended-doubledouble-extended-
exponentexponent
N24245353
K8e 1111e 15
Emax+127e +1023+1023e +16383
Emin-126d -1022-1022d -16382
Where one or both extended-exponent value sets are supported by an
implementation, then for each supported extended-exponent value set there is
a specific implementation-dependent K, whose constant value is constrained by
Table 2.1; this value K in turn dictates the values for Emin and Emax.
Each of the four value sets includes not only the finite nonzero values that are
ascribed to it above, but also the five values positive zero, negative zero, positive
infinity, negative infinity, and NaN.
Note that the constraints Table 2.1 in are designed so that every element of the
float value set is necessarily also an element of the float-extended-exponent value
set, the double value set, and the double-extended-exponent value set. Likewise,
each element of the double value set is necessarily also an element of the double-
extended-exponent value set. Each extended-exponent value set has a larger range
of exponent values than the corresponding standard value set, but does not have
more precision.
The elements of the float value set are exactly the values that can be represented
using the single floating-point format defined in the IEEE 754 standard, except
24
that there is only one NaN value (IEEE -2 754 distinct specifies NaN 2values).
The elements of the double value set are exactly the values that can be represented
using the double floating-point format defined in the IEEE 754 standard, except
53
that there is only one NaN value (IEEE -2 754 distinct specifies NaN 2values).
Note, however, that the elements of the float-extended-exponent and double-
extended-exponent value sets defined not correspond here do to the values that
can be represented using IEEE 754 single extended and double extended formats,
respectively. This specification does not mandate a specific representation for the
values of the floating-point value sets except where floating-point values must be
represented in the class file format (4.4.4, 4.4.5).
The float, float-extended-exponent, double, and double-extended-exponent value
sets are not types. It is always correct for an implementation of the Java virtual
machine to use an element of the float value set to floatrepresent ;a value of type 
9
--------------------------------------- 28
2.3.3 The returnAddress Type and ValuesTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
however, it may be permissible in certain contexts for an implementation to use
an element of the float-extended-exponent value set instead. Similarly, it is always
correct for an implementation to use an element of the double value set to represent
a value of doubletype ; however, it may be permissible in certain contexts for
an implementation to use an element of the double-extended-exponent value set
instead.
Except for NaNs, values of the floating-point orderedvalue . Whensets are 
arranged from smallest to largest, they are negative infinity, negative finite values,
positive and negative zero, positive finite values, and positive infinity.
Floating-point positive zero and floating-point negative zero compare as equal, but
there are other operations that can distinguish them; 1.0 byfor example, dividing 
0.0 produces positive infinity, 1.0 but by -0.0dividing  produces negative infinity.
NaNs are unordered, so numerical comparisons and tests for numerical equality
have the value false if either or both of their operands are NaN. In particular, a
test for numerical equality of a value against false itself if and has onlythe value 
if the value is NaN. A test for numerical inequality true if eitherhas the value 
operand is NaN.
2.3.3The returnAddress Type and Values
The returnAddress type is used by the Java virtual jsr, ret, machine's and jsr_w
instructions jsr, ret( , jsr_w). The values returnAddressof the  type are pointers
to the opcodes of Java virtual machine instructions. Unlike the numeric primitive
types, the returnAddress type does not correspond to any Java programming
language type and cannot be modified by the running program.
2.3.4The boolean Type
Although the Java virtual machine booleandefines  type, a it only provides
very limited support for it. There are no Java virtual machine instructions solely
dedicated to operations booleanon  values. Instead, expressions in the Java
programming language that operate boolean values on are compiled to use values
of the Java virtual machine int data type.
The Java virtual machine does directly boolean arrays. support newarrayIts 
instruction newarray() enables creation booleanof  arrays. Arrays of type
boolean are accessed and modified byteusing  array the instructions baload and
bastore (baload, bastore).
10
--------------------------------------- 29
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEReference Types and Values2.4
In Oracles Java virtual machine implementation, boolean arrays in the Java programming
language are encoded as Java virtual byte arrays, machine using 8 booleanbits per 
element.
The Java virtual machine booleanencodes  array components using 1 to represent
true and 0 to represent false. Where Java programming booleanlanguage  values
are mapped by compilers to values of Java virtual int, the machine compilerstype 
must use the same encoding.
2.4 Reference Types and Values
There are three kinds referenceof  types: class types, array types, and interface
types. Their values are references to dynamically created class instances, arrays, or
class instances or arrays that implement interfaces, respectively.
An array type consists component of a type with a single dimension (whose length
is not given by the type). The component type of an array type may itself be an array
type. If, starting from any array type, one considers its component type, and then
(if that is also an array type) the component type of that type, and so on, eventually
one must reach a component type that is not an array elementtype; this is called the 
type of the array type. The element type of an array type is necessarily either a
primitive type, or a class type, or an interface type.
A reference value may also be the special null reference, a reference to no object,
which will be denoted nullhere . The by null reference initially has no runtime
type, but may be cast to any type. The default value of a reference type is null.
The Java virtual machine specification does not mandate a concrete value encoding
null.
2.5 Runtime Data Areas
The Java virtual machine defines various runtime data areas that are used during
execution of a program. Some of these data areas are created on Java virtual
machine start-up and are destroyed only when the Java virtual machine exits. Other
data areas are per thread. Per-thread data areas are created when a thread is created
and destroyed when the thread exits.
11
--------------------------------------- 30
2.5.1 The pc RegisterTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
2.5.1The pc Register
The Java virtual machine can support many threads of execution at once (JLS 17).
Each Java virtual machine thread pc (program has its own counter) register. At any
point, each Java virtual machine thread is executing the code of a single method,
namely the current 2.6method ) for ( that thread. If that nativemethod , theis not 
pc register contains the address of the Java virtual machine instruction currently
being executed. If the method currently being executed native, by the thread is 
the value of the Java virtual pc register machine's is undefined. The Java virtual
machine's pc register is wide enough returnAddressto hold a  or a native pointer
on the specific platform.
2.5.2Java Virtual Machine Stacks
Each Java virtual machine thread Java has virtual a private machine , createdstack
at the same time as the thread. A Java virtual machine 2.6).stack stores frames (
A Java virtual machine stack is analogous to the stack of a conventional language
such as C: it holds local variables and partial results, and plays a part in method
invocation and return. Because the Java virtual machine stack is never manipulated
directly except to push and pop frames, frames may be heap allocated. The memory
for a Java virtual machine stack does not need to be contiguous.
In the first edition The Java of Virtual Machine Specification, the Java virtual machine
stack was known as the Java stack.
This specification permits Java virtual machine stacks either to be of a fixed size
or to dynamically expand and contract as required by the computation. If the Java
virtual machine stacks are of a fixed size, the size of each Java virtual machine
stack may be chosen independently when that stack is created.
A Java virtual machine implementation may provide the programmer or the user control
over the initial size of Java virtual machine stacks, as well as, in the case of dynamically
expanding or contracting Java virtual machine stacks, control over the maximum and
minimum sizes.
The following exceptional conditions are associated with Java virtual machine
stacks:
 If the computation in a thread requires a larger Java virtual machine stack than
is permitted, the Java virtual machine throws a StackOverflowError.
 If Java virtual machine stacks can be dynamically expanded, and expansion is
attempted but insufficient memory can be made available to effect the expansion,
or if insufficient memory can be made available to create the initial Java
12
--------------------------------------- 31
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEHeap2.5.3
virtual machine stack for a new thread, the Java virtual machine throws an
OutOfMemoryError.
2.5.3Heap
The Java virtual machine heap has that a is shared among all Java virtual machine
threads. The heap is the runtime data area from which memory for all class
instances and arrays is allocated.
The heap is created on virtual machine start-up. Heap storage for objects is
reclaimed by an automatic storage management system garbage(known as a 
collector); objects are never explicitly deallocated. The Java virtual machine
assumes no particular type of automatic storage management system, and the
storage management technique may be chosen according to the implementor's
system requirements. The heap may be of a fixed size or may be expanded as
required by the computation and may be contracted if a larger heap becomes
unnecessary. The memory for the heap does not need to be contiguous.
A Java virtual machine implementation may provide the programmer or the user control
over the initial size of the heap, as well as, if the heap can be dynamically expanded or
contracted, control over the maximum and minimum heap size.
The following exceptional condition is associated with the heap:
 If a computation requires more heap than can be made available by the
automatic storage management system, the Java virtual machine throws an
OutOfMemoryError.
2.5.4Method Area
The Java virtual machine method has areaa  that is shared among all Java virtual
machine threads. The method area is analogous to the storage area for compiled
code of a conventional language or analogous to the "text" segment in an operating
system process. It stores per-class structures such as the runtime constant pool, field
and method data, and the code for methods and constructors, including the special
methods 2.9( ) used in class and instance initialization and interface initialization.
The method area is created on virtual machine start-up. Although the method area is
logically part of the heap, simple implementations may choose not to either garbage
collect or compact it. This version of the Java virtual machine specification does not
mandate the location of the method area or the policies used to manage compiled
code. The method area may be of a fixed size or may be expanded as required by the
13
--------------------------------------- 32
2.5.5 Runtime Constant PoolTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
computation and may be contracted if a larger method area becomes unnecessary.
The memory for the method area does not need to be contiguous.
A Java virtual machine implementation may provide the programmer or the user control
over the initial size of the method area, as well as, in the case of a varying-size method area,
control over the maximum and minimum method area size.
The following exceptional condition is associated with the method area:
 If memory in the method area cannot be made available to satisfy an allocation
request, the Java virtual machine throws an OutOfMemoryError.
2.5.5Runtime Constant Pool
A runtime constant  is poola per-class or per-interface runtime representation
of the constant_pool table in classa  file 4.4(). It contains several kinds of
constants, ranging from numeric literals known at compile-time to method and field
references that must be resolved at runtime. The runtime constant pool serves a
function similar to that of a symbol table for a conventional programming language,
although it contains a wider range of data than a typical symbol table.
Each runtime constant pool is allocated from the Java virtual machine's method
area 2.5.4( ). The runtime constant pool for a class or interface is constructed when
the class or interface is created (5.3) by the Java virtual machine.
The following exceptional condition is associated with the construction of the
runtime constant pool for a class or interface:
 When creating a class or interface, if the construction of the runtime constant
pool requires more memory than can be made available in the method area of the
Java virtual machine, the Java virtual machine throws an OutOfMemoryError.
See 5 for information about the construction of the runtime constant pool.
2.5.6Native Method Stacks
An implementation of the Java virtual machine may use conventional stacks,
colloquially called "C stacks," nativeto  methods support (methods written in a
language other than the Java programming language). Native method stacks may
also be used by the implementation of an interpreter for the Java virtual machine's
instruction set in a language such as C. Java virtual machine implementations
that cannot nativeload  methods and that do not themselves rely on conventional
stacks need not supply native method stacks. If supplied, native method stacks are
typically allocated per thread when each thread is created.
14
--------------------------------------- 33
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEFrames2.6
This specification permits native method stacks either to be of a fixed size or to
dynamically expand and contract as required by the computation. If the native
method stacks are of a fixed size, the size of each native method stack may be
chosen independently when that stack is created.
A Java virtual machine implementation may provide the programmer or the user control
over the initial size of the native method stacks, as well as, in the case of varying-size native
method stacks, control over the maximum and minimum method stack sizes.
The following exceptional conditions are associated with native method stacks:
 If the computation in a thread requires a larger native method stack than is
permitted, the Java virtual machine throws a StackOverflowError.
 If native method stacks can be dynamically expanded and native method stack
expansion is attempted but insufficient memory can be made available, or if
insufficient memory can be made available to create the initial native method
stack for a new thread, the Java virtual machine throws an OutOfMemoryError.
2.6 Frames
A frame is used to store data and partial results, as well as to perform dynamic
linking, return values for methods, and dispatch exceptions.
A new frame is created each time a method is invoked. A frame is destroyed when
its method invocation completes, whether that completion is normal or abrupt (it
throws an uncaught exception). Frames are allocated from the Java virtual machine
stack 2.5.2( ) of the thread creating the frame. Each frame has its own array of local
variables 2.6.1(), its own operand 2.6.2stack ), and ( a reference to the runtime
constant pool (2.5.5) of the class of the current method.
A frame may be extended with additional implementation-specific information, such as
debugging information.
The sizes of the local variable array and the operand stack are determined at
compile-time and are supplied along with the code for the method associated with
the frame 4.7.3( ). Thus the size of the frame data structure depends only on the
implementation of the Java virtual machine, and the memory for these structures
can be allocated simultaneously on method invocation.
Only one frame, the frame for the executing method, is active at any point in a given
thread of control. This frame is current referred frameto , and as its the method is
known as the current method. The class in which the current method is defined is
15
--------------------------------------- 34
2.6.1 Local VariablesTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
the current class. Operations on local variables and the operand stack are typically
with reference to the current frame.
A frame ceases to be current if its method invokes another method or if its method
completes. When a method is invoked, a new frame is created and becomes current
when control transfers to the new method. On method return, the current frame
passes back the result of its method invocation, if any, to the previous frame. The
current frame is then discarded as the previous frame becomes the current one.
Note that a frame created by a thread is local to that thread and cannot be referenced
by any other thread.
2.6.1Local Variables
Each frame 2.6() contains an array of variables local known variablesas . Theits 
length of the local variable array of a frame is determined at compile-time and
supplied in the binary representation of a class or interface along with the code for
the method associated with the frame (4.7.3).
A single local variable can hold booleana value , byteof , chartype , short, int,
float, reference, or returnAddress. A pair of local variables can hold a value
of type long or double.
Local variables are addressed by indexing. The index of the first local variable is
zero. An integer is considered to be an index into the local variable array if and only
if that integer is between zero and one less than the size of the local variable array.
A value of longtype  or type double occupies two consecutive local variables.
Such a value may only be addressed using the lesser index. For example, a value of
type double stored in the local variable n actually array at occupies index the local
variables with nindices  and n+1; however, the local variable n+1 cannotat index 
be loaded from. It can be stored into. However, doing so invalidates the contents
of local variable n.
The Java virtual machine does n not to be require even. In intuitive terms, values
of types long and double need not be 64-bit aligned in the local variables array.
Implementors are free to decide the appropriate way to represent such values using
the two local variables reserved for the value.
The Java virtual machine uses local variables to pass parameters on method
invocation. On class method invocation, any parameters are passed in consecutive
local variables starting from 0. local On instance variable method invocation,
local variable 0 is always used to pass a reference to the object on which the
instance method is being thisinvoked  in the ( Java programming language). Any
16
--------------------------------------- 35
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEOperand Stacks2.6.2
parameters are subsequently passed in consecutive local variables starting from
local variable 1.
2.6.2Operand Stacks
Each frame 2.6() contains a last-in-first-out (LIFO) operandstack known as its 
stack. The maximum depth of the operand stack of a frame is determined at
compile-time and is supplied along with the code for the method associated with
the frame (4.7.3).
Where it is clear by context, we will sometimes refer to the operand stack of the
current frame as simply the operand stack.
The operand stack is empty when the frame that contains it is created. The
Java virtual machine supplies instructions to load constants or values from local
variables or fields onto the operand stack. Other Java virtual machine instructions
take operands from the operand stack, operate on them, and push the result back
onto the operand stack. The operand stack is also used to prepare parameters to be
passed to methods and to receive method results.
For example, iaddthe  instruction iadd) ( adds two int values together. It requires
that the int values to be added be the top two values of the operand stack, pushed
there by previous instructions. int values Both of are the popped from the operand
stack. They are added, and their sum is pushed back onto the operand stack.
Subcomputations may be nested on the operand stack, resulting in values that can
be used by the encompassing computation.
Each entry on the operand stack can hold a value of any Java virtual machine type,
including a value of type long or type double.
Values from the operand stack must be operated upon in ways appropriate to their
types. It is not possible, for example, int values to push and two subsequently
treat them longas  a or to push floattwo  values and subsequently add them with
an iadd instruction. A small number of Java virtual machine dupinstructions (the 
instructions dup) (and swap (swap)) operate on runtime data areas as raw values
without regard to their specific types; these instructions are defined in such a way
that they cannot be used to modify or break up individual values. These restrictions
on operand stack manipulation are enforced class file through verification 4.10). (
At any point in time, an operand stack has an associated depth, where a value of
type long or double contributes two units to the depth and a value of any other
type contributes one unit.
17
--------------------------------------- 36
2.6.3 Dynamic LinkingTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
2.6.3Dynamic Linking
Each frame 2.6() contains a reference to the runtime 2.5.5constant ) forpool (
the type of the current method dynamic to support linking of the method code.
The class file code for a method refers to methods to be invoked and variables
to be accessed via symbolic references. Dynamic linking translates these symbolic
method references into concrete method references, loading classes as necessary to
resolve as-yet-undefined symbols, and translates variable accesses into appropriate
offsets in storage structures associated with the runtime location of these variables.
This late binding of the methods and variables makes changes in other classes that
a method uses less likely to break this code.
2.6.4Normal Method Invocation Completion
A method invocation completes normally if that invocation does not cause an
exception 2.10() to be thrown, either directly from the Java virtual machine or as
a result of executing throwan explicit  statement. If the invocation of the current
method completes normally, then a value may be returned to the invoking method.
This occurs when the invoked method executes one of the return instructions
(2.11.8), the choice of which must be appropriate for the type of the value being
returned (if any).
The current frame 2.6) (is used in this case to restore the state of the invoker,
including its local variables and operand stack, with the program counter of the
invoker appropriately incremented to skip past the method invocation instruction.
Execution then continues normally in the invoking method's frame with the
returned value (if any) pushed onto the operand stack of that frame.
2.6.5Abrupt Method Invocation Completion
A method invocation completes abruptly if execution of a Java virtual machine
instruction within the method causes the Java virtual machine to throw an exception
(2.10), and that exception is not handled within the method. Execution of an
athrow instruction athrow() also causes an exception to be explicitly thrown and,
if the exception is not caught by the current method, results in abrupt method
invocation completion. A method invocation that completes abruptly never returns
a value to its invoker.
18
--------------------------------------- 37
THE STRUCTURE OF THE JAVA VIRTUAL MACHINERepresentation of Objects2.7
2.7 Representation of Objects
The Java virtual machine does not mandate any particular internal structure for
objects.
In some of Oracles implementations of the Java virtual machine, a reference to a class
instance is a pointer handle to that a is itself a pair of pointers: one to a table containing
the methods of the object and a Classpointer  object to that the represents the type of the
object, and the other to the memory allocated from the heap for the object data.
2.8 Floating-Point Arithmetic
The Java virtual machine incorporates a subset of the floating-point arithmetic
specified IEEE in Standard for Binary Floating-Point  (ANSI/IEEE ArithmeticStd.
754-1985, New York).
2.8.1Java Virtual Machine Floating-Point Arithmetic and IEEE 754
The key differences between the floating-point arithmetic supported by the Java
virtual machine and the IEEE 754 standard are:
 The floating-point operations of the Java virtual machine do not throw
exceptions, trap, or otherwise signal the IEEE 754 exceptional conditions of
invalid operation, division by zero, overflow, underflow, or inexact. The Java
virtual machine has no signaling NaN value.
 The Java virtual machine does not support IEEE 754 signaling floating-point
comparisons.
 The rounding operations of the Java virtual machine always use IEEE 754 round
to nearest mode. Inexact results are rounded to the nearest representable value,
with ties going to the value with a zero least-significant bit. This is the IEEE
754 default mode. But Java virtual machine instructions that convert values of
floating-point types to values of integral types round toward zero. The Java
virtual machine does not give any means to change the floating-point rounding
mode.
 The Java virtual machine does not support either the IEEE 754 single extended
or double extended format, except insofar as the double and double-extended-
exponent value sets may be said to support the single extended format. The
float-extended-exponent and double-extended-exponent value sets, which may
optionally be supported, do not correspond to the values of the IEEE 754
19
--------------------------------------- 38
2.8.2 Floating-Point ModesTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
extended formats: the IEEE 754 extended formats require extended precision as
well as extended exponent range.
2.8.2Floating-Point Modes
Every method has floating-point a , modewhich is either FP-strict or not FP-
strict. The floating-point mode of a method is determined by the setting of the
ACC_STRICT flag of access_flagsthe  item of method_infothe  structure 4.6)(
defining the method. A method for which this flag is set is FP-strict; otherwise, the
method is not FP-strict.
Note that this mapping ACC_STRICTof the  flag implies that methods in classes compiled
by a compiler in JDK release 1.1 or earlier are effectively not FP-strict.
We will refer to an operand stack as having a given floating-point mode when the
method whose invocation created the frame containing the operand stack has that
floating-point mode. Similarly, we will refer to a Java virtual machine instruction
as having a given floating-point mode when the method containing that instruction
has that floating-point mode.
If a float-extended-exponent value 2.3.2set ), is values supported of floattype (
on an operand stack that is not FP-strict may range over that value set except
where prohibited by value set 2.8.3conversion ). If a double-extended-exponent(
value set is supported 2.3.2), values (of doubletype  on an operand stack that is
not FP-strict may range over that value set except where prohibited by value set
conversion.
In all other contexts, whether on the operand stack or elsewhere, and regardless
of floating-point mode, floating-point floatvalues  and doubleof  may type only
range over the float value set and double value set, respectively. In particular, class
and instance fields, array elements, local variables, and method parameters may
only contain values drawn from the standard value sets.
2.8.3Value Set Conversion
An implementation of the Java virtual machine that supports an extended floating-
point value set is permitted or required, under specified circumstances, to map a
value of the associated floating-point type between the extended and the standard
value sets. Such value a set conversion is not a type conversion, but a mapping
between the value sets associated with the same type.
Where value set conversion is indicated, an implementation is permitted to perform
one of the following operations on a value:
20
--------------------------------------- 39
THE STRUCTURE OF THE JAVA VIRTUAL MACHINESpecial Methods2.9
 If the value is floatof  type and is not an element of the float value set, it maps
the value to the nearest element of the float value set.
 If the value is doubleof type  and is not an element of the double value set, it
maps the value to the nearest element of the double value set.
In addition, where value set conversion is indicated, certain operations are required:
 Suppose execution of a Java virtual machine instruction that is not FP-strict
causes a value floatof type  to be pushed onto an operand stack that is FP-strict,
passed as a parameter, or stored into a local variable, a field, or an element of an
array. If the value is not an element of the float value set, it maps the value to
the nearest element of the float value set.
 Suppose execution of a Java virtual machine instruction that is not FP-strict
causes a value of doubletype  to be pushed onto an operand stack that is FP-
strict, passed as a parameter, or stored into a local variable, a field, or an element
of an array. If the value is not an element of the double value set, it maps the
value to the nearest element of the double value set.
Such required value set conversions may occur as a result of passing a parameter
of a floating-point type during method invocation, native methodincluding 
invocation; returning a value of a floating-point type from a method that is not FP-
strict to a method that is FP-strict; or storing a value of a floating-point type into a
local variable, a field, or an array in a method that is not FP-strict.
Not all values from an extended-exponent value set can be mapped exactly to a
value in the corresponding standard value set. If a value being mapped is too large
to be represented exactly (its exponent is greater than that permitted by the standard
value set), it is converted to a (positive or negative) infinity of the corresponding
type. If a value being mapped is too small to be represented exactly (its exponent
is smaller than that permitted by the standard value set), it is rounded to the nearest
of a representable denormalized value or zero of the same sign.
Value set conversion preserves infinities and NaNs and cannot change the sign of
the value being converted. Value set conversion has no effect on a value that is not
of a floating-point type.
2.9 Special Methods
At the level of the Java virtual machine, every constructor written in the Java
programming language (JLS 8.8) appears instance as initialization an method
that has the special <init>name . This name is supplied by a compiler. Because
21
--------------------------------------- 40
2.9Special MethodsTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
the name <init> is not a valid identifier, it cannot be used directly in a program
written in the Java programming language. Instance initialization methods may
be invoked only within the Java virtual invokespecialmachine  instructionby the 
(invokespecial), and they may be invoked only on uninitialized class instances.
An instance initialization method takes on the access permissions (JLS 6.6) of the
constructor from which it was derived.
A class or interface has class at most or one interface initialization  and is method
initialized 5.5) (by invoking that method. The initialization method of a class or
interface has the special <clinit>name , takes no arguments, and 4.3.3is ).void (
Other methods named <clinit> in classa  file are of no consequence. They are not class
or interface initialization methods. They cannot be invoked by any Java virtual machine
instruction and are never invoked by the Java virtual machine itself.
In a class file whose version number is 51.0 or above, the method must
additionally have ACC_STATICits  flag 4.6() set in order to be the class or interface
initialization method.
This requirement is new in Java SE 7. In a class file whose version number is 50.0 or below,
a method named <clinit> that is void and takes no arguments is considered the class or
interface initialization method regardless of the setting of its ACC_STATIC flag.
The name <clinit> is supplied by a compiler. Because <clinit>the  isname 
not a valid identifier, it cannot be used directly in a program written in the Java
programming language. Class and interface initialization methods are invoked
implicitly by the Java virtual machine; they are never invoked directly from any
Java virtual machine instruction, but are invoked only indirectly as part of the class
initialization process.
A method signature is polymorphic if and only if all of the following conditions
hold :
 It is declared in the java.lang.invoke.MethodHandle class.
 It has a single formal parameter of type Object[].
 It has a return type of Object.
 It has the ACC_VARARGS and ACC_NATIVE flags set.
In Java SE 7, the only signature polymorphic invokemethods  and invokeExactare the 
methods of the class java.lang.invoke.MethodHandle.
The Java virtual machine gives special treatment to signature polymorphic methods
in the invokevirtual instruction invokevirtual(), in order to effect invocation of a
22
--------------------------------------- 41
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEExceptions 2.10
method handle. A method handle is a typed, directly executable reference to an
underlying method, constructor, field, or similar 5.4.3.5low-level ),operation (
with optional transformations of arguments or return values. These transformations
are quite general, and include such patterns as conversion, insertion, deletion, and
substitution. java.lang.invokeSee the  package in the Java SE platform API for
more information.
2.10Exceptions
An exception in the Java virtual machine is represented by an instance of the class
Throwable or one of its subclasses. Throwing an exception results in an immediate
nonlocal transfer of control from the point where the exception was thrown.
Most exceptions occur synchronously as a result of an action by the thread in which
they occur. An asynchronous exception, by contrast, can potentially occur at any
point in the execution of a program. The Java virtual machine throws an exception
for one of three reasons:
 An athrow instruction (athrow) was executed.
 An abnormal execution condition was synchronously detected by the Java virtual
machine. These exceptions are not thrown at an arbitrary point in the program,
but only synchronously after execution of an instruction that either:
Specifies the exception as a possible result, such as:
VWhen the instruction embodies an operation that violates the semantics of
the Java programming language, for example indexing outside the bounds
of an array.
VWhen an error occurs in loading or linking part of the program.
Causes some limit on a resource to be exceeded, for example when too much
memory is used.
 An asynchronous exception occurred because:
The stop method of class Thread or ThreadGroup was invoked, or
An internal error occurred in the Java virtual machine implementation.
The stop methods may be invoked by one thread to affect another thread or all
the threads in a specified thread group. They are asynchronous because they may
occur at any point in the execution of the other thread or threads. An internal
error is considered asynchronous (6.3).
23
--------------------------------------- 42
2.10ExceptionsTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
A Java virtual machine may permit a small but bounded amount of execution to
occur before an asynchronous exception is thrown. This delay is permitted to allow
optimized code to detect and throw these exceptions at points where it is practical
to handle them while obeying the semantics of the Java programming language.
A simple implementation might poll for asynchronous exceptions at the point of each
control transfer instruction. Since a program has a finite size, this provides a bound
on the total delay in detecting an asynchronous exception. Since no asynchronous
exception will occur between control transfers, the code generator has some flexibility
to reorder computation between control transfers for greater performance. The paper
Polling Efficiently on Stock  by HardwareMarc Feeley, Proc. 1993 Conference on
Functional Programming and Computer , ArchitectureCopenhagen, Denmark, pp. 179-
187, is recommended as further reading.
Exceptions thrown by the Java virtual machine are precise: when the transfer of
control takes place, all effects of the instructions executed before the point from
which the exception is thrown must appear to have taken place. No instructions that
occur after the point from which the exception is thrown may appear to have been
evaluated. If optimized code has speculatively executed some of the instructions
which follow the point at which the exception occurs, such code must be prepared
to hide this speculative execution from the user-visible state of the program.
Each method in the Java virtual machine may be associated with zero or more
exception handlers. An exception handler specifies the range of offsets into the Java
virtual machine code implementing the method for which the exception handler
is active, describes the type of exception that the exception handler is able to
handle, and specifies the location of the code that is to handle that exception. An
exception matches an exception handler if the offset of the instruction that caused
the exception is in the range of offsets of the exception handler and the exception
type is the same class as or a subclass of the class of exception that the exception
handler handles. When an exception is thrown, the Java virtual machine searches
for a matching exception handler in the current method. If a matching exception
handler is found, the system branches to the exception handling code specified by
the matched handler.
If no such exception handler is found in the current method, the current method
invocation completes abruptly 2.6.5). On ( abrupt completion, the operand stack
and local variables of the current method invocation are discarded, and its frame
is popped, reinstating the frame of the invoking method. The exception is then
rethrown in the context of the invoker's frame and so on, continuing up the method
invocation chain. If no suitable exception handler is found before the top of the
method invocation chain is reached, the execution of the thread in which the
exception was thrown is terminated.
24
--------------------------------------- 43
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEInstruction Set Summary2.11
The order in which the exception handlers of a method are searched for a match is
important. Within class a file, the exception handlers for each method are stored in
a table 4.7.3( ). At runtime, when an exception is thrown, the Java virtual machine
searches the exception handlers of the current method in the order that they appear
in the corresponding exception handler class table file, in starting the from the
beginning of that table.
Note that the Java virtual machine does not enforce nesting of or any ordering of
the exception table entries of a method. The exception handling semantics of the
Java programming language are implemented only through cooperation with the
compiler 3.12( ). When class files are generated by some other means, the defined
search procedure ensures that all Java virtual machine implementations will behave
consistently.
2.11Instruction Set Summary
A Java virtual machine instruction consists opcodeof  specifyinga one-byte 
the operation to be performed, followed operandsby zero  supplyingor more 
arguments or data that are used by the operation. Many instructions have no
operands and consist only of an opcode.
Ignoring exceptions, the inner loop of a Java virtual machine interpreter is
effectively
do {
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
The number and size of the operands are determined by the opcode. If an operand
is more than one byte in size, then big-endianit is  order stored - high-order in byte
first. For example, an unsigned 16-bit index into the local variables is stored as two
unsigned bytes, byte1 and byte2, such that its value is (byte1 << 8) | byte2.
The bytecode instruction stream is only single-byte aligned. The two exceptions
are the lookupswitch and tableswitch instructions lookupswitch(, tableswitch),
which are padded to force internal alignment of some of their operands on 4-byte
boundaries.
The decision to limit the Java virtual machine opcode to a byte and to forgo data alignment
within compiled code reflects a conscious bias in favor of compactness, possibly at the cost
of some performance in naive implementations. A one-byte opcode also limits the size of
25
--------------------------------------- 44
2.11.1 Types and the Java Virtual MachineTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
the instruction set. Not assuming data alignment means that immediate data larger than a
byte must be constructed from bytes at runtime on many machines.
2.11.1Types and the Java Virtual Machine
Most of the instructions in the Java virtual machine instruction set encode type
information about the operations they perform. iload For instructioninstance, the 
(iload) loads the contents of a local variable, int, which onto must the be an 
operand stack. floadThe  instruction fload) ( does the same floatwith  value. a The
two instructions may have identical implementations, but have distinct opcodes.
For the majority of typed instructions, the instruction type is represented explicitly
in the opcode mnemonic by i for a letter: intan  operation, l for long, s for short,
b for byte, c for char, f for float, d for double, and a for reference. Some
instructions for which the type is unambiguous do not have a type letter in their
mnemonic. For instance, arraylength always operates on an object that is an array.
Some instructions, gotosuch , an as unconditional control transfer, do not operate
on typed operands.
Given the Java virtual machine's one-byte opcode size, encoding types into opcodes
places pressure on the design of its instruction set. If each typed instruction
supported all of the Java virtual machine's runtime data types, there would be
more instructions than could be represented in a byte. Instead, the instruction set
of the Java virtual machine provides a reduced level of type support for certain
operations. In other words, the instruction set is intentionally not orthogonal.
Separate instructions can be used to convert between unsupported and supported
data types as necessary.
Table 2.2 summarizes the type support in the instruction set of the Java virtual
machine. A specific instruction, with type information, T is built by replacing the 
in the instruction template in the opcode column by the letter in the type column. If
the type column for some instruction template and type is blank, then no instruction
exists supporting that type of operation. For instance, there is a load instruction for
type int, iload, but there is no load instruction for type byte.
Note that most instructions Table 2.2 in do not have forms for the integral
types byte, char, and short. None have forms booleanfor the  type. Compilers
encode loads of literal values byte and of shorttypes  using Java virtual machine
instructions that sign-extend those values int to at values compile-timeof type 
or runtime. Loads of literal booleanvalues  and of chartypes  are encoded using
instructions that zero-extend the literal int to at compile-time a value of type or
runtime. Likewise, loads from arrays booleanof values , byte, of shorttype , and
char are encoded using Java virtual machine instructions that sign-extend or zero-
26
--------------------------------------- 45
THE STRUCTURE OF THE JAVA VIRTUAL MACHINE Types and the Java Virtual 2.11.1Machine
extend the values to values int. Thus, of type most operations on values of actual
types boolean, byte, char, and short are correctly performed by instructions
operating on values of computational type int.
27
--------------------------------------- 46
2.11.1 Types and the Java Virtual MachineTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
Table 2.2. Type support in the Java virtual machine instruction set
opcode byteshortintlongfloatdouble charreference
Tipush bipush sipush
Tconsticonst lconst fconst dconstaconst
Tloadiload lload fload dloadaload
Tstoreistore lstore fstore dstoreastore
Tinciinc
Taload baload saload iaload laload faload daload caload aaload
Tastorebastoresastoreiastorelastorefastoredastorecastoreaastore
Taddiaddladdfadddadd
Tsubisublsubfsubdsub
Tmulimullmulfmuldmul
Tdividivldivfdivddiv
Tremiremlremfremdrem
Tnegineglnegfnegdneg
Tshlishllshl
Tshrishrlshr
Tushriushr lushr
Tandiandland
Toriorlor
Txorixorlxor
i2Ti2bi2si2li2fi2d
l2Tl2il2fl2d
f2Tf2if2lf2d
d2Td2id2ld2f
Tcmplcmp
Tcmplfcmpl dcmpl
Tcmpgfcmpg dcmpg
if_TcmpOPif_icmpOPif_acmpOP
Treturnireturnlreturnfreturndreturnareturn
28
--------------------------------------- 47
THE STRUCTURE OF THE JAVA VIRTUAL MACHINELoad and Store Instructions2.11.2
The mapping between Java virtual machine actual types and Java virtual machine
computational types is summarized by Table 2.3.
Certain Java virtual machine instructions pop and swapsuch  operate as on the
operand stack without regard to type; however, such instructions are constrained
to use only on values of certain categories of computational types, also given in
Table 2.3.
Table 2.3. Java virtual machine actual and computational types
Actual typeComputational typeCategory
booleanintcategory 1
byteintcategory 1
charintcategory 1
shortintcategory 1
intintcategory 1
floatfloatcategory 1
referencereferencecategory 1
returnAddressreturnAddresscategory 1
longlongcategory 2
doubledoublecategory 2
2.11.2Load and Store Instructions
The load and store instructions transfer values between 2.6.1) the local variables (
and the operand stack (2.6.2) of a Java virtual machine frame (2.6):
 Load a local variable onto the operand iload, iload_<n>stack: , lload,
lload_<n>, fload, fload_<n>, dload, dload_<n>, aload, aload_<n>.
 Store a value from the operand stack into istorea , istore_<n>local variable: ,
lstore, lstore_<n>, fstore, fstore_<n>, dstore, dstore_<n>, astore, astore_<n>.
 Load a constant on to the operand bipush, sipushstack: , ldc, ldc_w, ldc2_w,
aconst_null, iconst_m1, iconst_<i>, lconst_<l>, fconst_<f>, dconst_<d>.
 Gain access to more local variables using a wider index, or to a larger immediate
operand: wide.
Instructions that access fields of objects and 2.11.5elements ) also of arrays (
transfer data to and from the operand stack.
29
--------------------------------------- 48
2.11.3 Arithmetic InstructionsTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
Instruction mnemonics shown above with trailing letters between angle brackets
(for instance, iload_<n>) denote families of instructions iload_0(with , members 
iload_1, iload_2, and iload_3 in the case iload_<n>of ). Such families of
instructions are specializations of an additional iload) generic that takesinstruction (
one operand. For the specialized instructions, the operand is implicit and does not
need to be stored or fetched. The semantics are iload_0otherwise  means the same (
the same thing iloadas  with the operand 0). The letter between the angle brackets
specifies the type of the implicit operand for that <n>family ,of instructions: for 
a nonnegative integer; <i>, an for int; for <l>, a long; for <f>, a float; and for
<d>, a double. Forms for inttype  are used in many cases to perform operations
on values of type byte, char, and short (2.11.1).
This notation for instruction families is used throughout this specification.
2.11.3Arithmetic Instructions
The arithmetic instructions compute a result that is typically a function of two
values on the operand stack, pushing the result back on the operand stack. There
are two main kinds of arithmetic instructions: those operating on integer values and
those operating on floating-point values. Within each of these kinds, the arithmetic
instructions are specialized to Java virtual machine numeric types. There is no
direct support for integer arithmetic byteon , shortvalues , and charof  the types
(2.11.1), or for values booleanof the  type; those operations are handled by
instructions operating inton . Integer type and floating-point instructions also
differ in their behavior on overflow and divide-by-zero. The arithmetic instructions
are as follows:
 Add: iadd, ladd, fadd, dadd.
 Subtract: isub, lsub, fsub, dsub.
 Multiply: imul, lmul, fmul, dmul.
 Divide: idiv, ldiv, fdiv, ddiv.
 Remainder: irem, lrem, frem, drem.
 Negate: ineg, lneg, fneg, dneg.
 Shift: ishl, ishr, iushr, lshl, lshr, lushr.
 Bitwise OR: ior, lor.
 Bitwise AND: iand, land.
 Bitwise exclusive OR: ixor, lxor.
30
--------------------------------------- 49
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEArithmetic Instructions2.11.3
 Local variable increment: iinc.
 Comparison: dcmpg, dcmpl, fcmpg, fcmpl, lcmp.
The semantics of the Java programming language operators on integer and floating-
point values (JLS 4.2.2, JLS 4.2.4) are directly supported by the semantics of
the Java virtual machine instruction set.
The Java virtual machine does not indicate overflow during operations on integer
data types. The only integer operations that can throw an exception are the integer
divide instructions idiv and ldiv( ) and the integer remainder ireminstructions  and(
lrem), which throw an ArithmeticException if the divisor is zero.
Java virtual machine operations on floating-point numbers behave as specified in
IEEE 754. In particular, the Java virtual machine requires full support of IEEE 754
denormalized floating-point numbers gradual and underflow, which make it easier
to prove desirable properties of particular numerical algorithms.
The Java virtual machine requires that floating-point arithmetic behave as if every
floating-point operator rounded its floating-point result to the result precision.
Inexact results must be rounded to the representable value nearest to the infinitely
precise result; if the two nearest representable values are equally near, the one
having a least significant bit of zero is chosen. This is the IEEE 754 standard's
default rounding mode, known as round to nearest mode.
The Java virtual machine uses the round IEEE towards 754  zeromode when
converting a floating-point value to an integer. This results in the number being
truncated; any bits of the significand that represent the fractional part of the operand
value are discarded. Round towards zero mode chooses as its result the type's value
closest to, but no greater in magnitude than, the infinitely precise result.
The Java virtual machine's floating-point operators do not throw runtime
exceptions (not to be confused with IEEE 754 floating-point exceptions). An
operation that overflows produces a signed infinity, an operation that underflows
produces a denormalized value or a signed zero, and an operation that has no
mathematically definite result produces NaN. All numeric operations with NaN as
an operand produce NaN as a result.
Comparisons on values of long type (lcmp) perform a signed comparison.
Comparisons on values of floating-point dcmpg, dcmpltypes , fcmpg(, fcmpl) are
performed using IEEE 754 nonsignaling comparisons.
31
--------------------------------------- 50
2.11.4 Type Conversion InstructionsTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
2.11.4Type Conversion Instructions
The type conversion instructions allow conversion between Java virtual machine
numeric types. These may be used to implement explicit conversions in user code
or to mitigate the lack of orthogonality in the instruction set of the Java virtual
machine.
The Java virtual machine directly supports the following widening numeric
conversions:
int to long, float, or double
long to float or double
float to double
The widening numeric conversion instructions i2l, i2f, i2d, l2f, l2dare , and f2d. The
mnemonics for these opcodes are straightforward given the naming conventions
for typed instructions and the punning use of 2 to mean "to." For instance, the
i2d instruction converts int value an to doublea . Widening numeric conversions
do not lose information about the overall magnitude of a numeric value. Indeed,
conversions widening intfrom  to long and int to double do not lose any
information at all; the numeric value is preserved exactly. Conversions widening
from float to double that are FP-strict 2.8.2) also (preserve the numeric value
exactly; however, such conversions that are not FP-strict may lose information
about the overall magnitude of the converted value.
Conversion of intan  or longa  value floatto , or of longa  value doubleto , may
lose precision, that is, may lose some of the least significant bits of the value; the
resulting floating-point value is a correctly rounded version of the integer value,
using IEEE 754 round to nearest mode.
A widening numeric conversion int to of longa an  simply sign-extends the two's-
complement representation int of value the to fill the wider format. A widening
numeric conversion charof  to a an integral type zero-extends the representation
of the char value to fill the wider format.
Despite the fact that loss of precision may occur, widening numeric conversions
never cause the Java virtual machine to throw a runtime exception (not to be
confused with an IEEE 754 floating-point exception).
Note that widening numeric conversions do not exist bytefrom ,integral types 
char, and short to type int. As noted 2.11.1in , values of bytetype , char, and
short are internally widened to type int, making these conversions implicit.
32
--------------------------------------- 51
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEType Conversion Instructions2.11.4
The Java virtual machine also directly supports the following narrowing numeric
conversions:
int to byte, short, or char
long to int
float to int or long
double to int, long, or float
The narrowing numeric conversion instructions i2b, i2c, i2s, l2i, f2iare , f2l, d2i,
d2l, and d2f. A narrowing numeric conversion can result in a value of different
sign, a different order of magnitude, or both; it may thereby lose precision.
A narrowing numeric conversion int or of longan  to an integral T simplytype 
discards all but N lowest-order the bits, N is where the number of bits used to
represent Ttype . This may cause the resulting value not to have the same sign as
the input value.
In a narrowing numeric conversion of a floating-point T,value to an integral type 
where T is either int or long, the floating-point value is converted as follows:
 If the floating-point value is NaN, the result int of or longthe  0.conversion is an 
 Otherwise, if the floating-point value is not an infinity, the floating-point value
is rounded to an integer V using value IEEE 754 round towards zero mode. There
are two cases:
If T is long and this integer value can be longrepresented , then the as resulta 
is the long value V.
If T is of type int and this integer value can be represented int, thenas an 
the result is the int value V.
 Otherwise:
Either the value must be too small (a negative value of large magnitude or
negative infinity), and the result is the smallest intrepresentable value of type 
or long.
Or the value must be too large (a positive value of large magnitude or positive
infinity), and the result is the largest representable value of type int or long.
A narrowing numeric conversion doublefrom  to float behaves in accordance
with IEEE 754. The result is correctly rounded using IEEE 754 round to nearest
mode. A value too small to be represented float is converted as a to a positive
or negative zero floatof type ; a value too large to be represented float isas a 
33
--------------------------------------- 52
2.11.5 Object Creation and ManipulationTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
converted to a positive or negative double infinity. NaN is always A converted to
a float NaN.
Despite the fact that overflow, underflow, or loss of precision may occur, narrowing
conversions among numeric types never cause the Java virtual machine to throw a
runtime exception (not to be confused with an IEEE 754 floating-point exception).
2.11.5Object Creation and Manipulation
Although both class instances and arrays are objects, the Java virtual machine
creates and manipulates class instances and arrays using distinct sets of
instructions:
 Create a new class instance: new.
 Create a new array: newarray, anewarray, multianewarray.
 Access fields of staticclasses  fields, (known as class variables) and fields
of class instances static(non- fields, known as instance getfieldvariables): ,
putfield, getstatic, putstatic.
 Load an array component onto the operand baload, caloadstack: , saload, iaload,
laload, faload, daload, aaload.
 Store a value from the operand stack as an bastorearray , castorecomponent: ,
sastore, iastore, lastore, fastore, dastore, aastore.
 Get the length of array: arraylength.
 Check properties of class instances or arrays: instanceof, checkcast.
2.11.6Operand Stack Management Instructions
A number of instructions are provided for the direct manipulation of the operand
stack: pop, pop2, dup, dup2, dup_x1, dup2_x1, dup_x2, dup2_x2, swap.
2.11.7Control Transfer Instructions
The control transfer instructions conditionally or unconditionally cause the Java
virtual machine to continue execution with an instruction other than the one
following the control transfer instruction. They are:
 Conditional branch: ifeq, ifne, iflt, ifle, ifgt, ifge, ifnull, ifnonnull, if_icmpeq,
if_icmpne, if_icmplt, if_icmple, if_icmpgt if_icmpge, if_acmpeq, if_acmpne.
 Compound conditional branch: tableswitch, lookupswitch.
34
--------------------------------------- 53
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEMethod Invocation and Return2.11.8
Instructions
 Unconditional branch: goto, goto_w, jsr, jsr_w, ret.
The Java virtual machine has distinct sets of instructions that conditionally
branch on comparison with intdata  and referenceof  types. It also has distinct
conditional branch instructions that test for the null reference and thus it is not
required to specify a concrete value for null (2.4).
Conditional branches on comparisons between booleandata , byteof ,types 
char, and short are performed intusing  comparison instructions 2.11.1). (A
conditional branch on a comparison between long, data float, of or doubletypes 
is initiated using an instruction that compares intthe  result data and of produces an 
the comparison 2.11.3(). A subsequent int comparison instruction tests this result
and effects the conditional branch. Because int of comparisons, its emphasis theon 
Java virtual machine provides a rich complement of conditional branch instructions
for type int.
All int conditional control transfer instructions perform signed comparisons.
2.11.8Method Invocation and Return Instructions
The following five instructions invoke methods:
 invokevirtual invokes an instance method of an object, dispatching on the
(virtual) type of the object. This is the normal method dispatch in the Java
programming language.
 invokeinterface invokes an interface method, searching the methods
implemented by the particular runtime object to find the appropriate method.
 invokespecial invokes an instance method requiring special handling, whether an
instance initialization 2.9), method privatea ( method, or a superclass method.
 invokestatic invokes a class (static) method in a named class.
 invokedynamic invokes the method which is the target of the call site object
bound to the invokedynamic instruction. The call site object was bound to a
specific lexical occurrence invokedynamicof the  instruction by the Java virtual
machine as a result of running a bootstrap method before the first execution of
the instruction. Therefore, each invokedynamicoccurrence  instruction of an has
a unique linkage state, unlike the other instructions which invoke methods.
The method return instructions, which are distinguished ireturnby return type, are 
(used to return values booleanof , type byte, char, short, or int), lreturn, freturn,
dreturn, and areturn. In addition, returnthe  instruction is used to return from
35
--------------------------------------- 54
2.11.9 Throwing ExceptionsTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
methods declared to be void, instance initialization methods, and class or interface
initialization methods.
2.11.9Throwing Exceptions
An exception is thrown programmatically athrow using instruction. the Exceptions
can also be thrown by various Java virtual machine instructions if they detect an
abnormal condition.
2.11.10Synchronization
The Java virtual machine supports synchronization of both methods and sequences
of instructions within a method by a single synchronization monitor.construct: the 
Method-level synchronization is performed implicitly, as part of method invocation
and return 2.11.8( ). A synchronized method is distinguished in the runtime
constant pool's method_info structure 4.6) ( by the ACC_SYNCHRONIZED flag,
which is checked by the method invocation instructions. When invoking a method
for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes
the method itself, and exits the monitor whether the method invocation completes
normally or abruptly. During the time the executing thread owns the monitor,
no other thread may enter it. If an exception is thrown during invocation of
the synchronized method and synchronizedthe  method does not handle the
exception, the monitor for the method is automatically exited before the exception
is rethrown out of the synchronized method.
Synchronization of sequences of instructions is typically used to encode the
synchronized block of the Java programming language. The Java virtual machine
supplies monitorenterthe  and monitorexit instructions to support such language
constructs. Proper implementation synchronizedof  blocks requires cooperation
from a compiler targeting the Java virtual machine (3.14).
Structured locking is the situation when, during a method invocation, every exit
on a given monitor matches a preceding entry on that monitor. Since there is
no assurance that all code submitted to the Java virtual machine will perform
structured locking, implementations of the Java virtual machine are permitted but
not required to enforce both of the following two rules guaranteeing structured
locking. Let T be a thread and M be a monitor. Then:
1. The number of monitor entries performed T on M during by a method
invocation must equal the number of monitor Texits  on M duringperformed by 
the method invocation whether the method invocation completes normally or
abruptly.
36
--------------------------------------- 55
THE STRUCTURE OF THE JAVA VIRTUAL MACHINEClass Libraries2.12
2. At no point during a method invocation may the number of monitor exits
performed Tby  on M since the method invocation exceed the number of
monitor entries performed by T on M since the method invocation.
Note that the monitor entry and exit automatically performed by the Java virtual
machine when invoking synchronizeda  method are considered to occur during
the calling method's invocation.
2.12Class Libraries
The Java virtual machine must provide sufficient support for the implementation of
the class libraries of the associated platform. Some of the classes in these libraries
cannot be implemented without the cooperation of the Java virtual machine.
Classes that might require special support from the Java virtual machine include
those that support:
 Reflection, such as the classes java.lang.reflectin the package  and the class
Class.
 Loading and creation of a class or interface. The most obvious example is the
class ClassLoader.
 Linking and initialization of a class or interface. The example classes cited above
fall into this category as well.
 Security, such as the classes java.securityin the package  and other classes
such as SecurityManager.
 Multithreading, such as the class Thread.
 Weak references, such as the classes in the package java.lang.ref.
The list above is meant to be illustrative rather than comprehensive. An exhaustive
list of these classes or of the functionality they provide is beyond the scope of
this specification. See the specifications of the Java SE platform class libraries for
details.
2.13Public Design, Private Implementation
Thus far this specification has sketched the public view of the Java virtual machine:
the class file format and the instruction set. These components are vital to
37
--------------------------------------- 56
2.13Public Design, Private ImplementationTHE STRUCTURE OF THE JAVA VIRTUAL MACHINE
the hardware-, operating system-, and implementation-independence of the Java
virtual machine. The implementor may prefer to think of them as a means to
securely communicate fragments of programs between hosts each implementing
the Java platform, rather than as a blueprint to be followed exactly.
It is important to understand where the line between the public design and the
private implementation lies. A Java virtual machine implementation must be
able to read class files and must exactly implement the semantics of the Java
virtual machine code therein. One way of doing this is to take this document
as a specification and to implement that specification literally. But it is also
perfectly feasible and desirable for the implementor to modify or optimize the
implementation within the constraints of this specification. class fileSo long as the 
format can be read and the semantics of its code are maintained, the implementor
may implement these semantics in any way. What is "under the hood" is the
implementor's business, as long as the correct external interface is carefully
maintained.
There are some exceptions: debuggers, profilers, and just-in-time code generators can each
require access to elements of the Java virtual machine that are normally considered to
be under the hood. Where appropriate, Oracle works with other Java virtual machine
implementors and tools vendors to develop common interfaces to the Java virtual machine
for use by such tools, and to promote those interfaces across the industry.
The implementor can use this flexibility to tailor Java virtual machine
implementations for high performance, low memory use, or portability. What
makes sense in a given implementation depends on the goals of that
implementation. The range of implementation options includes the following:
 Translating Java virtual machine code at load-time or during execution into the
instruction set of another virtual machine.
 Translating Java virtual machine code at load-time or during execution into the
native instruction set of the host CPU (sometimes just-in-timereferred , orto as 
JIT, code generation).
The existence of a precisely defined virtual machine and object file format need not
significantly restrict the creativity of the implementor. The Java virtual machine is
designed to support many different implementations, providing new and interesting
solutions while retaining compatibility between implementations.
38
--------------------------------------- 57
CHAPTER3
Compiling for the Java
Virtual Machine
THE Java virtual machine machine is designed to support the Java programming
language. Oracle's JDK software contains a compiler from source code written
in the Java programming language to the instruction set of the Java virtual
machine, and a runtime system that implements the Java virtual machine itself.
Understanding how one compiler utilizes the Java virtual machine is useful to the
prospective compiler writer, as well as to one trying to understand the Java virtual
machine itself. The numbered sections in this chapter are not normative.
Note that the term "compiler" is sometimes used when referring to a translator
from the instruction set of a Java virtual machine to the instruction set of a specific
CPU. One example of such a translator is a just-in-time (JIT) code generator, which
generates platform-specific instructions only after Java virtual machine code has
been loaded. This chapter does not address issues associated with code generation,
only those associated with compiling source code written in the Java programming
language to Java virtual machine instructions.
3.1 Format of Examples
This chapter consists mainly of examples of source code together with annotated
listings of the Java virtual machine code that the javac compiler in Oracles JDK
release 1.0.2 generates for the examples. The Java virtual machine code is written
in the informal virtual machine assembly language javapoutput by Oracle's 
utility, distributed with the JDK release. javap to You generate can use additional
examples of compiled methods.
39
--------------------------------------- 58
3.2Use of Constants, Local Variables, and Control ConstructsCOMPILING FOR THE JAVA
VIRTUAL MACHINE
The format of the examples should be familiar to anyone who has read assembly
code. Each instruction takes the form:
<index> <opcode> [ <operand1> [ <operand2>... ]] [<comment>]
The <index> is the index of the opcode of the instruction in the array that contains
the bytes of Java virtual machine code for this method. <index>Alternatively, the 
may be thought of as a byte offset from the beginning <opcode>of the method. The 
is the mnemonic for the instruction's opcode, <operandN>and the zero or more 
are the operands of the instruction. <comment>The  optional is given in end-of-
line comment syntax:
8   bipush 100     // Push int constant 100
Some of the material in the comments javapis ; emitted the rest by is supplied by
the authors. <index>The  prefacing each instruction may be used as the target of
a control transfer instruction. goto For 8 instance, instruction a transfers control
to the instruction at index 8. Note that the actual operands of Java virtual machine
control transfer instructions are offsets from the addresses of the opcodes of those
instructions; these operands are javapdisplayed  (and are by shown in this chapter)
as more easily read offsets into their methods.
We preface an operand representing a runtime constant pool index with a hash sign
and follow the instruction by a comment identifying the runtime constant pool item
referenced, as in:
10  ldc #1         // Push float constant 100.0
or:
9   invokevirtual #4    // Method Example.addTwo(II)I
For the purposes of this chapter, we do not worry about specifying details such as
operand sizes.
3.2 Use of Constants, Local Variables, and Control Constructs
Java virtual machine code exhibits a set of general characteristics imposed by the
Java virtual machine's design and use of types. In the first example we encounter
many of these, and we consider them in some detail.
The spin method simply spins around an empty for loop 100 times:
void spin() {
40
--------------------------------------- 59
COMPILING FOR THE JAVA VIRTUAL MACHINEUse of Constants, Local Variables, and3.2
Control Constructs
    int i;
    for (i = 0; i < 100; i++) {
        ;    // Loop body is empty
    }
}
A compiler might compile spin to:
0   iconst_0       // Push int constant 0
1   istore_1       // Store into local variable 1 (i=0)
2   goto 8         // First time through don't increment
5   iinc 1 1       // Increment local variable 1 by 1 (i++)
8   iload_1        // Push local variable 1 (i)
9   bipush 100     // Push int constant 100
11  if_icmplt 5    // Compare and loop if less than (i < 100)
14  return         // Return void when done
The Java virtual machine is stack-oriented, with most operations taking one or more
operands from the operand stack of the Java virtual machine's current frame or
pushing results back onto the operand stack. A new frame is created each time
a method is invoked, and with it is created a new operand stack and set of local
variables for use by that 2.6). method At any ( one point of the computation, there
are thus likely to be many frames and equally many operand stacks per thread of
control, corresponding to many nested method invocations. Only the operand stack
in the current frame is active.
The instruction set of the Java virtual machine distinguishes operand types by
using distinct bytecodes for operations on its various data types. The method
spin operates only on values int. of The type instructions in its compiled code
chosen to operate on typed iconst_0data , istore_1( , iinc, iload_1, if_icmplt) are all
specialized for type int.
The two constants spin, in 0 and 100, are pushed onto the operand stack using
two different instructions. 0 is pushed The using iconst_0an  instruction, one of the
family iconst_<i>of  instructions. 100 The is pushed using bipush a instruction,
which fetches the value it pushes as an immediate operand.
The Java virtual machine frequently takes advantage of the likelihood of certain
operands int( constants -1, 0, 1, 2, 3, 4 and 5 in the case iconst_<i>of the 
instructions) by making those operands implicit in the opcode. Because the
iconst_0 instruction knows it is going int 0, to iconst_0push  does an not need to
store an operand to tell it what value to push, nor does it need to fetch or decode an
operand. Compiling the 0 push as bipushof  0 would have been correct, but would
have made the compiled spincode  one for byte longer. A simple virtual machine
would have also spent additional time fetching and decoding the explicit operand
41
--------------------------------------- 60
3.2Use of Constants, Local Variables, and Control ConstructsCOMPILING FOR THE JAVA
VIRTUAL MACHINE
each time around the loop. Use of implicit operands makes compiled code more
compact and efficient.
The int i in spin is stored as Java virtual machine 1. Because local variable most
Java virtual machine instructions operate on values popped from the operand stack
rather than directly on local variables, instructions that transfer values between
local variables and the operand stack are common in code compiled for the Java
virtual machine. These operations also have special support in the instruction set.
In spin, values are transferred to and from local istore_1variables  andusing the 
iload_1 instructions, each of which implicitly operates 1. Theon local variable 
istore_1 instruction pops int from an the operand stack and stores it in local
variable 1. The iload_1 instruction pushes the value in 1 on local to thevariable 
operand stack.
The use (and reuse) of local variables is the responsibility of the compiler writer.
The specialized load and store instructions should encourage the compiler writer
to reuse local variables as much as is feasible. The resulting code is faster, more
compact, and uses less space in the frame.
Certain very frequent operations on local variables are catered to specially by
the Java virtual machine. iinc instruction The increments the contents of a local
variable by a one-byte signed iincvalue.  instruction The spinin  increments the
first local variable (its first 1 (its operand) second operand). by iinc instructionThe 
is very handy when implementing looping constructs.
The for loop of spin is accomplished mainly by these instructions:
5   iinc 1 1       // Increment local variable 1 by 1 (i++)
8   iload_1        // Push local variable 1 (i)
9   bipush 100     // Push int constant 100
11  if_icmplt 5    // Compare and loop if less than (i < 100)
The bipush instruction pushes 100the  onto value the operand stack int, as an 
then the if_icmplt instruction pops that value off the operand stack and compares
it against i. If the comparison succeeds i(the  is less variable 100than ), control
is transferred to 5 and index the next iteration for loop of the begins. Otherwise,
control passes to the instruction following the if_icmplt.
If the spin example had used a data type intother  for the than loop counter,
the compiled code would necessarily change to reflect the different data type. For
instance, if instead of an int the spin example uses a double, as shown:
void dspin() {
    double i;
    for (i = 0.0; i < 100.0; i++) {
        ;    // Loop body is empty
42
--------------------------------------- 61
COMPILING FOR THE JAVA VIRTUAL MACHINEUse of Constants, Local Variables, and3.2
Control Constructs
    }
}
the compiled code is:
Method void dspin()
0   dconst_0       // Push double constant 0.0
1   dstore_1       // Store into local variables 1 and 2
2   goto 9         // First time through don't increment
5   dload_1        // Push local variables 1 and 2 
6   dconst_1       // Push double constant 1.0 
7   dadd           // Add; there is no dinc instruction
8   dstore_1       // Store result in local variables 1 and 2
9   dload_1        // Push local variables 1 and 2 
10  ldc2_w #4      // Push double constant 100.0 
13  dcmpg          // There is no if_dcmplt instruction
14  iflt 5         // Compare and loop if less than (i < 100.0)
17  return         // Return void when done
The instructions that operate on typed data are now doublespecialized .for type 
(The ldc2_w instruction will be discussed later in this chapter.)
Recall that double values occupy two local variables, although they are only
accessed using the lesser index of the two local variables. This is also the case for
values of type long. Again for example,
double doubleLocals(double d1, double d2) {
    return d1 + d2;
}
becomes
Method double doubleLocals(double,double)
0   dload_1       // First argument in local variables 1 and 2
1   dload_3       // Second argument in local variables 3 and 4
2   dadd
3   dreturn
Note that local variables of the local variable double pairs values used in to store 
doubleLocals must never be manipulated individually.
The Java virtual machine's opcode size of 1 byte results in its compiled code being
very compact. However, 1-byte opcodes also mean that the Java virtual machine
instruction set must stay small. As a compromise, the Java virtual machine does not
provide equal support for all data types: it is Table not completely 2.2).orthogonal (
For example, the comparison of values int in the forof  type statement of example
spin can be implemented using if_icmplta single  instruction; however, there is
no single instruction in the Java virtual machine instruction set that performs a
conditional branch on values doubleof . Thus, type dspin must implement its
43
--------------------------------------- 62
3.2Use of Constants, Local Variables, and Control ConstructsCOMPILING FOR THE JAVA
VIRTUAL MACHINE
comparison of values doubleof type  using dcmpga  instruction followed ifltby an 
instruction.
The Java virtual machine provides the most direct intsupport . This for data of type 
is partly in anticipation of efficient implementations of the Java virtual machine's
operand stacks and local variable arrays. It is also motivated by the frequency of
int data in typical programs. Other integral types have less direct support. There
are no byte, char, or short versions of the store, load, or add instructions, for
instance. Here is the spin example written using a short:
void sspin() {
    short i;
    for (i = 0; i < 100; i++) {
        ;    // Loop body is empty
    }
}
It must be compiled for the Java virtual machine, as follows, using instructions
operating on another type, intmost , converting likely between short and int
values as necessary to ensure that the results short data of operations stay withinon 
the appropriate range:
Method void sspin()
0   iconst_0
1   istore_1
2   goto 10
5   iload_1        // The short is treated as though an int
6   iconst_1
7   iadd
8   i2s            // Truncate int to short
9   istore_1
10  iload_1
11  bipush 100
13  if_icmplt 5
16  return
The lack of direct support byte, charfor , and short types in the Java virtual
machine is not particularly painful, because values of those types are internally
promoted intto  (byte and short are sign-extended int, charto  is zero-extended).
Operations byteon , char, and short data can thus be done int instructions.using 
The only additional cost is that of truncating int operations the values to validof 
ranges.
The long and floating-point types have an intermediate level of support in the Java
virtual machine, lacking only the full complement of conditional control transfer
instructions.
44
--------------------------------------- 63
COMPILING FOR THE JAVA VIRTUAL MACHINEArithmetic 3.3
3.3 Arithmetic
The Java virtual machine generally does arithmetic on its operand stack. (The
exception is iincthe  instruction, which directly increments the value of a local
variable.) For instance, align2grainthe  method aligns int an value to a given
power of 2:
int align2grain(int i, int grain) {
    return ((i + grain-1) & ~(grain-1));
}
Operands for arithmetic operations are popped from the operand stack, and
the results of operations are pushed back onto the operand stack. Results of
arithmetic subcomputations can thus be made available as operands of their nesting
computation. For instance, the ~(grain-1)calculation  is of handled by these
instructions:
5   iload_2        // Push grain
6   iconst_1       // Push int constant 1
7   isub           // Subtract; push result
8   iconst_m1      // Push int constant -1
9   ixor           // Do XOR; push result
First grain-1 is calculated using the contents 2 of and local an immediatevariable 
int value 1. These operands are popped from the operand stack and their difference
pushed back onto the operand stack. The difference is thus immediately available
for use as one operand ixor of instruction. the (Recall ~x == -1^xthat .) Similarly,
the result of ixor the instruction becomes an operand for iandthe subsequent 
instruction.
The code for the entire method follows:
Method int align2grain(int,int)
0   iload_1
1   iload_2
2   iadd
3   iconst_1
4   isub
5   iload_2
6   iconst_1
7   isub
8   iconst_m1
9   ixor
10  iand
11  ireturn
45
--------------------------------------- 64
3.4Accessing the Runtime Constant PoolCOMPILING FOR THE JAVA VIRTUAL MACHINE
3.4 Accessing the Runtime Constant Pool
Many numeric constants, as well as objects, fields, and methods, are accessed
via the runtime constant pool of the current class. Object access is considered
later 3.8(). Data of inttypes , long, float, and double, as well as references
to instances of Stringclass , are managed using ldc, ldc_wthe , and ldc2_w
instructions.
The ldc and ldc_w instructions are used to access values in the runtime constant
pool (including instances Stringof ) class of types other doublethan  and long.
The ldc_w instruction is used ldcin  only place when of there is a large number of
runtime constant pool items and a larger index is needed to access an item. The
ldc2_w instruction is used to access all doublevalues  and longof ; types there is
no non-wide variant.
Integral constants byteof , types char, or short, as well as intsmall  values,
may be compiled using bipushthe , sipush, or iconst_<i> instructions 3.2).(
Certain small floating-point constants may be fconst_<f>compiled  andusing the 
dconst_<d> instructions.
In all of these cases, compilation is straightforward. For instance, the constants for:
void useManyNumeric() {
    int i = 100;
    int j = 1000000;
    long l1 = 1;
    long l2 = 0xffffffff;
    double d = 2.2;
    ...do some calculations...
}
are set up as follows:
Method void useManyNumeric()
0   bipush 100     // Push a small int with bipush
2   istore_1
3   ldc #1         // Push int constant 1000000;
                   // a larger int value uses ldc
5   istore_2
6   lconst_1       // A tiny long value uses short, fast lconst_1
7   lstore_3
8   ldc2_w #6      // Push long 0xffffffff (that is, an int -1);
                   // any long constant value can be pushed using ldc2_w
11  lstore 5
13  ldc2_w #8      // Push double constant 2.200000;
                   // uncommon double values are also pushed using ldc2_w
16  dstore 7
...do those calculations...
46
--------------------------------------- 65
COMPILING FOR THE JAVA VIRTUAL MACHINEMore Control Examples3.5
3.5 More Control Examples
Compilation forof  statements was shown in an earlier 3.2). Most section of the(
Java programming language's other control if-then-elseconstructs , do, while(,
break, and continue) are also compiled in the obvious ways. The compilation of
switch statements is handled in a separate 3.10), as section are the (compilation
of exceptions (3.12) and the compilation of finally clauses (3.13).
As a further example, while loop a is compiled in an obvious way, although the
specific control transfer instructions made available by the Java virtual machine
vary by data type. As usual, there is more support int, for for example:data of type 
void whileInt() {
    int i = 0;
    while (i < 100) {
        i++;
    }
}
is compiled to:
Method void whileInt()
0   iconst_0
1   istore_1
2   goto 8
5   iinc 1 1
8   iload_1
9   bipush 100
11  if_icmplt 5
14  return
Note that the test whileof  statement the (implemented using if_icmpltthe 
instruction) is at the bottom of the Java virtual machine code for the loop. (This
was also the case spinin  examples the earlier.) The test being at the bottom of the
loop forces the gotouse  instruction of a to get to the test prior to the first iteration of
the loop. If that test fails, and the loop body is never entered, this extra instruction
is wasted. However, while loops are typically used when their body is expected
to be run, often for many iterations. For subsequent iterations, putting the test at
the bottom of the loop saves a Java virtual machine instruction each time around
the loop: if the test were at the top of the loop, the loop body would need a trailing
goto instruction to get back to the top.
Control constructs involving other data types are compiled in similar ways, but
must use the instructions available for those data types. This leads to somewhat
less efficient code because more Java virtual machine instructions are needed, for
example:
47
--------------------------------------- 66
3.5More Control ExamplesCOMPILING FOR THE JAVA VIRTUAL MACHINE
void whileDouble() {
    double i = 0.0;
    while (i < 100.1) {
        i++;
    }
}
is compiled to:
Method void whileDouble()
0   dconst_0
1   dstore_1
2   goto 9
5   dload_1
6   dconst_1
7   dadd
8   dstore_1
9   dload_1
10  ldc2_w #4      // Push double constant 100.1
13  dcmpg          // To do the compare and branch we have to use...
14  iflt 5         // ...two instructions
17  return
Each floating-point type has two comparison fcmpl and instructions: fcmpg for type
float, and dcmpl and dcmpg for type double. The variants differ only in their
treatment of NaN. NaN is unordered 2.3.2), so (all floating-point comparisons
fail if either of their operands is NaN. The compiler chooses the variant of the
comparison instruction for the appropriate type that produces the same result
whether the comparison fails on non-NaN values or encounters a NaN. For
instance:
int lessThan100(double d) {
    if (d < 100.0) {
        return 1;    
    } else {
        return -1;    
    }
}
compiles to:
Method int lessThan100(double)
0   dload_1
1   ldc2_w #4      // Push double constant 100.0
4   dcmpg          // Push 1 if d is NaN or d > 100.0;
                   // push 0 if d == 100.0
5   ifge 10        // Branch on 0 or 1
8   iconst_1
9   ireturn
10  iconst_m1
11  ireturn
48
--------------------------------------- 67
COMPILING FOR THE JAVA VIRTUAL MACHINEReceiving Arguments3.6
If d is not NaN and is 100.0less , than the dcmpg instruction pushes int -1 ontoan 
the operand stack, ifgeand  instruction the does not branch. d is Whether greater
than 100.0 or is NaN, dcmpgthe  instruction pushes int 1 an onto the operand
stack, and ifgethe  branches. d is If equal 100.0to , the dcmpg instruction pushes
an int 0 onto the operand stack, and the ifge branches.
The dcmpl instruction achieves the same effect if the comparison is reversed:
int greaterThan100(double d) {
    if (d > 100.0) {
        return 1;   
    } else {
        return -1;   
    }
}
becomes:
Method int greaterThan100(double)
0   dload_1
1   ldc2_w #4      // Push double constant 100.0
4   dcmpl          // Push -1 if d is NaN or d < 100.0;
                   // push 0 if d == 100.0
5   ifle 10        // Branch on 0 or -1
8   iconst_1
9   ireturn
10  iconst_m1
11  ireturn
Once again, whether the comparison fails on a non-NaN value or because it is
passed a NaN, dcmplthe  instruction pushes int value an onto the operand stack
that causes iflethe  to branch. If both dcmpof  instructions the did not exist, one of
the example methods would have had to do more work to detect NaN.
3.6 Receiving Arguments
If n arguments are passed to an instance method, they are received, by convention,
in the local variables 1 through numbered n of the frame created for the new method
invocation. The arguments are received in the order they were passed. For example:
int addTwo(int i, int j) {
    return i + j;
}
compiles to:
Method int addTwo(int,int)
49
--------------------------------------- 68
3.7Invoking MethodsCOMPILING FOR THE JAVA VIRTUAL MACHINE
0   iload_1        // Push value of local variable 1 (i)
1   iload_2        // Push value of local variable 2 (j)
2   iadd           // Add; leave int result on operand stack
3   ireturn        // Return int result
By convention, an instance method referenceis passed  to its a instance in local
variable 0. In the Java programming language the instance is accessible via the
this keyword.
Class static() methods do not have an instance, so for them this use of local
variable 0 is unnecessary. A class method starts using local 0. If variables at index 
the addTwo method were a class method, its arguments would be passed in a similar
way to the first version:
static int addTwoStatic(int i, int j) {
    return i + j;
}
compiles to:
Method int addTwoStatic(int,int)
0   iload_0
1   iload_1
2   iadd
3   ireturn
The only difference is that the method arguments appear starting in local variable
0 rather than 1.
3.7 Invoking Methods
The normal method invocation for a instance method dispatches on the runtime type
of the object. (They are virtual, in C++ terms.) Such an invocation is implemented
using the invokevirtual instruction, which takes as its argument an index to a
runtime constant pool entry giving the internal form of the binary name of the class
type of the object, the name of the method to invoke, and that method's descriptor
(4.3.3). To invoke addTwothe  method, defined earlier as an instance method, we
might write:
int add12and13() {
    return addTwo(12, 13);
}
This compiles to:
Method int add12and13()
50
--------------------------------------- 69
COMPILING FOR THE JAVA VIRTUAL MACHINEInvoking Methods3.7
0   aload_0             // Push local variable 0 (this)
1   bipush 12           // Push int constant 12
3   bipush 13           // Push int constant 13
5   invokevirtual #4    // Method Example.addtwo(II)I
8   ireturn             // Return int on top of operand stack;
                        // it is the int result of addTwo()
The invocation is set up by first referencepushing  to the a current thisinstance, ,
on to the operand stack. The method invocation's int values 12arguments,  and 13,
are then pushed. When the frame addTwofor  method the is created, the arguments
passed to the method become the initial values of the new frame's local variables.
That is, referencethe  for this and the two arguments, pushed onto the operand
stack by the invoker, will become the initial values 0, 1, and 2of local variables 
of the invoked method.
Finally, addTwo is invoked. When it returns, int return its value is pushed onto
the operand stack of the frame of add12and13the invoker,  method. the The return
value is thus put in place to be immediately returned add12and13to . the invoker of 
The return from add12and13 is handled by ireturnthe  instruction add12and13of .
The ireturn instruction takes int value the returned addTwoby , on the operand
stack of the current frame, and pushes it onto the operand stack of the frame of
the invoker. It then returns control to the invoker, making the invoker's frame
current. The Java virtual machine provides distinct return instructions for many of
its numeric referenceand  data types, as well return as instruction a for methods
with no return value. The same set of return instructions is used for all varieties
of method invocations.
The operand of invokevirtualthe  instruction (in the example, the runtime constant
pool index #4) is not the offset of the method in the class instance. The compiler
does not know the internal layout of a class instance. Instead, it generates symbolic
references to the methods of an instance, which are stored in the runtime constant
pool. Those runtime constant pool items are resolved at runtime to determine
the actual method location. The same is true for all other Java virtual machine
instructions that access class instances.
Invoking addTwoStatic, a class (static) variant of addTwo, is similar, as shown:
int add12and13() {
    return addTwoStatic(12, 13);
}
although a different Java virtual machine method invocation instruction is used:
Method int add12and13()
0   bipush 12
2   bipush 13
51
--------------------------------------- 70
3.7Invoking MethodsCOMPILING FOR THE JAVA VIRTUAL MACHINE
4   invokestatic #3     // Method Example.addTwoStatic(II)I
7   ireturn
Compiling an invocation of statica ) class method ( is very much like compiling
an invocation of an instance method, except this is not passed by the invoker. The
method arguments will thus be received beginning 0 (3.6with ). local Thevariable 
invokestatic instruction is always used to invoke class methods.
The invokespecial instruction must be used to invoke instance initialization
methods 3.8( ). It is also used when invoking methods superin )the superclass (
and when invoking private methods. For instance, given Near and classes Far
declared as:
class Near {
    int it;
    public int getItNear() {
        return getIt();
    }
    private int getIt() {
        return it;
    }
}
class Far extends Near {
    int getItFar() {
        return super.getItNear();
    }
}
the method Near.getItNear (which invokes a private method) becomes:
Method int getItNear()
0   aload_0
1   invokespecial #5    // Method Near.getIt()I
4   ireturn
The method Far.getItFar (which invokes a superclass method) becomes:
Method int getItFar()
0   aload_0
1   invokespecial #4    // Method Near.getItNear()I
4   ireturn
Note that methods called invokespecialusing the  instruction always this pass to
the invoked method as its first argument. As usual, it 0.is received in local variable 
To invoke the target of a method handle, a compiler must form a method descriptor
that records the actual argument and return types. A compiler may not perform
method invocation conversions on the arguments; instead, it must push them on
the stack according to their own unconverted types. The compiler arranges for
52
--------------------------------------- 71
COMPILING FOR THE JAVA VIRTUAL MACHINEWorking with Class Instances3.8
a reference to the method handle object to be pushed on the stack before the
arguments, as usual. The compiler invokevirtualemits  instruction an that references
a descriptor which describes the argument and return types. By special arrangement
with method resolution 5.4.3.3), ( an invokevirtual instruction which invokes
the invokeExact or invoke methods java.lang.invoke.MethodHandleof  will
always link, provided the method descriptor is syntactically well-formed and the
types named in the descriptor can be resolved.
3.8 Working with Class Instances
Java virtual machine class instances are created using the Java virtual machine's
new instruction. Recall that at the level of the Java virtual machine, a constructor
appears as a method with the compiler-supplied <init>. This name specially
named method is known as the instance initialization 2.9). Multiplemethod (
instance initialization methods, corresponding to multiple constructors, may exist
for a given class. Once the class instance has been created and its instance variables,
including those of the class and all of its superclasses, have been initialized to
their default values, an instance initialization method of the new class instance is
invoked. For example:
Object create() {
    return new Object();
}
compiles to:
Method java.lang.Object create()
0   new #1              // Class java.lang.Object
3   dup
4   invokespecial #4    // Method java.lang.Object.<init>()V
7   areturn
Class instances are passed and referencereturned  types) (as very much like
numeric values, although referencetype  has its own complement of instructions,
for example:
int i;                                  // An instance variable
MyObj example() {
    MyObj o = new MyObj();
    return silly(o);
}
MyObj silly(MyObj o) {
    if (o != null) {
        return o;
    } else {
53
--------------------------------------- 72
3.8Working with Class InstancesCOMPILING FOR THE JAVA VIRTUAL MACHINE
        return o;
    }
}
becomes:
Method MyObj example()
0   new #2              // Class MyObj
3   dup
4   invokespecial #5    // Method MyObj.<init>()V
7   astore_1
8   aload_0
9   aload_1
10  invokevirtual #4    // Method Example.silly(LMyObj;)LMyObj;
13  areturn
Method MyObj silly(MyObj)
0   aload_1
1   ifnull 6
4   aload_1
5   areturn
6   aload_1
7   areturn
The fields of a class instance (instance variables) getfieldare accessed using the 
and putfield instructions. i is If an instance variable int, the of type methods setIt
and getIt, defined as:
void setIt(int value) {
    i = value;
}
int getIt() {
    return i;
}
become:
Method void setIt(int)
0   aload_0
1   iload_1
2   putfield #4    // Field Example.i I
5   return
Method int getIt()
0   aload_0
1   getfield #4    // Field Example.i I
4   ireturn
As with the operands of method invocation instructions, putfieldthe operands of the 
and getfield instructions (the runtime constant #4) are pool not index the offsets of
the fields in the class instance. The compiler generates symbolic references to the
54
--------------------------------------- 73
COMPILING FOR THE JAVA VIRTUAL MACHINEArrays3.9
fields of an instance, which are stored in the runtime constant pool. Those runtime
constant pool items are resolved at runtime to determine the location of the field
within the referenced object.
3.9 Arrays
Java virtual machine arrays are also objects. Arrays are created and manipulated
using a distinct set of instructions. newarray instruction The is used to create an
array of a numeric type. The code:
void createBuffer() {
    int buffer[];
    int bufsz = 100;
    int value = 12;
    buffer = new int[bufsz];
    buffer[10] = value;
    value = buffer[11];
}
might be compiled to:
Method void createBuffer()
0   bipush 100     // Push int constant 100 (bufsz)
2   istore_2       // Store bufsz in local variable 2
3   bipush 12      // Push int constant 12 (value)
5   istore_3       // Store value in local variable 3
6   iload_2        // Push bufsz...
7   newarray int   // ...and create new array of int of that length
9   astore_1       // Store new array in buffer
10  aload_1        // Push buffer
11  bipush 10      // Push int constant 10
13  iload_3        // Push value
14  iastore        // Store value at buffer[10]
15  aload_1        // Push buffer
16  bipush 11      // Push int constant 11
18  iaload         // Push value at buffer[11]...
19  istore_3       // ...and store it in value
20  return
The anewarray instruction is used to create a one-dimensional array of object
references, for example:
void createThreadArray() {
    Thread threads[];
    int count = 10;
    threads = new Thread[count];
    threads[0] = new Thread();
}
55
--------------------------------------- 74
3.9ArraysCOMPILING FOR THE JAVA VIRTUAL MACHINE
becomes:
Method void createThreadArray()
0   bipush 10           // Push int constant 10
2   istore_2            // Initialize count to that
3   iload_2             // Push count, used by anewarray
4   anewarray class #1  // Create new array of class Thread
7   astore_1            // Store new array in threads
8   aload_1             // Push value of threads
9   iconst_0            // Push int constant 0
10  new #1              // Create instance of class Thread
13  dup                 // Make duplicate reference...
14  invokespecial #5    // ...to pass to instance initialization method
                        // Method java.lang.Thread.<init>()V
17  aastore             // Store new Thread in array at 0
18  return
The anewarray instruction can also be used to create the first dimension of a
multidimensional array. Alternatively, multianewarray the instruction can be used
to create several dimensions at once. For example, the three-dimensional array:
int[][][] create3DArray() {
    int grid[][][];
    grid = new int[10][5][];
    return grid;
}
is created by:
Method int create3DArray()[][][]
0   bipush 10                // Push int 10 (dimension one)
2   iconst_5                 // Push int 5 (dimension two)
3   multianewarray #1 dim #2 // Class [[[I, a three
                             // dimensional int array;
                             // only create first two dimensions
7   astore_1                 // Store new array...
8   aload_1                  // ...then prepare to return it
9   areturn
The first operand multianewarrayof the  instruction is the runtime constant pool
index to the array class type to be created. The second is the number of dimensions
of that array type to actually multianewarraycreate.  instruction The can be used to
create all the dimensions of the type, create3DArrayas the  code shows. for Note
that the multidimensional array is just an object and so is loaded and returned by
an aload_1 and areturn instruction, respectively. For information about array class
names, see 4.4.1.
All arrays have associated lengths, which are arraylengthaccessed via the 
instruction.
56
--------------------------------------- 75
COMPILING FOR THE JAVA VIRTUAL MACHINECompiling Switches3.10
3.10Compiling Switches
Compilation switchof  statements uses tableswitchthe  and lookupswitch
instructions. tableswitchThe  instruction is used when the switchcases  canof the 
be efficiently represented as indices into a table defaultof target offsets. The 
target of switchthe  is used if the value of the expression switch falls of outsidethe 
the range of valid indices. For instance:
int chooseNear(int i) {
    switch (i) {
        case 0:  return  0;
        case 1:  return  1;
        case 2:  return  2;
        default: return -1;
    }
}
compiles to:
Method int chooseNear(int)
0   iload_1             // Push local variable 1 (argument i)
1   tableswitch 0 to 2: // Valid indices are 0 through 2
      0: 28             // If i is 0, continue at 28
      1: 30             // If i is 1, continue at 30
      2: 32             // If i is 2, continue at 32
      default:34        // Otherwise, continue at 34
28  iconst_0            // i was 0; push int constant 0...
29  ireturn             // ...and return it
30  iconst_1            // i was 1; push int constant 1...
31  ireturn             // ...and return it
32  iconst_2            // i was 2; push int constant 2...
33  ireturn             // ...and return it
34  iconst_m1           // otherwise push int constant -1...
35  ireturn             // ...and return it
The Java virtual machine's tableswitch and lookupswitch instructions operate only
on int data. Because operations byte, charon , or short values are internally
promoted intto , a switch whose expression evaluates to one of those types is
compiled as though it evaluated int. If to chooseNearthe type  method had been
written using shorttype , the same Java virtual machine instructions would have
been generated as when using int. Other type numeric types must be narrowed to
type int for use in a switch.
Where the cases switchof the  are sparse, the table representation tableswitchof the 
instruction becomes inefficient in terms lookupswitchof space.  instruction The may
be used instead. lookupswitchThe  instruction intpairs  keys (the values caseof the 
labels) with target offsets in lookupswitcha table.  instruction When a is executed,
57
--------------------------------------- 76
3.11Operations on the Operand StackCOMPILING FOR THE JAVA VIRTUAL MACHINE
the value of the expression switch of is the compared against the keys in the table.
If one of the keys matches the value of the expression, execution continues at the
associated target offset. If no key matches, execution defaultcontinues at the 
target. For instance, the compiled code for:
int chooseFar(int i) {
    switch (i) {
        case -100: return -1;
        case 0:    return  0;
        case 100:  return  1;
        default:   return -1;
    }
}
looks just like the code for chooseNear, except for the lookupswitch instruction:
Method int chooseFar(int)
0   iload_1
1   lookupswitch 3:
         -100: 36
            0: 38
          100: 40
      default: 42
36  iconst_m1
37  ireturn
38  iconst_0
39  ireturn
40  iconst_1
41  ireturn
42  iconst_m1
43  ireturn
The Java virtual machine specifies that lookupswitchthe table  instructionof the 
must be sorted by key so that implementations may use searches more efficient than
a linear scan. Even lookupswitchso, the  instruction must search its keys for a match
rather than simply perform a bounds check and index tableswitchinto . a table like 
Thus, tableswitcha  instruction is probably more efficient lookupswitchthan a 
where space considerations permit a choice.
3.11Operations on the Operand Stack
The Java virtual machine has a large complement of instructions that manipulate
the contents of the operand stack as untyped values. These are useful because of
the Java virtual machine's reliance on deft manipulation of its operand stack. For
instance:
58
--------------------------------------- 77
COMPILING FOR THE JAVA VIRTUAL MACHINEThrowing and Handling Exceptions3.12
public long nextIndex() { 
    return index++;
}
private long index = 0;
is compiled to:
Method long nextIndex()
0   aload_0        // Push this
1   dup            // Make a copy of it
2   getfield #4    // One of the copies of this is consumed
                   // pushing long field index,
                   // above the original this
5   dup2_x1        // The long on top of the operand stack is 
                   // inserted into the operand stack below the 
                   // original this
6   lconst_1       // Push long constant 1 
7   ladd           // The index value is incremented...
8   putfield #4    // ...and the result stored back in the field
11  lreturn        // The original value of index is left on
                   // top of the operand stack, ready to be returned
Note that the Java virtual machine never allows its operand stack manipulation
instructions to modify or break up individual values on the operand stack.
3.12Throwing and Handling Exceptions
Exceptions are thrown from programs throwusing  keyword. the Its compilation
is simple:
void cantBeZero(int i) throws TestExc {
    if (i == 0) {
        throw new TestExc();
    }
}
becomes:
Method void cantBeZero(int)
0   iload_1             // Push argument 1 (i)
1   ifne 12             // If i==0, allocate instance and throw
4   new #1              // Create instance of TestExc
7   dup                 // One reference goes to the constructor
8   invokespecial #7    // Method TestExc.<init>()V
11  athrow              // Second reference is thrown
12  return              // Never get here if we threw TestExc
Compilation of try-catch constructs is straightforward. For example:
59
--------------------------------------- 78
3.12Throwing and Handling ExceptionsCOMPILING FOR THE JAVA VIRTUAL MACHINE
void catchOne() {
    try {
        tryItOut();
    } catch (TestExc e) {
        handleExc(e);
    }
}
is compiled as:
Method void catchOne()
0   aload_0             // Beginning of try block
1   invokevirtual #6    // Method Example.tryItOut()V
4   return              // End of try block; normal return
5   astore_1            // Store thrown value in local variable 1
6   aload_0             // Push this
7   aload_1             // Push thrown value
8   invokevirtual #5    // Invoke handler method: 
                        // Example.handleExc(LTestExc;)V
11  return              // Return after handling TestExc
Exception table:
From    To      Target      Type
0       4       5           Class TestExc
Looking more closely, try block the is compiled just as it trywould  werebe if the 
not present:
Method void catchOne()
0   aload_0             // Beginning of try block
1   invokevirtual #6    // Method Example.tryItOut()V
4   return              // End of try block; normal return
If no exception is thrown during the tryexecution  block, it of behaves the as though
the try were not there: tryItOut is invoked and catchOne returns.
Following trythe  block is the Java virtual machine code that implements the single
catch clause:
5   astore_1            // Store thrown value in local variable 1
6   aload_0             // Push this
7   aload_1             // Push thrown value
8   invokevirtual #5    // Invoke handler method: 
                        // Example.handleExc(LTestExc;)V
11  return              // Return after handling TestExc
Exception table:
From    To      Target      Type
0       4       5           Class TestExc
The invocation handleExcof , the contents catchof  the clause, is also compiled
like a normal method invocation. However, catchthe  presence clause causesof a 
the compiler to generate an exception 2.10, table 4.7.3). entry The exception(
60
--------------------------------------- 79
COMPILING FOR THE JAVA VIRTUAL MACHINEThrowing and Handling Exceptions3.12
table for catchOnethe  method has one entry corresponding to the one argument (an
instance of TestExcclass ) that catchthe  clause catchOneof  can handle. If some
value that is an instance TestExc is of thrown during execution of the instructions
between indices 0 and 4 in catchOne, control is transferred to the Java virtual
machine code at 5index , which implements the block catch of clause. the If the
value that is thrown is not TestExcan instance , the catchof  clause catchOneof 
cannot handle it. Instead, the value is rethrown to the invoker of catchOne.
A try may have multiple catch clauses:
void catchTwo() {
    try {
        tryItOut();
    } catch (TestExc1 e) {
        handleExc(e);
    } catch (TestExc2 e) {
        handleExc(e);
    }
}
Multiple catch clauses of a trygiven  statement are compiled by simply appending
the Java virtual machine code catch for clause each one after the other and adding
entries to the exception table, as shown:
Method void catchTwo()
0   aload_0             // Begin try block
1   invokevirtual #5    // Method Example.tryItOut()V
4   return              // End of try block; normal return
5   astore_1            // Beginning of handler for TestExc1;
                        // Store thrown value in local variable 1
6   aload_0             // Push this
7   aload_1             // Push thrown value
8   invokevirtual #7    // Invoke handler method:
                        // Example.handleExc(LTestExc1;)V
11  return              // Return after handling TestExc1
12  astore_1            // Beginning of handler for TestExc2;
                        // Store thrown value in local variable 1
13  aload_0             // Push this
14  aload_1             // Push thrown value
15  invokevirtual #7    // Invoke handler method:
                        // Example.handleExc(LTestExc2;)V
18  return              // Return after handling TestExc2
Exception table:
From    To      Target      Type
0       4       5           Class TestExc1
0       4       12          Class TestExc2
If during the execution try clause of the (between 0indices  and 4) a value is thrown
that matches the parameter of one catchor more  clauses of the (the value is an
instance of one or more of the parameters), the catchfirst  clause(innermost) such 
61
--------------------------------------- 80
3.12Throwing and Handling ExceptionsCOMPILING FOR THE JAVA VIRTUAL MACHINE
is selected. Control is transferred to the Java virtual machine code for the block of
that catch clause. If the value thrown does not match the parameter of any of the
catch clauses catchTwoof , the Java virtual machine rethrows the value without
invoking code in any catch clause of catchTwo.
Nested try-catch statements are compiled very trymuch  statement like a with
multiple catch clauses:
void nestedCatch() {
    try {
        try {
            tryItOut();
        } catch (TestExc1 e) {
            handleExc1(e);
        }
    } catch (TestExc2 e) {
        handleExc2(e);
    }
}
becomes:
Method void nestedCatch()
0   aload_0             // Begin try block
1   invokevirtual #8    // Method Example.tryItOut()V
4   return              // End of try block; normal return
5   astore_1            // Beginning of handler for TestExc1;
                        // Store thrown value in local variable 1
6   aload_0             // Push this
7   aload_1             // Push thrown value
8   invokevirtual #7    // Invoke handler method: 
                        // Example.handleExc1(LTestExc1;)V
11  return              // Return after handling TestExc1
12  astore_1            // Beginning of handler for TestExc2;
                        // Store thrown value in local variable 1
13  aload_0             // Push this
14  aload_1             // Push thrown value
15  invokevirtual #6    // Invoke handler method:
                        // Example.handleExc2(LTestExc2;)V
18  return              // Return after handling TestExc2
Exception table:
From    To      Target      Type
0       4       5           Class TestExc1
0       12      12          Class TestExc2
The nesting catchof  clauses is represented only in the exception table. The Java
virtual machine does not enforce nesting of or any ordering of the exception table
entries 2.10(). However, because try-catch constructs are structured, a compiler
can always order the entries of the exception handler table such that, for any thrown
exception and any program counter value in that method, the first exception handler
62
--------------------------------------- 81
COMPILING FOR THE JAVA VIRTUAL MACHINECompiling finally3.13
that matches the thrown exception corresponds to the catchinnermost matching 
clause.
For instance, if the invocation tryItOut (at of index 1) threw an instance of
TestExc1, it would be handled catchby  clause the that invokes handleExc1. This
is so even though the exception occurs within the catchbounds  clauseof the outer 
(catching TestExc2) and even though that catchouter  clause might otherwise have
been able to handle the thrown value.
As a subtle point, note that catchthe  clause range of is a inclusive on the "from"
end and exclusive on the 4.7.3"to" ). end Thus, ( the exception table entry for the
catch clause catching TestExc1 does not cover returnthe  instruction at 4.offset 
However, the exception table catchentry  clause for the catching TestExc2 does
cover the return instruction at 11. offset Return instructions within catch nested 
clauses are included in the range of instructions catch clauses.covered by nesting 
3.13Compiling finally
(This section assumes a compiler classgenerates  files with version number 50.0
or below, so that the jsr instruction may be used. See also 4.10.2.5.)
Compilation tryof -finallya  statement is similar tryto -catchthat . Prior of to
transferring control outside try statement, the whether that transfer is normal or
abrupt, because an exception has been finallythrown,  clause the must first be
executed. For this simple example:
void tryFinally() {
    try {
        tryItOut();
    } finally {
        wrapItUp();
    }
}
the compiled code is:
Method void tryFinally()
0   aload_0             // Beginning of try block
1   invokevirtual #6    // Method Example.tryItOut()V
4   jsr 14              // Call finally block
7   return              // End of try block
8   astore_1            // Beginning of handler for any throw
9   jsr 14              // Call finally block
12  aload_1             // Push thrown value
13  athrow              // ...and rethrow the value to the invoker
14  astore_2            // Beginning of finally block
63
--------------------------------------- 82
3.13Compiling finallyCOMPILING FOR THE JAVA VIRTUAL MACHINE
15  aload_0             // Push this
16  invokevirtual #5    // Method Example.wrapItUp()V
19  ret 2               // Return from finally block
Exception table:
From    To      Target      Type
0       4       8           any
There are four ways for control to pass try statement: outside of by the falling
through the bottom of that block, by returning, break or continueby executing a 
statement, or by raising an tryItOutexception.  returns If without raising an
exception, control is transferred finally block to the using jsr instruction. a The
jsr 14 instruction at 4 makes index a "subroutine call" to the finallycode for the 
block at index 14 (the finally block is compiled as an embedded subroutine).
When the finally block completes, ret 2the  instruction returns control to the
instruction following the jsr instruction at index 4.
In more detail, the subroutine call works jsr instruction as follows: pushesThe 
the address of the following returninstruction  at index 7) onto (the operand stack
before jumping. astore_2The  instruction that is the jump target stores the address
on the operand stack into local 2. The variable code for finallythe  block (in
this case aload_0the  and invokevirtual instructions) is run. Assuming execution of
that code completes normally, ret instruction the retrieves the address from local
variable 2 and resumes execution at that returnaddress.  instruction The is executed,
and tryFinally returns normally.
A try statement with finallya  clause is compiled to have a special exception
handler, one that can handle any exception trythrown  statement. within Ifthe 
tryItOut throws an exception, the exception tryFinallytable  is searched for for
an appropriate exception handler. The special handler is found, causing execution
to continue at 8. index The astore_1 instruction at 8 stores index the thrown value
into local variable 1. The following jsr instruction does a subroutine call to the
code for finallythe  block. Assuming that code returns aload_1normally, the 
instruction at 12index  pushes the thrown value back onto the operand stack, and
the following athrow instruction rethrows the value.
Compiling trya  statement with catchboth  clause a and finallya  clause is more
complex:
void tryCatchFinally() {
    try {
        tryItOut();
    } catch (TestExc e) {
        handleExc(e);
    } finally {
        wrapItUp();
    }
64
--------------------------------------- 83
COMPILING FOR THE JAVA VIRTUAL MACHINECompiling finally3.13
}
becomes:
Method void tryCatchFinally()
0   aload_0             // Beginning of try block
1   invokevirtual #4    // Method Example.tryItOut()V
4   goto 16             // Jump to finally block
7   astore_3            // Beginning of handler for TestExc;
                        // Store thrown value in local variable 3
8   aload_0             // Push this
9   aload_3             // Push thrown value
10  invokevirtual #6    // Invoke handler method:
                        // Example.handleExc(LTestExc;)V
13  goto 16             // This goto instruction is unnecessary,
                        // but was generated by javac in JDK 1.0.2.
16  jsr 26              // Call finally block
19  return              // Return after handling TestExc
20  astore_1            // Beginning of handler for exceptions
                        // other than TestExc, or exceptions
                        // thrown while handling TestExc
21  jsr 26              // Call finally block
24  aload_1             // Push thrown value...
25  athrow              // ...and rethrow the value to the invoker
26  astore_2            // Beginning of finally block
27  aload_0             // Push this
28  invokevirtual #5    // Method Example.wrapItUp()V
31  ret 2               // Return from finally block
Exception table:
From    To      Target      Type
0       4       7           Class TestExc
0       16      20          any
If the try statement completes normally, goto instruction the at 4 jumpsindex 
to the subroutine call finallyfor  block the at index 16. The finally block at
index 26 is executed, control returns return instruction to the at 19, index and
tryCatchFinally returns normally.
If tryItOut throws an instance TestExcof , the first (innermost) applicable
exception handler in the exception table is chosen to handle the exception. The
code for that exception handler, beginning 7, passes at the index thrown value to
handleExc and on its return makes the same subroutine finally blockcall to the 
at index 26 as in the normal case. If an exception handleExcis not , thrown by 
tryCatchFinally returns normally.
If tryItOut throws a value that is not TestExcan instance  or handleExcif of  itself
throws an exception, the condition is handled by the second entry in the exception
table, which handles any value thrown 0between  and 16. That indices exception
handler transfers control 20, to where index the thrown value is first stored in local
65
--------------------------------------- 84
3.14SynchronizationCOMPILING FOR THE JAVA VIRTUAL MACHINE
variable 1. The code for finallythe  block at index 26 is called as a subroutine. If it
returns, the thrown value is retrieved 1 from and rethrown local variable using the
athrow instruction. If a new value is thrown during finally execution clause, of the 
the finally clause aborts, tryCatchFinallyand  returns abruptly, throwing the
new value to its invoker.
3.14Synchronization
Synchronization in the Java virtual machine is implemented by monitor entry and
exit, either explicitly monitorenter(by use of  and the monitorexit instructions) or
implicitly (by the method invocation and return instructions).
For code written in the Java programming language, perhaps the most common
form of synchronization synchronizedis the  method. synchronizedA  method is
not normally implemented monitorenterusing  and monitorexit. Rather, it is simply
distinguished in the runtime constant ACC_SYNCHRONIZEDpool by  the flag, which
is checked by the method invocation instructions (2.11.10).
The monitorenter and monitorexit instructions enable the compilation of
synchronized statements. For example:
void onlyMe(Foo f) {
    synchronized(f) {
        doSomething();
    }
}
is compiled to:
Method void onlyMe(Foo)
0   aload_1             // Push f
1   dup                 // Duplicate it on the stack
2   astore_2            // Store duplicate in local variable 2
3   monitorenter        // Enter the monitor associated with f
4   aload_0             // Holding the monitor, pass this and...
5   invokevirtual #5    // ...call Example.doSomething()V
8   aload_2             // Push local variable 2 (f)
9   monitorexit         // Exit the monitor associated with f
10  goto 18             // Complete the method normally
13  astore_3            // In case of any throw, end up here
14  aload_2             // Push local variable 2 (f)
15  monitorexit         // Be sure to exit the monitor!
16  aload_3             // Push thrown exception...
17  athrow              // ...then rethrow the value to the invoker
18  return              // Return in the normal case
Exception table:
66
--------------------------------------- 85
COMPILING FOR THE JAVA VIRTUAL MACHINEAnnotations 3.15
From    To      Target      Type
4       10      13          any
13      16      13          any
The compiler ensures that at any method invocation monitorexitcompletion, a 
instruction will have been executed monitorenterfor  instruction each executed
since the method invocation. This is the case whether the method invocation
completes normally 2.6.4) ( or abruptly 2.6.5). ( To enforce proper pairing
of monitorenter and monitorexit instructions on abrupt method invocation
completion, the compiler generates exception 2.10) that handlers will match(
any exception and whose associated code executes monitorexitthe necessary 
instructions.
3.15Annotations
The representation of annotations class files in is described 4.7.16 and in 4.7.17,
which make it clear how to represent annotations on types, fields and methods in
the class file format. Package annotations require additional rules, given here.
When the compiler encounters an annotated package declaration that must be
made available at runtime, classit  file emits that a represents an interface whose
name is the internal 4.2.1form ) of package-name(.package-info. The interface
has the default access level ("package-private") and no superinterfaces. The
ACC_INTERFACE and ACC_ABSTRACT flags (Table 4.1) ClassFileof the  structure
(4.1) are set. If the classemitted  file version number is less than 50.0, then the
ACC_SYNTHETIC flag is unset; if the class file version number is 50.0 or above, then
the ACC_SYNTHETIC flag is set. The only members of the interface are those implied
by The Java Language Specification, Java SE 7 Edition (JLS 9.2).
The package-level annotations are RuntimeVisibleAnnotationsstored in the 
(4.7.16) and RuntimeInvisibleAnnotations 4.7.17() attributes of the
ClassFile structure (4.1) of this interface.
67
--------------------------------------- 86
3.15AnnotationsCOMPILING FOR THE JAVA VIRTUAL MACHINE
68
--------------------------------------- 87
CHAPTER4
The class File Format
THIS chapter describes the Java virtual class file machine format. classEach 
file contains the definition of a single class or interface. Although a class or
interface need not have an external representation literally contained in a file (for
instance, because the class is generated by a class loader), we will colloquially refer
to any valid representation of a class or interface class file as format.being in the 
A class file consists of a stream of 8-bit bytes. All 16-bit, 32-bit, and 64-bit
quantities are constructed by reading in two, four, and eight consecutive 8-bit
bytes, respectively. Multibyte data items are always stored in big-endian order,
where the high bytes come first. In the Java platform, this format is supported
by interfaces java.io.DataInput and java.io.DataOutput and classes such as
java.io.DataInputStream and java.io.DataOutputStream.
This chapter defines its own set of data classtypes  file representing data:
The types u1, u2, and u4 represent an unsigned one-, two-, or four-byte
quantity, respectively. In the Java platform, these types may be read by methods
such as readUnsignedByte, readUnsignedShort, and readInt of the interface
java.io.DataInput.
This chapter presents class the file format using pseudostructures written in a
C-like structure notation. To avoid confusion with the fields of classes and class
instances, etc., the contents of the structures class file describing format arethe 
referred to itemsas . Successive items are stored class file in the sequentially,
without padding or alignment.
Tables, consisting of zero or more variable-sized items, class are used in several 
file structures. Although we use C-like array syntax to refer to table items, the fact
that tables are streams of varying-sized structures means that it is not possible to
translate a table index directly to a byte offset into the table.
Where we refer to a data structure as an array, it consists of zero or more contiguous
fixed-sized items and can be indexed like an array.
69
--------------------------------------- 88
4.1The ClassFile StructureTHE CLASS FILE FORMAT
Note: We use this font for Prolog code and code this fontfragments,  forand 
Java virtual machine instructions class file and structures. Commentary, designed
to clarify the specification, is given as indented text between horizontal lines:
Commentary provides intuition, motivation, rationale, examples, etc.
4.1 The ClassFile Structure
A class file consists of a single ClassFile structure:
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
The items in the ClassFile structure are as follows:
magic
The magic item supplies the magic number identifying class file format;the 
it has the value 0xCAFEBABE.
minor_version, major_version
The values of minor_versionthe  and major_version items are the minor and
major version numbers classof  this file. Together, a major and a minor version
number determine the version class of file the format. classIf  file a has major
version number M and minor version number m, we denote the version of its
class file format as M.m. classThus,  file format versions may be ordered
lexicographically, for example, 1.5 < 2.0 < 2.1.
A Java virtual machine implementation classcan  file support format a of
version v if and only if v lies in some contiguous d v d Mj.m.range Mi.0 
70
--------------------------------------- 89
THE CLASS FILE FORMATThe ClassFile Structure 4.1
The release level of the Java platform to which a Java virtual machine
implementation conforms is responsible for determining the range.
Oracle's Java virtual machine implementation in JDK classrelease  file1.0.2 supports 
format versions 45.0 through 45.3 inclusive. JDK classreleases  file 1.1.X formatsupport 
versions in the range 45.0 through 45.65535 e 2, inclusive. implementations For k of
version 1.k of the Java platform class file support format versions in the range 45.0
through 44+k.0 inclusive.
constant_pool_count
The value of constant_pool_countthe  item is equal to the number of entries
in the constant_pool table plus one. constant_poolA  index is considered
valid if it is greater than zero constant_pool_countand less than , with the
exception for constants of type long and double noted in 4.4.5.
constant_pool[]
The constant_pool is a table of structures 4.4) representing (various string
constants, class and interface names, field names, and other constants that are
referred to within ClassFilethe  structure and its substructures. The format of
each constant_pool table entry is indicated by its first "tag" byte.
The constant_pool table is indexed from 1 to constant_pool_count-1.
access_flags
The value of access_flagsthe  item is a mask of flags used to denote access
permissions to and properties of this class or interface. The interpretation of
each flag, when set, is as shown in Table 4.1.
Table 4.1. Class access and property modifiers
Flag NameValueInterpretation
ACC_PUBLIC0x0001Declared public; may be accessed from outside its
package.
ACC_FINAL0x0010Declared final; no subclasses allowed.
ACC_SUPER0x0020Treat superclass methods specially when invoked by
the invokespecial instruction.
ACC_INTERFACE0x0200Is an interface, not a class.
ACC_ABSTRACT0x0400Declared abstract; must not be instantiated.
ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.
ACC_ANNOTATION0x2000Declared as an annotation type.
ACC_ENUM0x4000Declared as an enum type.
71
--------------------------------------- 90
4.1The ClassFile StructureTHE CLASS FILE FORMAT
A class may be marked ACC_SYNTHETICwith the  flag to indicate that it was
generated by the compiler and does not appear in the source code.
The ACC_ENUM flag indicates that this class or its superclass is declared as an
enumerated type.
An interface is distinguished ACC_INTERFACEby its  flag being set. If its
ACC_INTERFACE flag is not classset,  file this defines a class, not an interface.
If the ACC_INTERFACE flag of classthis  file is set, ACC_ABSTRACTits  flag must
also be set (JLS 9.1.1.1). class Such file a must not have ACC_FINALits ,
ACC_SUPER or ACC_ENUM flags set.
An annotation type must have ACC_ANNOTATIONits  flag set. If the
ACC_ANNOTATION flag is set, ACC_INTERFACEthe  flag must be set as well. If the
ACC_INTERFACE flag of classthis  file is not set, it may have any of the other
flags Table in 4.1 set, except ACC_ANNOTATIONthe  flag. However, classsuch a 
file cannot have ACC_FINALboth its  and ACC_ABSTRACT flags set (JLS 8.1.1.2).
The ACC_SUPER flag indicates which of two alternative semantics is to be
expressed by invokespecialthe  instruction invokespecial() if it appears in this
class. Compilers to the instruction set of the Java virtual machine should set
the ACC_SUPER flag.
The ACC_SUPER flag exists for backward compatibility with code compiled by older
compilers for the Java programming language. In Oracles JDK prior to release 1.0.2,
the compiler generated ClassFile access_flags in which the flag now representing
ACC_SUPER had no assigned meaning, and Oracle's Java virtual machine implementation
ignored the flag if it was set.
All bits of access_flagsthe  item not assigned Table in 4.1 are reserved for
future use. They should be set to zero class in files generated and should be
ignored by Java virtual machine implementations.
this_class
The value of this_classthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Class_info 4.4.1() structure representing the class or interface
defined by this class file.
super_class
For a class, the value super_classof the  item either must be zero or
must be a valid index constant_poolinto the  table. If the value of the
super_class item is nonzero, constant_poolthe  entry at that index must be
a CONSTANT_Class_info (4.4.1) structure representing the direct superclass
72
--------------------------------------- 91
THE CLASS FILE FORMATThe ClassFile Structure 4.1
of the class defined classby  file. this Neither the direct superclass nor any of
its superclasses may ACC_FINALhave the  flag set access_flagsin the  item of
its ClassFile structure.
If the value super_classof the  item is zero, classthen  this file must represent
the class Object, the only class or interface without a direct superclass.
For an interface, the value super_classof the  item must always be a valid
index into constant_poolthe  table. constant_poolThe  entry at that index
must be a CONSTANT_Class_info structure representing the class Object.
interfaces_count
The value of interfaces_countthe  item gives the number of direct
superinterfaces of this class or interface type.
interfaces[]
Each value in interfacesthe  array must be a valid index into
the constant_pool table. The constant_pool entry at each value
of interfaces[i], where d0  i < interfaces_count, must be a
CONSTANT_Class_info (4.4.1) structure representing an interface that is a
direct superinterface of this class or interface type, in the left-to-right order
given in the source for the type.
fields_count
The value of fields_countthe  item gives the number field_infoof 
structures in fieldsthe  table. field_infoThe  4.5( ) structures represent all
fields, both class variables and instance variables, declared by this class or
interface type.
fields[]
Each value in fieldsthe  table must field_infobe a  4.5( ) structure giving
a complete description of a field in this fieldsclass  tableor interface. The 
includes only those fields that are declared by this class or interface. It does
not include items representing fields that are inherited from superclasses or
superinterfaces.
methods_count
The value of methods_countthe  item gives the number method_infoof 
structures in the methods table.
methods[]
Each value in methodsthe  table must method_infobe a  (4.6) structure giving
a complete description of a method in this class or interface. If neither of the
ACC_NATIVE and ACC_ABSTRACT flags are set access_flagsin the  item of a
73
--------------------------------------- 92
4.1The ClassFile StructureTHE CLASS FILE FORMAT
method_info structure, the Java virtual machine instructions implementing the
method are also supplied.
The method_info structures represent all methods declared by this class
or interface type, including instance methods, class methods, instance
initialization methods 2.9), and ( any class or interface initialization method
(2.9). The methods table does not include items representing methods that are
inherited from superclasses or superinterfaces.
attributes_count
The value of attributes_countthe  item gives the number of 4.7attributes )(
in the attributes table of this class.
attributes[]
Each value of attributesthe  table must be attribute_infoan  (4.7)
structure.
The attributes defined by this specification as appearing in
the attributes table of ClassFilea  structure are the
InnerClasses (4.7.6), EnclosingMethod (4.7.7), Synthetic (4.7.8),
Signature 4.7.9(), SourceFile (4.7.10), SourceDebugExtension
(4.7.11), Deprecated 4.7.15(), RuntimeVisibleAnnotations 4.7.16(),
RuntimeInvisibleAnnotations 4.7.17(), and BootstrapMethods (4.7.21)
attributes.
If a Java virtual machine implementation class recognizes files whose
version number is 49.0 or above, it must recognize and correctly
read Signature (4.7.9), RuntimeVisibleAnnotations 4.7.16(), and
RuntimeInvisibleAnnotations (4.7.17) attributes found attributesin the 
table of ClassFilea  structure classof  a file whose version number is 49.0
or above.
If a Java virtual machine implementation class recognizes files whose
version number is 51.0 or above, it must recognize and correctly read
BootstrapMethods (4.7.21) attributes found attributesin the  table of a
ClassFile structure of a class file whose version number is 51.0 or above.
A Java virtual machine implementation is required to silently ignore any or
all attributes attributesin the  table of ClassFilea  structure that it does
not recognize. Attributes not defined in this specification are not allowed to
affect the semantics classof  file, the but only to provide additional descriptive
information (4.7.1).
74
--------------------------------------- 93
THE CLASS FILE FORMATThe Internal Form of Names4.2
4.2 The Internal Form of Names
4.2.1Binary Class and Interface Names
Class and interface names that classappear  file in structures are always
represented in a fully qualified binary form names (JLS as 13.1). Such names are
always represented CONSTANT_Utf8_infoas  (4.4.7) structures and thus may be
drawn, where not further constrained, from the entire Unicode codespace. Class and
interface names are referenced CONSTANT_NameAndType_infofrom those  (4.4.6)
structures which have such names as part 4.3of ), their and descriptor from all (
CONSTANT_Class_info (4.4.1) structures.
For historical reasons, the syntax of binary classnames  filethat appear in 
structures differs from the syntax of binary names documented in JLS 13.1. In
this internal form, the ASCII periods ('.') that normally separate the identifiers that
make up the binary name are replaced by ASCII forward slashes ('/'). The identifiers
themselves must be unqualified names (4.2.2).
For example, the normal binary name Threadof  is java.lang.Threadclass . In the
internal form used in descriptors class file in format, the a reference to the name of class
Thread is implemented using CONSTANT_Utf8_infoa  structure representing the string
"java/lang/Thread".
4.2.2Unqualified Names
Names of methods, fields and local variables unqualified are stored names.as 
Unqualified names must not contain the (Unicode code points corresponding to
the) ASCII characters '.', ';', '[', or '/'.
Method names are further constrained so that, with the exception of the special
method names <init> and <clinit> 2.9( ), they must not contain the (Unicode
code points corresponding to the) ASCII characters '<' or '>'.
Note that a field name or interface method <init>name  or <clinit>may be , but
no method invocation instruction <clinit>may reference  and only invokespecialthe 
instruction (invokespecial) may reference <init>.
4.3 Descriptors and Signatures
A descriptor is a string representing the type of a field or method. Descriptors are
represented classin the  file format using modified UTF-8 4.4.7) strings and thus(
may be drawn, where not further constrained, from the entire Unicode codespace.
75
--------------------------------------- 94
4.3.1 Grammar NotationTHE CLASS FILE FORMAT
A signature is a string representing the generic type of a field or method, or generic
type information for a class declaration.
4.3.1Grammar Notation
Descriptors and signatures are specified using a grammar. This grammar is a set
of productions that describe how sequences of characters can form syntactically
correct descriptors of various types. Terminal symbols of the grammar are shown
in bold fixed-width font. Nonterminal symbols are italicshown  type. in The
definition of a nonterminal is introduced by the name of the nonterminal being
defined, followed by a colon. One or more alternative right-hand sides for the
nonterminal then follow on succeeding lines. For example, the production:
FieldType:
    BaseType
    ObjectType
    ArrayType
states that FieldTypea  may represent either BaseTypea , an ObjectType or an
ArrayType.
A nonterminal symbol on the right-hand side of a production that is followed by
an asterisk (*) represents zero or more possibly different values produced from
that nonterminal, appended without any intervening space. Similarly, a nonterminal
symbol on the right-hand side of a production that is followed by an plus sign (+)
represents one or more possibly different values produced from that nonterminal,
appended without any intervening space. The production:
MethodDescriptor:
    ( ParameterDescriptor* ) ReturnDescriptor
states that MethodDescriptora  represents a left parenthesis, followed by zero or
more ParameterDescriptor values, followed by a right parenthesis, followed by a
ReturnDescriptor.
4.3.2Field Descriptors
A field descriptor represents the type of a class, instance, or local variable. It is a
series of characters generated by the grammar:
76
--------------------------------------- 95
THE CLASS FILE FORMATField Descriptors4.3.2
FieldDescriptor:
    FieldType
ComponentType:
    FieldType
FieldType:
    BaseType
    ObjectType
    ArrayType 
BaseType:
    B
    C
    D
    F
    I
    J
    S
    Z
ObjectType:
    L Classname ;
ArrayType:
    [ ComponentType
The characters BaseTypeof , the L and ; of ObjectType, and the [ of ArrayType are
all ASCII characters. ClassnameThe  represents a binary class or interface name
encoded in internal 4.2.1form ). A ( type descriptor representing an array type is
valid only if it represents a type with 255 or fewer dimensions. The interpretation
of the field types is as shown in Table 4.2.
77
--------------------------------------- 96
4.3.3 Method DescriptorsTHE CLASS FILE FORMAT
Table 4.2. Interpretation of BaseType characters
BaseType CharacterTypeInterpretation
Bbytesigned byte
CcharUnicode character code point in the Basic
Multilingual Plane, encoded with UTF-16
Ddoubledouble-precision floating-point value
Ffloatsingle-precision floating-point value
Iintinteger
Jlonglong integer
L Classname ;reference an instance of class Classname
Sshortsigned short
Zbooleantrue or false
[reference one array dimension
For example, the descriptor of an instance variable of type int is simply I.
The descriptor of an instance variable Object is Ljava/lang/Object;of type . Note that
the internal form of the binary name for class Object is used.
The descriptor of an instance variable that is a multidimensional double array,
double d[][][];
is
[[[D
4.3.3Method Descriptors
A method descriptor represents the parameters that the method takes and the value
that it returns:
MethodDescriptor:
    ( ParameterDescriptor* ) ReturnDescriptor
A parameter descriptor represents a parameter passed to a method:
ParameterDescriptor:
    FieldType
78
--------------------------------------- 97
THE CLASS FILE FORMATSignatures4.3.4
A return descriptor represents the type of the value returned from a method. It is
a series of characters generated by the grammar:
ReturnDescriptor:
    FieldType
    VoidDescriptor
VoidDescriptor:
    V
The character V indicates that the method returns no value void).(its return type is 
A method descriptor is valid only if it represents method parameters with a total
length of 255 or less, where that length includes this the in thecontribution for 
case of instance or interface method invocations. The total length is calculated by
summing the contributions of the individual parameters, where a parameter of type
long or double contributes two units to the length and a parameter of any other
type contributes one unit.
For example, the method descriptor for the method
Object mymethod(int i, double d, Thread t)
is
(IDLjava/lang/Thread;)Ljava/lang/Object;
Note that the internal forms of the Threadbinary  and names Object of are used in the
method descriptor.
The method descriptor mymethodfor  is the same whether mymethod is a class or an
instance method. Although an instance method this, a is reference passed to the current
class instance, in addition to its intended parameters, that fact is not reflected in the method
descriptor. The reference this is passed to implicitly by the method invocation instructions
of the Java virtual machine used to invoke instance thismethods.  is notA reference to 
passed to a class method.
4.3.4Signatures
Signatures are used to encode Java programming language type information that is
not part of the Java virtual machine type system, such as generic type and method
declarations and parameterized The types. Java See Language Specification,
Java SE 7 Edition for details about such types.
79
--------------------------------------- 98
4.3.4 SignaturesTHE CLASS FILE FORMAT
This kind of type information is needed to support reflection and debugging, and by the
Java compiler.
In the following, the terminal Identifiersymbol  is used to denote the name of a
type, field, local variable, parameter, method, or type variable, as generated by the
Java compiler. Such a name must not contain the characters <', >', ' or'.', ';', '[', '/', '
':', but may contain characters that must not appear in a legal identifier in the Java
programming language.
A class signature, defined by ClassSignaturethe production , is used to encode type
information about a class declaration. It describes any formal type parameters the
class might have, and lists its (possibly parameterized) direct superclass and direct
superinterfaces, if any.
ClassSignature:
    FormalTypeParametersopt SuperclassSignature SuperinterfaceSignature*
A formal type parameter is described by its name, followed by its class and interface
bounds. If the class bound does not specify a type, it is taken to be Object.
FormalTypeParameters:
    < FormalTypeParameter+ >
FormalTypeParameter:
    Identifier ClassBound InterfaceBound*
ClassBound:
    : FieldTypeSignatureopt
InterfaceBound:
    : FieldTypeSignature
SuperclassSignature:
    ClassTypeSignature
SuperinterfaceSignature:
    ClassTypeSignature
A field type signature, defined by FieldTypeSignaturethe production , encodes the
(possibly parameterized) type for a field, parameter or local variable.
80
--------------------------------------- 99
THE CLASS FILE FORMATSignatures4.3.4
FieldTypeSignature:
    ClassTypeSignature 
    ArrayTypeSignature
    TypeVariableSignature
A class type signature gives complete type information for a class or interface type.
The class type signature must be formulated such that it can be reliably mapped
to the binary name of the class it denotes by erasing any type arguments and
converting each '.' character in the signature to a '$' character.
81
--------------------------------------- 100
4.3.4 SignaturesTHE CLASS FILE FORMAT
ClassTypeSignature:
    L PackageSpecifieropt SimpleClassTypeSignature ClassTypeSignatureSuffix* ;
PackageSpecifier:
    Identifier / PackageSpecifier*
SimpleClassTypeSignature:
    Identifier TypeArgumentsopt
ClassTypeSignatureSuffix:
    . SimpleClassTypeSignature
TypeVariableSignature:
    T Identifier ;
TypeArguments:
    < TypeArgument+ >
TypeArgument:
    WildcardIndicatoropt FieldTypeSignature
    *
WildcardIndicator:
    +
    -
ArrayTypeSignature:
    [ TypeSignature
TypeSignature:
    FieldTypeSignature
    BaseType
A method signature, defined by the MethodTypeSignatureproduction , encodes
the (possibly parameterized) types of the method's formal arguments and of the
exceptions it has declared throws in clause, its its (possibly parameterized) return
type, and any formal type parameters in the method declaration.
82
--------------------------------------- 101
THE CLASS FILE FORMATThe Constant Pool4.4
MethodTypeSignature:
    FormalTypeParametersopt (TypeSignature*) ReturnType ThrowsSignature*
ReturnType:
    TypeSignature
    VoidDescriptor
ThrowsSignature:
    ^ ClassTypeSignature
    ^ TypeVariableSignature
If the throws clause of a method or constructor does not involve type variables,
the ThowsSignature may be elided from the MethodTypeSignature.
A Java compiler must output generic signature information for any class, interface,
constructor or member whose generic signature in the Java programming language
would include references to type variables or parameterized types.
The signature and descriptor 4.3.3) of (a given method or constructor may not correspond
exactly, due to compiler-generated artifacts. In TypeSignatureparticular, s the number of 
that encode formal arguments MethodTypeSignaturein  may be less than the number of
ParameterDescriptors in MethodDescriptor.
Oracle's Java virtual machine implementation does not check the well-formedness of the
signatures described in this subsection during loading or linking. Instead, these checks are
deferred until the signatures are used by reflective methods, as specified in the API of
Class and members java.lang.reflectof . Future versions of a Java virtual machine
implementation may be required to perform some or all of these checks during loading or
linking.
4.4 The Constant Pool
Java virtual machine instructions do not rely on the runtime layout of classes,
interfaces, class instances, or arrays. Instead, instructions refer to symbolic
information in the constant_pool table.
All constant_pool table entries have the following general format:
cp_info {
    u1 tag;
    u1 info[];
}
83
--------------------------------------- 102
4.4.1 The CONSTANT_Class_info StructureTHE CLASS FILE FORMAT
Each item in constant_poolthe  table must begin with a 1-byte tag indicating
the kind cp_infoof  entry. The contents infoof  array the vary with the value of
tag. The valid tags and their values Table are 4.3. listed Each tag in byte must be
followed by two or more bytes giving information about the specific constant. The
format of the additional information varies with the tag value.
Table 4.3. Constant pool tags
Constant TypeValue
CONSTANT_Class7
CONSTANT_Fieldref9
CONSTANT_Methodref10
CONSTANT_InterfaceMethodref11
CONSTANT_String8
CONSTANT_Integer3
CONSTANT_Float4
CONSTANT_Long5
CONSTANT_Double6
CONSTANT_NameAndType12
CONSTANT_Utf81
CONSTANT_MethodHandle15
CONSTANT_MethodType16
CONSTANT_InvokeDynamic18
4.4.1The CONSTANT_Class_info Structure
The CONSTANT_Class_info structure is used to represent a class or an interface:
CONSTANT_Class_info {
    u1 tag;
    u2 name_index;
}
The items of the CONSTANT_Class_info structure are the following:
tag
The tag item has the value CONSTANT_Class (7).
84
--------------------------------------- 103
THE CLASS FILE FORMAT The CONSTANT_Fieldref_info,4.4.2
CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing a valid binary class or
interface name encoded in internal form (4.2.1).
Because arrays are objects, the anewarrayopcodes  and multianewarray
can reference array "classes" CONSTANT_Class_infovia  structures in the
constant_pool table. For such array classes, the name of the class is the descriptor
of the array type.
For example, the class name representing a two-dimensional int array type
int[][]
is
[[I
The class name representing the type array of class Thread
Thread[]
is
[Ljava/lang/Thread;
An array type descriptor is valid only if it represents 255 or fewer dimensions.
4.4.2The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
CONSTANT_InterfaceMethodref_info Structures
Fields, methods, and interface methods are represented by similar structures:
85
--------------------------------------- 104
4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
CONSTANT_InterfaceMethodref_info StructuresTHE CLASS FILE FORMAT
CONSTANT_Fieldref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
}
CONSTANT_Methodref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
}
CONSTANT_InterfaceMethodref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
}
The items of these structures are as follows:
tag
The tag item of CONSTANT_Fieldref_infoa  structure has the value
CONSTANT_Fieldref (9).
The tag item of CONSTANT_Methodref_infoa  structure has the value
CONSTANT_Methodref (10).
The tag item of CONSTANT_InterfaceMethodref_infoa  structure has the
value CONSTANT_InterfaceMethodref (11).
class_index
The value of class_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Class_info (4.4.1) structure representing a class or interface type
that has the field or method as a member.
The class_index item of CONSTANT_Methodref_infoa  structure must be a
class type, not an interface type.
The class_index item of CONSTANT_InterfaceMethodref_infoa  structure
must be an interface type.
The class_index item of CONSTANT_Fieldref_infoa  structure may be either
a class type or an interface type.
name_and_type_index
The value of name_and_type_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
86
--------------------------------------- 105
THE CLASS FILE FORMATThe CONSTANT_String_info Structure4.4.3
CONSTANT_NameAndType_info (4.4.6) structure. constant_poolThis  entry
indicates the name and descriptor of the field or method.
In a CONSTANT_Fieldref_info, the indicated descriptor must be a field
descriptor 4.3.2(). Otherwise, the indicated descriptor must be a method
descriptor (4.3.3).
If the name of the method CONSTANT_Methodref_infoof a  structure begins
with a <' '\u003c(''), then the name must be the <init>special ,name 
representing an instance initialization 2.9). The method return ( type of such
a method must be void.
4.4.3The CONSTANT_String_info Structure
The CONSTANT_String_info structure is used to represent constant objects of the
type String:
CONSTANT_String_info {
    u1 tag;
    u2 string_index;
}
The items of the CONSTANT_String_info structure are as follows:
tag
The tag item of CONSTANT_String_infothe  structure has the value
CONSTANT_String (8).
string_index
The value of string_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info 4.4.7() structure representing the sequence of Unicode
code points to which the String object is to be initialized.
4.4.4The CONSTANT_Integer_info and CONSTANT_Float_info Structures
The CONSTANT_Integer_info and CONSTANT_Float_info structures represent 4-
byte numeric (int and float) constants:
87
--------------------------------------- 106
4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures THE CLASS FILE FORMAT
CONSTANT_Integer_info {
    u1 tag;
    u4 bytes;
}
CONSTANT_Float_info {
    u1 tag;
    u4 bytes;
}
The items of these structures are as follows:
tag
The tag item of CONSTANT_Integer_infothe  structure has the value
CONSTANT_Integer (3).
The tag item of CONSTANT_Float_infothe  structure has the value
CONSTANT_Float (4).
bytes
The bytes item of CONSTANT_Integer_infothe  structure represents the value
of the int constant. The bytes of the value are stored in big-endian (high byte
first) order.
The bytes item of CONSTANT_Float_infothe  structure represents the value
of the float constant in IEEE 754 floating-point 2.3.2single ). Theformat (
bytes of the single format representation are stored in big-endian (high byte
first) order.
The value represented CONSTANT_Float_infoby the  structure is determined
as follows. The bytes of the value are first int constant converted bits.into an 
Then:
 If bits is 0x7f800000, the float value will be positive infinity.
 If bits is 0xff800000, the float value will be negative infinity.
 If bits is in the 0x7f800001range  through 0x7fffffff or in the range
0xff800001 through 0xffffffff, the float value will be NaN.
 In all other cases, s, e, and mlet  be three values that might be computed from
bits:
int s = ((bits >> 31) == 0) ? 1 : -1;
int e = ((bits >> 23) & 0xff);
int m = (e == 0) ?
          (bits & 0x7fffff) << 1 :
          (bits & 0x7fffff) | 0x800000;
88
--------------------------------------- 107
THE CLASS FILE FORMAT The CONSTANT_Long_info and CONSTANT_Double_info Structures4.4.5
Then the float value equals the result of the mathematical s  mexpression 
e-150
 2.
4.4.5The CONSTANT_Long_info and CONSTANT_Double_info Structures
The CONSTANT_Long_info and CONSTANT_Double_info represent 8-byte numeric
(long and double) constants:
CONSTANT_Long_info {
    u1 tag;
    u4 high_bytes;
    u4 low_bytes;
}
CONSTANT_Double_info {
    u1 tag;
    u4 high_bytes;
    u4 low_bytes;
}
All 8-byte constants take up two constant_poolentries in  table the of classthe 
file. If CONSTANT_Long_infoa  or CONSTANT_Double_info structure is the item
in the constant_pool table at nindex , then the next usable item in the pool is
located at nindex +2. The constant_pool index n+1 must be valid but is considered
unusable.
In retrospect, making 8-byte constants take two constant pool entries was a poor choice.
The items of these structures are as follows:
tag
The tag item of the CONSTANT_Long_info structure has the value
CONSTANT_Long (5).
The tag item of CONSTANT_Double_infothe  structure has the value
CONSTANT_Double (6).
high_bytes, low_bytes
The unsigned high_bytes and low_bytes items of CONSTANT_Long_infothe 
structure together represent the value of the long constant
((long) high_bytes << 32) + low_bytes
where the bytes of high_byteseach of  and low_bytes are stored in big-endian
(high byte first) order.
89
--------------------------------------- 108
4.4.6 The CONSTANT_NameAndType_info StructureTHE CLASS FILE FORMAT
The high_bytes and low_bytes items of CONSTANT_Double_infothe 
structure together represent double value the in IEEE 754 floating-point
double format 2.3.2(). The bytes of each item are stored in big-endian (high
byte first) order.
The value represented CONSTANT_Double_infoby the  structure is determined
as follows. high_bytesThe  and low_bytes items are converted longinto the 
constant bits, which is equal to
((long) high_bytes << 32) + low_bytes
Then:
 If bits is 0x7ff0000000000000L, the double value will be positive infinity.
 If bits is 0xfff0000000000000L, the double value will be negative infinity.
 If bits is in the 0x7ff0000000000001Lrange  through 0x7fffffffffffffffL
or in the range 0xfff0000000000001L through 0xffffffffffffffffL, the
double value will be NaN.
 In all other cases, s, e, and mlet  be three values that might be computed from
bits:
int s = ((bits >> 63) == 0) ? 1 : -1;
int e = (int)((bits >> 52) & 0x7ffL);
long m = (e == 0) ?
           (bits & 0xfffffffffffffL) << 1 :
           (bits & 0xfffffffffffffL) | 0x10000000000000L;
Then the floating-point value doubleequals  value the of the mathematical
e-1075
expression s  m  2.
4.4.6The CONSTANT_NameAndType_info Structure
The CONSTANT_NameAndType_info structure is used to represent a field or method,
without indicating which class or interface type it belongs to:
CONSTANT_NameAndType_info {
    u1 tag;
    u2 name_index;
    u2 descriptor_index;
}
The items of the CONSTANT_NameAndType_info structure are as follows:
90
--------------------------------------- 109
THE CLASS FILE FORMATThe CONSTANT_Utf8_info Structure4.4.7
tag
The tag item of CONSTANT_NameAndType_infothe  structure has the value
CONSTANT_NameAndType (12).
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing either the special method
name <init> (2.9) or a valid unqualified 4.2.2) name denoting (a field or
method.
descriptor_index
The value of descriptor_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info 4.4.7() structure representing a valid field descriptor
(4.3.2) or method descriptor (4.3.3).
4.4.7The CONSTANT_Utf8_info Structure
The CONSTANT_Utf8_info structure is used to represent constant string values:
CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
}
The items of the CONSTANT_Utf8_info structure are the following:
tag
The tag item of the CONSTANT_Utf8_info structure has the value
CONSTANT_Utf8 (1).
length
The value of lengththe  item gives the number of bytesbytes  arrayin the 
(not the length of the resulting string). CONSTANT_Utf8_infoThe strings in the 
structure are not null-terminated.
bytes[]
The bytes array contains the bytes of the string. No byte may have the value
(byte)0 or lie in the range (byte)0xf0 - (byte)0xff.
String content is encoded in modified UTF-8. Modified UTF-8 strings are encoded
so that code point sequences that contain only non-null ASCII characters can be
91
--------------------------------------- 110
4.4.7 The CONSTANT_Utf8_info StructureTHE CLASS FILE FORMAT
represented using only 1 byte per code point, but all code points in the Unicode
codespace can be represented.
 Code points in the range '\u0001' to '\u007F' are represented by a single byte:
0bits 6-0
The 7 bits of data in the byte give the value of the code point represented.
 The null code point \u0000') ('and code points in \u0080the ' range to \u07FF' ''
are represented by a pair of bytes x and y :
x:110bits 10-6
y:10bits 5-0
The bytes represent the code point with the value:
((x & 0x1f) << 6) + (y & 0x3f)
 Code points in the \u0800range ' to \uFFFF' ' ' are represented by x, y3 , bytes 
and z :
x:1110bits 15-12
y:10bits 11-6
z:10bits 5-0
The three bytes represent the code point with the value:
((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f)
 Characters with code points above U+FFFF supplementary(so-called 
characters) are represented by separately encoding the two surrogate code units
of their UTF-16 representation. Each of the surrogate code units is represented by
three bytes. This means supplementary characters are represented by six bytes,
u, v, w, x, y, and z :
92
--------------------------------------- 111
THE CLASS FILE FORMATThe CONSTANT_MethodHandle_info Structure4.4.8
u:11101101
v:1010(bits 20-16)-1
w:
10bits 15-10
x:11101101
y:1011bits 9-6
z:10bits 5-0
The six bytes represent the code point with the value:
0x10000 + ((v & 0x0f) << 16) + ((w & 0x3f) << 10) +
((y & 0x0f) << 6) + (z & 0x3f)
The bytes of multibyte characters classare stored  file in in big-endian the (high
byte first) order.
There are two differences between this format and the "standard" UTF-8 format.
First, the null (char)0character  is encoded using the 2-byte format rather than the
1-byte format, so that modified UTF-8 strings never have embedded nulls. Second,
only the 1-byte, 2-byte, and 3-byte formats of standard UTF-8 are used. The Java
virtual machine does not recognize the four-byte format of standard UTF-8; it uses
its own two-times-three-byte format instead.
For more information regarding the standard UTF-8 format, Unicodesee Section 3.9 
Encoding Forms of The Unicode Standard, Version 6.0.0.
4.4.8The CONSTANT_MethodHandle_info Structure
The CONSTANT_MethodHandle_info structure is used to represent a method handle:
CONSTANT_MethodHandle_info {
    u1 tag;
    u1 reference_kind;
    u2 reference_index;
}
The items of the CONSTANT_MethodHandle_info structure are the following:
tag
The tag item of CONSTANT_MethodHandle_infothe  structure has the value
CONSTANT_MethodHandle (15).
93
--------------------------------------- 112
4.4.9 The CONSTANT_MethodType_info Structure THE CLASS FILE FORMAT
reference_kind
The value of reference_kindthe  item must be in the range 1 to 9. The
value denotes kindthe  of this method handle, which characterizes its bytecode
behavior (5.4.3.5).
reference_index
The value of reference_indexthe  item must be a valid index into the
constant_pool table.
If the value of reference_kindthe  item is REF_getField1 (), 2
(REF_getStatic), 3 REF_putField(), or REF_putStatic4 (), then the
constant_pool entry at that index CONSTANT_Fieldref_infomust be a 
(4.4.2) structure representing a field for which a method handle is to be
created.
If the value of reference_kindthe  item is 5
(REF_invokeVirtual), 6 REF_invokeStatic(), 7 REF_invokeSpecial(), or 8
(REF_newInvokeSpecial), then constant_poolthe  entry at that index must be
a CONSTANT_Methodref_info (4.4.2) structure representing a class's method
or constructor (2.9) for which a method handle is to be created.
If the value of reference_kindthe  item is REF_invokeInterface9 (),
then the constant_pool entry at that index must be a
CONSTANT_InterfaceMethodref_info (4.4.2) structure representing an
interface's method for which a method handle is to be created.
If the value of reference_kindthe  item is REF_invokeVirtual5 (), 6
(REF_invokeStatic), 7 REF_invokeSpecial(), or REF_invokeInterface9 (),
the name of the method represented CONSTANT_Methodref_infoby a  structure
must not be <init> or <clinit>.
If the value REF_newInvokeSpecialis 8 (), the name of the method represented
by a CONSTANT_Methodref_info structure must be <init>.
4.4.9The CONSTANT_MethodType_info Structure
The CONSTANT_MethodType_info structure is used to represent a method type:
CONSTANT_MethodType_info {
    u1 tag;
    u2 descriptor_index;
}
The items of the CONSTANT_NameAndType_info structure are as follows:
94
--------------------------------------- 113
THE CLASS FILE FORMATThe CONSTANT_InvokeDynamic_info Structure4.4.10
tag
The tag item of CONSTANT_MethodType_infothe  structure has the value
CONSTANT_MethodType (16).
descriptor_index
The value of descriptor_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info 4.4.7() structure representing a method descriptor
(4.3.3).
4.4.10The CONSTANT_InvokeDynamic_info Structure
The CONSTANT_InvokeDynamic_info structure is used invokedynamicby an 
instruction invokedynamic() to specify a bootstrap method, the dynamic
invocation name, the argument and return types of the call, and optionally, a
sequence of additional constants called static arguments to the bootstrap method.
CONSTANT_InvokeDynamic_info {
    u1 tag;
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;
}
The items of the CONSTANT_InvokeDynamic_info structure are as follows:
tag
The tag item of CONSTANT_InvokeDynamic_infothe  structure has the value
CONSTANT_InvokeDynamic (18).
bootstrap_method_attr_index
The value of bootstrap_method_attr_indexthe  item must be a valid index
into the bootstrap_methods array of the bootstrap method 4.7.21) table of(
this class file.
name_and_type_index
The value of name_and_type_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_NameAndType_info (4.4.6) structure representing a method name
and method descriptor (4.3.3).
95
--------------------------------------- 114
4.5FieldsTHE CLASS FILE FORMAT
4.5 Fields
Each field is described field_infoby  a structure. No two fields class in fileone 
may have the same name and descriptor (4.3.2).
The structure has the following format:
field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
The items of the field_info structure are as follows:
access_flags
The value of access_flagsthe  item is a mask of flags used to denote access
permission to and properties of this field. The interpretation of each flag, when
set, is as shown in Table 4.19.
Table 4.19. Field access and property flags
Flag NameValueInterpretation
ACC_PUBLIC0x0001Declared public; may be accessed from outside its
package.
ACC_PRIVATE0x0002Declared private; usable only within the defining
class.
ACC_PROTECTED0x0004Declared protected; may be accessed within
subclasses.
ACC_STATIC0x0008Declared static.
ACC_FINAL0x0010Declared final; never directly assigned to after
object construction (JLS 17.5).
ACC_VOLATILE0x0040Declared volatile; cannot be cached.
ACC_TRANSIENT0x0080Declared transient; not written or read by a
persistent object manager.
ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.
ACC_ENUM0x4000Declared as an element of an enum.
A field may be marked ACC_SYNTHETICwith the  flag to indicate that it was
generated by the compiler and does not appear in the source code.
96
--------------------------------------- 115
THE CLASS FILE FORMATFields4.5
The ACC_ENUM flag indicates that this field is used to hold an element of an
enumerated type.
Fields of classes may set any Table of the 4.19. flags However, in a specific
field of a class may have at ACC_PRIVATEmost one , of ACC_PROTECTEDits , and
ACC_PUBLIC flags set (JLS 8.3.1) and must not ACC_FINALhave  andboth its 
ACC_VOLATILE flags set (JLS 8.3.1.4).
All fields of interfaces must ACC_PUBLIChave , their ACC_STATIC, and
ACC_FINAL flags set; they may ACC_SYNTHETIChave their  flag set and must not
have any of the other flags in Table 4.19 set (JLS 9.3).
All bits of access_flagsthe  item not assigned Table in 4.19 are reserved for
future use. They should be set to zero class in files generated and should be
ignored by Java virtual machine implementations.
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. The constant_pool entry at that index must be
a CONSTANT_Utf8_info (4.4.7) structure which must represent a valid
unqualified name (4.2.2) denoting a field.
descriptor_index
The value of descriptor_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure that must represent a valid field
descriptor (4.3.2).
attributes_count
The value of attributes_countthe  item indicates the number of additional
attributes (4.7) of this field.
attributes[]
Each value of attributesthe  table must be an attribute 4.7). structure A(
field can have any number of attributes associated with it.
The attributes defined by this specification as appearing
in the attributes table of field_infoa  structure are
ConstantValue (4.7.2), Synthetic (4.7.8), Signature (4.7.9),
Deprecated (4.7.15), RuntimeVisibleAnnotations 4.7.16() and
RuntimeInvisibleAnnotations (4.7.17).
A Java virtual machine implementation must recognize and correctly read
ConstantValue (4.7.2) attributes found attributesin the  table of a
field_info structure. If a Java virtual machine implementation recognizes
97
--------------------------------------- 116
4.6MethodsTHE CLASS FILE FORMAT
class files whose version number is 49.0 or above, it must recognize and
correctly Signatureread  (4.7.9), RuntimeVisibleAnnotations (4.7.16)
and RuntimeInvisibleAnnotations 4.7.17() attributes found in the
attributes table of field_infoa  structure classof  a file whose version
number is 49.0 or above.
A Java virtual machine implementation is required to silently ignore any or all
attributes that it does not attributesrecognize  table in the of field_infoa 
structure. Attributes not defined in this specification are not allowed to affect
the semantics of classthe  file, but only to provide additional descriptive
information (4.7.1).
4.6 Methods
Each method, including each instance initialization 2.9) and the method class (or
interface initialization 2.9), method is described (method_infoby a  structure. No
two methods in one class file may have the same name and descriptor (4.3.3).
The structure has the following format:
method_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
The items of the method_info structure are as follows:
access_flags
The value of access_flagsthe  item is a mask of flags used to denote access
permission to and properties of this method. The interpretation of each flag,
when set, is as shown in Table 4.20.
98
--------------------------------------- 117
THE CLASS FILE FORMATMethods4.6
Table 4.20. Method access and property flags
Flag NameValueInterpretation
ACC_PUBLIC0x0001Declared public; may be accessed from outside its
package.
ACC_PRIVATE0x0002Declared private; accessible only within the
defining class.
ACC_PROTECTED0x0004Declared protected; may be accessed within
subclasses.
ACC_STATIC0x0008Declared static.
ACC_FINAL0x0010Declared final; must not be overridden (5.4.5).
ACC_SYNCHRONIZED 0x0020Declared synchronized; invocation is wrapped
by a monitor use.
ACC_BRIDGE0x0040A bridge method, generated by the compiler.
ACC_VARARGS0x0080Declared with variable number of arguments.
ACC_NATIVE0x0100Declared native; implemented in a language other
than Java.
ACC_ABSTRACT0x0400Declared abstract; no implementation is
provided.
ACC_STRICT0x0800Declared strictfp; floating-point mode is FP-
strict.
ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.
The ACC_VARARGS flag indicates that this method takes a variable number of
arguments at the source code level. A method declared to take a variable
number of arguments must be compiled ACC_VARARGSwith  the flag set to 1.
All other methods must be compiled with the ACC_VARARGS flag set to 0.
The ACC_BRIDGE flag is used to indicate a bridge method generated by the
compiler.
A method may be marked with ACC_SYNTHETICthe  flag to indicate that it was
generated by the compiler and does not appear in the source code, unless it is
one of the methods named in 4.7.8.
Methods of classes may set any of Table the flags 4.20. However, in a
specific method of a class may have at ACC_PRIVATEmost one , of its 
ACC_PROTECTED and ACC_PUBLIC flags set (JLS 8.4.3). If a specific method
has its ACC_ABSTRACT flag set, it must not have ACC_FINALany of ,its 
99
--------------------------------------- 118
4.6MethodsTHE CLASS FILE FORMAT
ACC_NATIVE, ACC_PRIVATE, ACC_STATIC, ACC_STRICT or ACC_SYNCHRONIZED
flags set (JLS 8.4.3.1, JLS 8.4.3.3, JLS 8.4.3.4).
All interface methods must ACC_ABSTRACThave their  and ACC_PUBLIC flags
set; they may have ACC_VARARGStheir , ACC_BRIDGE and ACC_SYNTHETIC flags
set and must not have any of the other flags in Table 4.20 set (JLS 9.4).
A specific instance initialization 2.9) may method have (at most one of its
ACC_PRIVATE, ACC_PROTECTED, and ACC_PUBLIC flags set, and may also have
its ACC_STRICT, ACC_VARARGS and ACC_SYNTHETIC flags set, but must not have
any of the other flags in Table 4.20 set.
Class and interface initialization 2.9) are methods called ( implicitly by the
Java virtual machine. The value access_flagsof their  item is ignored except
for the setting of the ACC_STRICT flag.
All bits of access_flagsthe  item not assigned Table in 4.20 are reserved for
future use. They should be set to zero class in files generated and should be
ignored by Java virtual machine implementations.
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing either one of the special
method names 2.9() <init> or <clinit>, or a valid unqualified 4.2.2)name (
denoting a method.
descriptor_index
The value of descriptor_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing a valid method descriptor
(4.3.3).
Commentary: A future edition of this specification may require that the last parameter
descriptor of the method descriptor is ACC_VARARGSan array type  flag if is the set in the
access_flags item.
attributes_count
The value of attributes_countthe  item indicates the number of additional
attributes (4.7) of this method.
attributes[]
Each value of attributesthe  table must be an attribute 4.7). structure A(
method can have any number of optional attributes associated with it.
100
--------------------------------------- 119
THE CLASS FILE FORMATAttributes 4.7
The attributes defined by this specification attributesas appearing in the 
table of method_infoa  structure are Codethe  4.7.3(), Exceptions
(4.7.5), Synthetic (4.7.8), Signature (4.7.9), Deprecated 4.7.15(),
RuntimeVisibleAnnotations (4.7.16), RuntimeInvisibleAnnotations
(4.7.17), RuntimeVisibleParameterAnnotations 4.7.18(),
RuntimeInvisibleParameterAnnotations (4.7.19), and
AnnotationDefault (4.7.20) attributes.
A Java virtual machine implementation must recognize and correctly
read Code (4.7.3) and Exceptions 4.7.5() attributes found in the
attributes table of method_infoa  structure. If a Java virtual machine
implementation recognizes class files whose version number is 49.0
or above, it must recognize and correctly Signature (4.7.9read ),
RuntimeVisibleAnnotations (4.7.16), RuntimeInvisibleAnnotations
(4.7.17), RuntimeVisibleParameterAnnotations 4.7.18(),
RuntimeInvisibleParameterAnnotations (4.7.19) and
AnnotationDefault (4.7.20) attributes found attributesin the  table of a
method_info structure classof  a file whose version number is 49.0 or above.
A Java virtual machine implementation is required to silently ignore any or
all attributes attributesin the  table of method_infoa  structure that it does
not recognize. Attributes not defined in this specification are not allowed to
affect the semantics classof  file, the but only to provide additional descriptive
information (4.7.1).
4.7 Attributes
Attributes are used ClassFilein the  (4.1), field_info (4.5), method_info
(4.6) and Code_attribute (4.7.3) structures classof the  file format. All
attributes have the following general format:
attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
For all attributes, attribute_name_indexthe  must be a valid unsigned 16-
bit index into the constant pool of constant_poolthe class.  entryThe 
at attribute_name_index must be CONSTANT_Utf8_infoa  (4.4.7) structure
representing the name of the attribute. attribute_lengthThe value of  itemthe 
indicates the length of the subsequent information in bytes. The length does
101
--------------------------------------- 120
4.7AttributesTHE CLASS FILE FORMAT
not include the initial six bytes attribute_name_indexthat contain the  and
attribute_length items.
Certain attributes are predefined classas  file part specification. of the They are
listed Table in 4.21, accompanied by the version of the Java Platform, Standard
Edition ("Java SE") and the version class file of format the in which each first
appeared. Within the context of their use in this specification, that is, in the
attributes tables of classthe  file structures in which they appear, the names of
these predefined attributes are reserved. Of the predefined attributes:
 The ConstantValue, Code and Exceptions attributes must be recognized and
correctly read classby  a file reader for correct interpretation class fileof the 
by a Java virtual machine implementation.
 The InnerClasses, EnclosingMethod and Synthetic attributes must be
recognized and correctly classread  file by a reader in order to properly
implement the Java platform class libraries (2.12).
 The RuntimeVisibleAnnotations, RuntimeInvisibleAnnotations,
RuntimeVisibleParameterAnnotations,
RuntimeInvisibleParameterAnnotations and AnnotationDefault attributes
must be recognized and correctly class read file by reader a in order to properly
implement the Java platform class 2.12), libraries if classthe  (file's version
number is 49.0 or above and the Java virtual machine implementation recognizes
class files whose version number is 49.0 or above.
 The Signature attribute must be recognized and correctly class fileread by a 
reader if classthe  file's version number is 49.0 or above and the Java virtual
machine implementation recognizes class files whose version number is 49.0
or above.
 The StackMapTable attribute must be recognized and correctly classread by a 
file reader classif the  file's version number is 50.0 or above and the Java virtual
machine implementation recognizes class files whose version number is 50.0
or above.
 The BootstrapMethods attribute must be recognized and correctly read by a
class file reader classif  the file's version number is 51.0 or above and the Java
virtual machine implementation classrecognizes  files whose version number
is 51.0 or above.
Use of the remaining predefined attributes class file is optional; reader may a use
the information they contain, or otherwise must silently ignore those attributes.
102
--------------------------------------- 121
THE CLASS FILE FORMATDefining and Naming New Attributes4.7.1
Table 4.21. Predefined class file attributes
AttributeJava SEclass file
ConstantValue (4.7.2)1.0.245.3
Code (4.7.3)1.0.245.3
StackMapTable (4.7.4)650.0
Exceptions (4.7.5)1.0.245.3
InnerClasses (4.7.6)1.145.3
EnclosingMethod (4.7.7)5.049.0
Synthetic (4.7.8)1.145.3
Signature (4.7.9)5.049.0
SourceFile (4.7.10)1.0.245.3
SourceDebugExtension (4.7.11)5.049.0
LineNumberTable (4.7.12)1.0.245.3
LocalVariableTable (4.7.13)1.0.245.3
LocalVariableTypeTable (4.7.14)5.049.0
Deprecated (4.7.15)1.145.3
RuntimeVisibleAnnotations (4.7.16)5.049.0
RuntimeInvisibleAnnotations (4.7.17)5.049.0
RuntimeVisibleParameterAnnotations (4.7.18)5.049.0
RuntimeInvisibleParameterAnnotations (4.7.19)5.049.0
AnnotationDefault (4.7.20)5.049.0
BootstrapMethods (4.7.21)751.0
4.7.1Defining and Naming New Attributes
Compilers are permitted to define classand  files emit containing new
attributes attributesin the  tables classof  file structures. Java virtual machine
implementations are permitted to recognize and use new attributes found in the
attributes tables classof  file structures. However, any attribute not defined as
part of this Java virtual machine specification must not affect the semantics of class
or interface types. Java virtual machine implementations are required to silently
ignore attributes they do not recognize.
103
--------------------------------------- 122
4.7.2 The ConstantValue AttributeTHE CLASS FILE FORMAT
For instance, defining a new attribute to support vendor-specific debugging is
permitted. Because Java virtual machine implementations are required to ignore
attributes they do not classrecognize,  files intended for that particular Java virtual
machine implementation will be usable by other implementations even if those
implementations cannot make use of the additional debugging information that the
class files contain.
Java virtual machine implementations are specifically prohibited from throwing an
exception or otherwise refusing class files to use simply because of the presence of
some new attribute. Of course, tools classoperating  files may on not run correctly
if given class files that do not contain all the attributes they require.
Two attributes that are intended to be distinct, but that happen to use the same
attribute name and are of the same length, will conflict on implementations that
recognize either attribute. Attributes defined other than in this specification must
have names chosen according to the package naming convention Thedescribed in 
Java Language Specification, Java SE 7 Edition (JLS 6.1).
Future versions of this specification may define additional attributes.
4.7.2The ConstantValue Attribute
The ConstantValue attribute is a fixed-length attributesattribute  tablein the 
of field_infoa  (4.5) structure. ConstantValueA  attribute represents the value
of a constant field. There can be ConstantValueno more than  attribute one in the
attributes table of a field_infogiven  structure. If the field is static (that is,
the ACC_STATIC flag Table (4.19) in the access_flags item of field_infothe 
structure is set) then the constant field field_inforepresented  structureby the 
is assigned the value referenced ConstantValueby its  attribute as part of the
initialization of the class or interface declaring 5.5). This the occursconstant field (
prior to the invocation of the class or interface 2.9) initialization of thatmethod (
class or interface.
If field_infoa  structure representing a non-static ConstantValuefield has a 
attribute, then that attribute must silently be ignored. Every Java virtual machine
implementation must recognize ConstantValue attributes.
The ConstantValue attribute has the following format:
ConstantValue_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 constantvalue_index;
}
104
--------------------------------------- 123
THE CLASS FILE FORMATThe Code Attribute4.7.3
The items of the ConstantValue_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"ConstantValue".
attribute_length
The value of attribute_lengththe  item of ConstantValue_attributea 
structure must be 2.
constantvalue_index
The value of constantvalue_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index gives the
constant value represented by this constant_poolattribute.  entry The must be
of a type appropriate to the field, as shown by Table 4.22.
Table 4.22. Constant value attribute types
Field TypeEntry Type
longCONSTANT_Long
floatCONSTANT_Float
doubleCONSTANT_Double
int, short, char, byte, booleanCONSTANT_Integer
StringCONSTANT_String
4.7.3The Code Attribute
The Code attribute is a variable-length attributesattribute  table in the of a
method_info (4.6) structure. Code A attribute contains the Java virtual machine
instructions and auxiliary information for a single method, instance initialization
method 2.9( ), or class or interface initialization 2.9). Every method Java virtual(
machine implementation must Coderecognize  attributes. If the method is either
native or abstract, its method_info structure must not Codehave  attribute.a 
Otherwise, its method_info structure must have exactly one Code attribute.
The Code attribute has the following format:
105
--------------------------------------- 124
4.7.3 The Code AttributeTHE CLASS FILE FORMAT
Code_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 max_stack;
    u2 max_locals;
    u4 code_length;
    u1 code[code_length];
    u2 exception_table_length;
    {   u2 start_pc;
        u2 end_pc;
        u2 handler_pc;
        u2 catch_type;
    } exception_table[exception_table_length];
    u2 attributes_count;
    attribute_info attributes[attributes_count];
}
The items of the Code_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing the string "Code".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
max_stack
The value of max_stackthe  item gives the maximum depth of the operand
stack of this method (2.6.2) at any point during execution of the method.
max_locals
The value of max_localsthe  item gives the number of local variables in
the local variable array allocated upon invocation 2.6.1), of this method (
including the local variables used to pass parameters to the method on its
invocation.
The greatest local variable index for longa  value or doubleof  istype 
max_locals - 2. The greatest local variable index for a value of any other
type is max_locals - 1.
code_length
The value of code_lengththe  item gives the number of codebytes  arrayin the 
for this method. The code_lengthvalue of  must be greater than codezero; the 
array must not be empty.
106
--------------------------------------- 125
THE CLASS FILE FORMATThe Code Attribute4.7.3
code[]
The code array gives the actual bytes of Java virtual machine code that
implement the method.
When the code array is read into memory on a byte-addressable machine, if
the first byte of the array is aligned on tableswitcha 4-byte  andboundary, the 
lookupswitch 32-bit offsets will be 4-byte aligned. (Refer to the descriptions
of those instructions for more information on codethe  arrayconsequences of 
alignment.)
The detailed constraints on the codecontents  array of are the extensive and are
given in a separate section (4.9).
exception_table_length
The value of exception_table_lengththe  item gives the number of entries
in the exception_table table.
exception_table[]
Each entry in exception_tablethe  array describes one exception handler in
the code array. The order of the handlers exception_tablein the  array is
significant (2.10).
Each exception_table entry contains the following four items:
start_pc, end_pc
The values of the two start_pcitems  and end_pc indicate the ranges in the
code array at which the exception handler is start_pcactive. The value of 
must be a valid index codeinto  array the of the opcode of an instruction.
The value end_pcof  either must be a valid index code array into of the the
opcode of an instruction or must code_lengthbe equal , the to length of the
code array. The value start_pcof  must be less than the end_pcvalue .of 
The start_pc is inclusive end_pcand  is exclusive; that is, the exception
handler must be active while the program counter is within the interval
[start_pc, end_pc).
The fact end_pcthat  is exclusive is a historical mistake in the design of the Java virtual
machine: if the Java virtual machine code for a method is exactly 65535 bytes long and
ends with an instruction that is 1 byte long, then that instruction cannot be protected
by an exception handler. A compiler writer can work around this bug by limiting the
maximum size of the generated Java virtual machine code for any method, instance
initialization method, or static initializer (the size of any code array) to 65534 bytes.
107
--------------------------------------- 126
4.7.4 The StackMapTable AttributeTHE CLASS FILE FORMAT
handler_pc
The value of handler_pcthe  item indicates the start of the exception
handler. The value of the item must be a codevalid  arrayindex into the 
and must be the index of the opcode of an instruction.
catch_type
If the value catch_typeof the  item is nonzero, it must be a valid index
into the constant_pool table. constant_poolThe  entry at that index
must be CONSTANT_Class_infoa  (4.4.1) structure representing a class of
exceptions that this exception handler is designated to catch. The exception
handler will be called only if the thrown exception is an instance of the
given class or one of its subclasses.
If the value catch_typeof the  item is zero, this exception handler is called
for all exceptions. This is used to implement finally (3.13).
attributes_count
The value of attributes_countthe  item indicates the number of attributes of
the Code attribute.
attributes[]
Each value of attributesthe  table must be an attribute 4.7). structure A(
Code attribute can have any number of optional attributes associated with it.
The only attributes defined by this specification as appearing in the
attributes table of Codea  attribute are LineNumberTablethe  4.7.12(),
LocalVariableTable 4.7.13(), LocalVariableTypeTable (4.7.14), and
StackMapTable (4.7.4) attributes.
If a Java virtual machine implementation class files recognizes whose version
number is 50.0 or above, it must recognize StackMapTableand correctly read 
(4.7.4) attributes found attributesin the  table Codeof a  attribute classof a 
file whose version number is 50.0 or above.
A Java virtual machine implementation is required to silently ignore any or
all attributes attributesin the  table of Codea  attribute that it does not
recognize. Attributes not defined in this specification are not allowed to affect
the semantics of classthe  file, but only to provide additional descriptive
information (4.7.1).
4.7.4The StackMapTable Attribute
The StackMapTable attribute is a variable-length attributesattribute in the 
table of Codea  4.7.3() attribute. This attribute is used during the process of
108
--------------------------------------- 127
THE CLASS FILE FORMATThe StackMapTable Attribute4.7.4
verification by typechecking 4.10.1). A (method's Code attribute may have at most
one StackMapTable attribute.
A StackMapTable attribute consists of zero stack or map more frames. Each
stack map frame specifies (either explicitly or implicitly) a bytecode offset, the
verification 4.10.1types ) (for the local variables, and the verification types for
the operand stack.
The type checker deals with and manipulates the expected types of a method's local
variables and operand stack. Throughout locationthis  refers section, to either a a
single local variable or to a single operand stack entry.
We will use the stack terms map frame and type state interchangeably to describe
a mapping from locations in the operand stack and local variables of a method
to verification types. We will usually stack use map the frame when term such a
mapping is provided classin  the file, and the type term state when the mapping
is used by the type checker.
In classa  file whose version number is greater than or equal to 50.0, if a method's
Code attribute does not StackMapTablehave a  attribute, it implicit has an stack
map attribute. This implicit stack map attribute StackMapTableis equivalent to a 
attribute with number_of_entries equal to zero.
The StackMapTable attribute has the following format:
StackMapTable_attribute {
    u2              attribute_name_index;
    u4              attribute_length;
    u2              number_of_entries;
    stack_map_frame entries[number_of_entries];
}
The items of the StackMapTable_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"StackMapTable".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
109
--------------------------------------- 128
4.7.4 The StackMapTable AttributeTHE CLASS FILE FORMAT
number_of_entries
The value of number_of_entriesthe  item gives the number of
stack_map_frame entries in the entries table.
entries
The entries array gives the method's stack_map_frame structures.
Each stack_map_frame structure specifies the type state at a particular bytecode
offset. Each frame type specifies (explicitly offset_deltaor implicitly) ,a value, 
that is used to calculate the actual bytecode offset at which a frame applies. The
bytecode offset at which a frame applies is offset_deltacalculated by adding 
+ 1 to the bytecode offset of the previous frame, unless the previous frame is the
initial frame of the method, in which case the bytecode offset is offset_delta.
By using an offset delta rather than the actual bytecode offset we ensure, by definition, that
stack map frames are in the correctly sorted order. Furthermore, by consistently using the
formula offset_delta + 1 for all explicit frames, we guarantee the absence of duplicates.
We say that an instruction in the bytecode has a corresponding stack map frame
if the instruction starts i in at the codeoffset  array of Codea  attribute, and
the Code attribute has StackMapTablea  attribute whose entries array has a
stack_map_frame structure that applies at bytecode offset i.
The stack_map_frame structure consists of a one-byte tag followed by zero or
more bytes, giving more information, depending upon the tag.
A stack map frame may belong to one of several frame types:
union stack_map_frame {
    same_frame;
    same_locals_1_stack_item_frame;
    same_locals_1_stack_item_frame_extended;
    chop_frame;
    same_frame_extended;
    append_frame;
    full_frame;
}
All frame types, full_frameeven , rely on the previous frame for some of their
semantics. This raises the question of what is the very first frame? The initial frame
is implicit, and computed from the method descriptor. See the Prolog code for
methodInitialStackFrame (the section called Checking Code).
 The frame type same_frame is represented by tags in the range [0-63]. If the
frame type same_frameis , it means the frame has exactly the same locals as
110
--------------------------------------- 129
THE CLASS FILE FORMATThe StackMapTable Attribute4.7.4
the previous stack map frame and that the number of stack items is zero. The
offset_delta value for the frame is the value of the tag item, frame_type.
same_frame {
    u1 frame_type = SAME; /* 0-63 */
}
 The frame type same_locals_1_stack_item_frame is represented by tags in
the range [64, 127]. If the same_locals_1_stack_item_frameframe_type is , it
means the frame has exactly the same locals as the previous stack map frame and
that the number of stack items offset_deltais 1.  The value for the frame is the
value (frame_type - 64). There verification_type_infois a  following the
frame_type for the one stack item.
same_locals_1_stack_item_frame {
    u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
    verification_type_info stack[1];
}
Tags in the range [128-246] are reserved for future use.
 The frame type same_locals_1_stack_item_frame_extended is represented
by the tag 247. The frame same_locals_1_stack_item_frame_extendedtype 
indicates that the frame has exactly the same locals as the previous stack map
frame and that the number of stack offset_deltaitems is  1. value The for the
frame is given explicitly. verification_type_infoThere is a  following the
frame_type for the one stack item.
same_locals_1_stack_item_frame_extended {
    u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
    u2 offset_delta;
    verification_type_info stack[1];
}
 The frame type chop_frame is represented by tags in the range [248-250]. If the
frame_type is chop_frame, it means that the operand stack is empty and the
current locals are the same as the locals in the previous kframe, except that the 
last locals are absent. k The is given value by of the 251 formula - frame_type.
chop_frame {
    u1 frame_type = CHOP; /* 248-250 */
    u2 offset_delta;
}
 The frame type same_frame_extended is represented by the tag value 251. If the
frame type same_frame_extendedis , it means the frame has exactly the same
locals as the previous stack map frame and that the number of stack items is zero.
111
--------------------------------------- 130
4.7.4 The StackMapTable AttributeTHE CLASS FILE FORMAT
same_frame_extended {
    u1 frame_type = SAME_FRAME_EXTENDED; /* 251 */
    u2 offset_delta;
}
 The frame type append_frame is represented by tags in the range [252-254]. If
the frame_type is append_frame, it means that the operand stack is empty and
the current locals are the same as the locals in the kprevious frame, except that 
additional locals are defined. k is The given value by of the frame_typeformula 
- 251.
append_frame {
    u1 frame_type = APPEND; /* 252-254 */
    u2 offset_delta;
    verification_type_info locals[frame_type - 251];
}
The 0th entry localsin  represents the type of the first additional local variable.
If locals[M] represents local Nvariable , then locals[M+1] represents local
variable N+1 if locals[M] is one of:
Top_variable_info
Integer_variable_info
Float_variable_info
Null_variable_info
UninitializedThis_variable_info
Object_variable_info
Uninitialized_variable_info
Otherwise locals[M+1] represents local variable N+2.
It is an error if, for i, locals[any iindex ] represents a local variable whose
index is greater than the maximum number of local variables for the method.
 The frame type full_frame is represented by the tag value 255.
full_frame {
    u1 frame_type = FULL_FRAME; /* 255 */
    u2 offset_delta;
    u2 number_of_locals;
    verification_type_info locals[number_of_locals];
    u2 number_of_stack_items;
    verification_type_info stack[number_of_stack_items];
}
112
--------------------------------------- 131
THE CLASS FILE FORMATThe StackMapTable Attribute4.7.4
The 0th entry localsin  represents the type of local locals[M]variable 0. If 
represents local Nvariable , then locals[M+1] represents local N+1variable  if
locals[M] is one of:
Top_variable_info
Integer_variable_info
Float_variable_info
Null_variable_info
UninitializedThis_variable_info
Object_variable_info
Uninitialized_variable_info
Otherwise locals[M+1] represents local variable N+2.
It is an error if, for i, locals[any iindex ] represents a local variable whose
index is greater than the maximum number of local variables for the method.
The 0th entry stackin  represents the type of the bottom of the stack, and
subsequent entries represent types of stack elements closer to the top of the
operand stack. We shall refer to the bottom element of the stack as stack element
0, and to subsequent elements as stack stack[M]element  represents1, 2 etc. If 
stack element N, then stack[M+1] represents stack N+1element  if stack[M] is
one of:
Top_variable_info
Integer_variable_info
Float_variable_info
Null_variable_info
UninitializedThis_variable_info
Object_variable_info
Uninitialized_variable_info
Otherwise, stack[M+1] represents stack element N+2.
It is an error if, for i, stack[any i]index  represents a stack entry whose index
is greater than the maximum operand stack size for the method.
The verification_type_info structure consists of a one-byte tag followed
by zero or more bytes, giving more information about the tag. Each
113
--------------------------------------- 132
4.7.4 The StackMapTable AttributeTHE CLASS FILE FORMAT
verification_type_info structure specifies the verification type of one or two
locations.
union verification_type_info {
    Top_variable_info;
    Integer_variable_info;
    Float_variable_info;
    Long_variable_info;
    Double_variable_info;
    Null_variable_info;
    UninitializedThis_variable_info;
    Object_variable_info;
    Uninitialized_variable_info;
}
 The Top_variable_info type indicates that the local variable has the
verification type top ().
Top_variable_info {
    u1 tag = ITEM_Top; /* 0 */
}
 The Integer_variable_info type indicates that the location contains the
verification type int.
Integer_variable_info {
    u1 tag = ITEM_Integer; /* 1 */
}
 The Float_variable_info type indicates that the location contains the
verification type float.
Float_variable_info {
    u1 tag = ITEM_Float; /* 2 */
}
 The Long_variable_info type indicates that the location contains the
verification type long.
Long_variable_info {
    u1 tag = ITEM_Long; /* 4 */
}
This structure gives the contents of two locations in the operand stack or in the
local variable array.
If the location is a local variable, then:
It must not be the local variable with the highest index.
The next higher numbered local variable contains the verification type .
114
--------------------------------------- 133
THE CLASS FILE FORMATThe StackMapTable Attribute4.7.4
If the location is an operand stack entry, then:
The current location must not be the topmost location of the operand stack.
The next location closer to the top of the operand stack contains the verification
type .
 The Double_variable_info type indicates that the location contains the
verification type double.
Double_variable_info {
    u1 tag = ITEM_Double; /* 3 */
}
This structure gives the contents of two locations in in the operand stack or in
the local variable array.
If the location is a local variable, then:
It must not be the local variable with the highest index.
The next higher numbered local variable contains the verification type .
If the location is an operand stack entry, then:
The current location must not be the topmost location of the operand stack.
The next location closer to the top of the operand stack contains the verification
type .
 The Null_variable_info type indicates that location contains the verification
type null.
Null_variable_info {
    u1 tag = ITEM_Null; /* 5 */
}
 The UninitializedThis_variable_info type indicates that the location
contains the verification type uninitializedThis.
UninitializedThis_variable_info {
    u1 tag = ITEM_UninitializedThis; /* 6 */
}
 The Object_variable_info type indicates that the location contains an instance
of the class represented CONSTANT_Class_infoby the  (4.4.1) structure found
in the constant_pool table at the index given by cpool_index.
115
--------------------------------------- 134
4.7.5 The Exceptions AttributeTHE CLASS FILE FORMAT
Object_variable_info {
    u1 tag = ITEM_Object; /* 7 */
    u2 cpool_index;
}
 The Uninitialized_variable_info type indicates that the location contains
the verification uninitialized(offset)type . The offset item indicates the
offset, in codethe  array of Codethe  attribute 4.7.3() that contains this
StackMapTable attribute, newof  instruction the new) (that created the object
being stored in the location.
Uninitialized_variable_info {
    u1 tag = ITEM_Uninitialized /* 8 */
    u2 offset;
}
4.7.5The Exceptions Attribute
The Exceptions attribute is a variable-length attributesattribute  table in of the a
method_info (4.6) structure. ExceptionsThe  attribute indicates which checked
exceptions a method may throw. There may Exceptionsbe at most  attributeone 
in each method_info structure.
The Exceptions attribute has the following format:
Exceptions_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 number_of_exceptions;
    u2 exception_index_table[number_of_exceptions];
}
The items of the Exceptions_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be the
CONSTANT_Utf8_info (4.4.7) structure representing Exceptionsthe string "."
attribute_length
The value of attribute_lengththe  item indicates the attribute length,
excluding the initial six bytes.
number_of_exceptions
The value of number_of_exceptionsthe  item indicates the number of entries
in the exception_index_table.
116
--------------------------------------- 135
THE CLASS FILE FORMATThe InnerClasses Attribute4.7.6
exception_index_table[]
Each value in exception_index_tablethe  array must be a valid index into
the constant_pool table. constant_poolThe  entry referenced by each table
item must be CONSTANT_Class_infoa  4.4.1() structure representing a class
type that this method is declared to throw.
A method should throw an exception only if at least one of the following three criteria is
met:
 The exception is an instance of RuntimeException or one of its subclasses.
 The exception is an instance of Error or one of its subclasses.
 The exception is an instance of one of the exception classes specified in the
exception_index_table just described, or one of their subclasses.
These requirements are not enforced in the Java virtual machine; they are enforced only
at compile-time.
4.7.6The InnerClasses Attribute
The InnerClasses attribute is a variable-length attributesattribute  tablein the 
of a ClassFile (4.1) structure. If the constant pool of Ca class or interface 
contains CONSTANT_Class_infoa  entry which represents a class or interface that
is not a member of a package, C's ClassFilethen  structure must have exactly one
InnerClasses attribute in its attributes table.
The InnerClasses attribute has the following format:
InnerClasses_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 number_of_classes;
    {   u2 inner_class_info_index;
        u2 outer_class_info_index;
        u2 inner_name_index;
        u2 inner_class_access_flags;
    } classes[number_of_classes];
}
The items of the InnerClasses_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"InnerClasses".
117
--------------------------------------- 136
4.7.6 The InnerClasses AttributeTHE CLASS FILE FORMAT
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
number_of_classes
The value of number_of_classesthe  item indicates the number of entries in
the classes array.
classes[]
Every CONSTANT_Class_info entry in constant_poolthe  table which
represents a class or C that interface is not a package member must have exactly
one corresponding entry in the classes array.
If a class has members that are classes constant_poolor interfaces,  table its 
(and hence InnerClassesits  attribute) must refer to each such member, even
if that member is not otherwise mentioned by the class. These rules imply that
a nested class or interface member InnerClasseswill  have information for
each enclosing class and for each immediate member.
Each classes array entry contains the following four items:
inner_class_info_index
The value of inner_class_info_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be
a CONSTANT_Class_info (4.4.1) structure representing C. The remaining
items in the classes array entry give information about C.
outer_class_info_index
If C is not a member of a class or an interface C is a top-level(that is, if 
class or interface (JLS 7.6) or a local class (JLS 14.3) or an anonymous
class (JLS 15.9.5)), the outer_class_info_indexvalue of the  item must
be zero.
Otherwise, the value outer_class_info_indexof the  item must be a
valid index into constant_poolthe  table, and the entry at that index must
be a CONSTANT_Class_info (4.4.1) structure representing the class or
interface of which C is a member.
inner_name_index
If C is anonymous (JLS 15.9.5), the inner_name_indexvalue of the  item
must be zero.
Otherwise, the value inner_name_indexof the  item must be a valid index
into the constant_pool table, and the entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure that represents the original simple
118
--------------------------------------- 137
THE CLASS FILE FORMATThe InnerClasses Attribute4.7.6
name of C, as given in the source code from class which file wasthis 
compiled.
inner_class_access_flags
The value of inner_class_access_flagsthe  item is a mask of flags used
to denote access permissions to and properties C of as class or interface 
declared in the source code from classwhich  file this was compiled. It is
used by compilers to recover the original information when source code is
not available. The flags are shown in Table 4.23.
Table 4.23. Nested class access and property flags
Flag NameValueInterpretation
ACC_PUBLIC0x0001Marked or implicitly public in source.
ACC_PRIVATE0x0002Marked private in source.
ACC_PROTECTED0x0004Marked protected in source.
ACC_STATIC0x0008Marked or implicitly static in source.
ACC_FINAL0x0010Marked final in source.
ACC_INTERFACE0x0200Was an interface in source.
ACC_ABSTRACT0x0400Marked or implicitly abstract in source.
ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.
ACC_ANNOTATION0x2000Declared as an annotation type.
ACC_ENUM0x4000Declared as an enum type.
All bits of inner_class_access_flagsthe  item not assigned in
Table 4.23 are reserved for future use. They should be set to zero in
generated class files and should be ignored by Java virtual machine
implementations.
If a class file has a version number that is greater than or equal to
51.0, and has InnerClassesan  attribute attributesin its  table, then for
all entries classesin the  array of InnerClassesthe  attribute, the value
of the outer_class_info_index item must be zero if the value of the
inner_name_index item is zero.
Oracle's Java virtual machine implementation does not check the consistency of an
InnerClasses attribute against class file a representing a class or interface referenced
by the attribute.
119
--------------------------------------- 138
4.7.7 The EnclosingMethod AttributeTHE CLASS FILE FORMAT
4.7.7The EnclosingMethod Attribute
The EnclosingMethod attribute is an optional fixed-length attribute in the
attributes table of ClassFilea  4.1( ) structure. A class must have an
EnclosingMethod attribute if and only if it is a local class or an anonymous class.
A class may have no more than one EnclosingMethod attribute.
The EnclosingMethod attribute has the following format:
EnclosingMethod_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 class_index;
    u2 method_index;
}
The items of the EnclosingMethod_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"EnclosingMethod".
attribute_length
The value of the attribute_length item is four.
class_index
The value of class_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Class_info (4.4.1) structure representing the innermost class that
encloses the declaration of the current class.
method_index
If the current class is not immediately enclosed by a method or constructor,
then the value of the method_index item must be zero.
Otherwise, the value method_indexof the  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_NameAndType_info (4.4.6) structure representing the name and
type of a method in the class referenced by the class_index attribute above.
It is the responsibility of the Java compiler to ensure that the method identified via the
method_index is indeed the closest lexically enclosing method of the class that contains
this EnclosingMethod attribute.
120
--------------------------------------- 139
THE CLASS FILE FORMATThe Synthetic Attribute4.7.8
4.7.8The Synthetic Attribute
The Synthetic attribute is a fixed-length attributesattribute  table in the of a
ClassFile (4.1), field_info (4.5) or method_info (4.6) structure. A class
member that does not appear in the source code must Syntheticbe marked using a 
attribute, or else it must ACC_SYNTHETIChave its  flag set. The only exceptions
to this requirement are compiler-generated methods which are not considered
implementation artifacts, namely the instance initialization method representing a
default constructor of the Java programming 2.9), the language class initialization(
method (2.9), and the Enum.values() and Enum.valueOf() methods.
The Synthetic attribute was introduced in JDK release 1.1 to support nested classes and
interfaces.
The Synthetic attribute has the following format:
Synthetic_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
}
The items of the Synthetic_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing the string "Synthetic".
attribute_length
The value of the attribute_length item is zero.
4.7.9The Signature Attribute
The Signature attribute is an optional fixed-length attributesattribute in the 
table of ClassFilea  4.1( ), field_info 4.5( ) or method_info (4.6) structure.
The Signature attribute records generic signature information for any class,
interface, constructor or member whose generic signature in the Java programming
language would include references to type variables or parameterized types.
The Signature attribute has the following format:
Signature_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 signature_index;
}
121
--------------------------------------- 140
4.7.10 The SourceFile AttributeTHE CLASS FILE FORMAT
The items of the Signature_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing the string "Signature".
attribute_length
The value of attribute_lengththe  item of Signature_attributea  structure
must be 2.
signature_index
The value of signature_indexthe  item must be a valid index into the
constant_pool table. The constant pool entry at that index must be a
CONSTANT_Utf8_info 4.4.7() structure representing a class 4.3.4) signature (
if this Signature attribute is an attribute ClassFile of structure; a a method
signature if Signaturethis  attribute is an attribute method_infoof  structure;a 
or a field type signature otherwise.
4.7.10The SourceFile Attribute
The SourceFile attribute is an optional fixed-length attributesattribute in the 
table of ClassFilea  (4.1) structure. There can be no SourceFilemore than one 
attribute in the attributes table of a given ClassFile structure.
The SourceFile attribute has the following format:
SourceFile_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 sourcefile_index;
}
The items of the SourceFile_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing SourceFilethe string "."
attribute_length
The value of attribute_lengththe  item of SourceFile_attributea 
structure must be 2.
122
--------------------------------------- 141
THE CLASS FILE FORMATThe SourceDebugExtension Attribute4.7.11
sourcefile_index
The value of sourcefile_indexthe  item must be a valid index into the
constant_pool table. The constant pool entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing a string.
The string referenced sourcefile_indexby the  item will be interpreted as
indicating the name of the source file classfrom  file which was compiled.this 
It will not be interpreted as indicating the name of a directory containing the
file or an absolute path name for the file; such platform-specific additional
information must be supplied by the runtime interpreter or development tool
at the time the file name is actually used.
4.7.11The SourceDebugExtension Attribute
The SourceDebugExtension attribute is an optional attribute attributes in the 
table of ClassFilea  (4.1) structure. There can be no more than one
SourceDebugExtension attribute attributesin the  table of a ClassFilegiven 
structure.
The SourceDebugExtension attribute has the following format:
SourceDebugExtension_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 debug_extension[attribute_length];
}
The items of the SourceDebugExtension_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"SourceDebugExtension".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus the number of bytes in the
debug_extension[] item.
123
--------------------------------------- 142
4.7.12 The LineNumberTable AttributeTHE CLASS FILE FORMAT
debug_extension[]
The debug_extension array holds extended debugging information which has
no semantic effect on the Java virtual machine. The information is represented
using a modified UTF-8 string (4.4.7) with no terminating zero byte.
Note that debug_extensionthe  array may denote a string longer than that which can be
represented with an instance of class String.
4.7.12The LineNumberTable Attribute
The LineNumberTable attribute is an optional variable-length attribute in the
attributes table of Codea  (4.7.3) attribute. It may be used by debuggers to
determine which part of the Java codevirtual  array machine corresponds to a given
line number in the original source file.
If LineNumberTable attributes are present attributesin the  table of a given
Code attribute, then they may appear in any order. Furthermore, multiple
LineNumberTable attributes may together represent a given line of a source file;
that is, LineNumberTable attributes need not be one-to-one with source lines.
The LineNumberTable attribute has the following format:
LineNumberTable_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 line_number_table_length;
    {   u2 start_pc;
        u2 line_number; 
    } line_number_table[line_number_table_length];
}
The items of the LineNumberTable_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"LineNumberTable".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
line_number_table_length
The value of line_number_table_lengththe  item indicates the number of
entries in the line_number_table array.
124
--------------------------------------- 143
THE CLASS FILE FORMATThe LocalVariableTable Attribute4.7.13
line_number_table[]
Each entry in line_number_tablethe  array indicates that the line number
in the original source file changes at codea given  array. point Eachin the 
line_number_table entry must contain the following two items:
start_pc
The value of start_pcthe  item must indicate the index code arrayinto the 
at which the code for a new line in the original source file begins.
The value start_pcof  must be less than the value code_lengthof the 
item of the Code attribute of which this LineNumberTable is an attribute.
line_number
The value of line_numberthe  item must give the corresponding line
number in the original source file.
4.7.13The LocalVariableTable Attribute
The LocalVariableTable attribute is an optional variable-length attribute in the
attributes table of Codea  (4.7.3) attribute. It may be used by debuggers to
determine the value of a given local variable during the execution of a method.
If LocalVariableTable attributes are present attributesin the  table of a given
Code attribute, then they may appear in any order. There may be no more than one
LocalVariableTable attribute per local variable in the Code attribute.
The LocalVariableTable attribute has the following format:
LocalVariableTable_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 local_variable_table_length;
    {   u2 start_pc;
        u2 length;
        u2 name_index;
        u2 descriptor_index;
        u2 index;
    } local_variable_table[local_variable_table_length];
}
The items of the LocalVariableTable_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
125
--------------------------------------- 144
4.7.13 The LocalVariableTable AttributeTHE CLASS FILE FORMAT
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"LocalVariableTable".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
local_variable_table_length
The value of local_variable_table_lengththe  item indicates the number
of entries in the local_variable_table array.
local_variable_table[]
Each entry in local_variable_tablethe  array indicates a coderange  arrayof 
offsets within which a local variable has a value. It also indicates the index into
the local variable array of the current frame at which that local variable can be
found. Each entry must contain the following five items:
start_pc, length
The given local variable must have a value codeat  array indices in into the 
the interval start_pc[ , start_pc + length), that is, between start_pc
inclusive and start_pc + length exclusive.
The value start_pcof  must be a valid index codeinto  array the of this
Code attribute and must be the index of the opcode of an instruction.
The value start_pc of + length must either be a valid index codeinto the 
array of Codethis  attribute and be the index of the opcode of an instruction,
or it must be the first index beyond the end of that code array.
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must contain
a CONSTANT_Utf8_info (4.4.7) structure representing a valid unqualified
name (4.2.2) denoting a local variable.
descriptor_index
The value of descriptor_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must contain
a CONSTANT_Utf8_info (4.4.7) structure representing a field descriptor
(4.3.2) encoding the type of a local variable in the source program.
index
The given local variable indexmust  in be the at local variable array of the
current frame.
126
--------------------------------------- 145
THE CLASS FILE FORMATThe LocalVariableTypeTable Attribute4.7.14
If the local variable index is at of type double or long, it occupies both
index and index + 1.
4.7.14The LocalVariableTypeTable Attribute
The LocalVariableTypeTable attribute is an optional variable-length attribute in
the attributes table of Codea  (4.7.3) attribute. It may be used by debuggers to
determine the value of a given local variable during the execution of a method.
If LocalVariableTypeTable attributes are present attributesin the  table of a
given Code attribute, then they may appear in any order. There may be no more than
one LocalVariableTypeTable attribute per local variable in the Code attribute.
The LocalVariableTypeTable attribute differs LocalVariableTablefrom the 
attribute in that it provides signature information rather than descriptor information.
This difference is only significant for variables whose type is a generic reference
type. Such variables will appear in both tables, while variables of other types will
appear only in LocalVariableTable.
The LocalVariableTypeTable attribute has the following format:
LocalVariableTypeTable_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 local_variable_type_table_length;
    {   u2 start_pc;
        u2 length;
        u2 name_index;
        u2 signature_index;
        u2 index;
    } local_variable_type_table[local_variable_type_table_length];
}
The items of the LocalVariableTypeTable_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"LocalVariableTypeTable".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
127
--------------------------------------- 146
4.7.14 The LocalVariableTypeTable AttributeTHE CLASS FILE FORMAT
local_variable_type_table_length
The value of local_variable_type_table_lengththe  item indicates the
number of entries in the local_variable_type_table array.
local_variable_type_table[]
Each entry in local_variable_type_tablethe  array indicates a coderange of 
array offsets within which a local variable has a value. It also indicates the index
into the local variable array of the current frame at which that local variable
can be found. Each entry must contain the following five items:
start_pc, length
The given local variable must have a value at indices into the code array in
the interval start_pc[ , start_pc + length), that is, between start_pc
inclusive and start_pc + length exclusive.
The value start_pcof  must be a valid index codeinto  array the of this
Code attribute and must be the index of the opcode of an instruction.
The value start_pc of + length must either be a valid index codeinto the 
array of Codethis  attribute and be the index of the opcode of an instruction,
or it must be the first index beyond the end of that code array.
name_index
The value of name_indexthe  item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must contain
a CONSTANT_Utf8_info (4.4.7) structure representing a valid unqualified
name (4.2.2) denoting a local variable.
signature_index
The value of signature_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must
contain CONSTANT_Utf8_infoa  (4.4.7) structure representing a field type
signature 4.3.4() encoding the type of a local variable in the source
program.
index
The given local variable indexmust  in be the at local variable array of the
current frame.
If the local variable index is at of type double or long, it occupies both
index and index + 1.
128
--------------------------------------- 147
THE CLASS FILE FORMATThe Deprecated Attribute4.7.15
4.7.15The Deprecated Attribute
The Deprecated attribute is an optional fixed-length attributesattribute in the 
table of ClassFilea  4.1( ), field_info 4.5( ) or method_info (4.6) structure.
A class, interface, method, or field may Deprecatedbe marked  attribute using a to
indicate that the class, interface, method, or field has been superseded.
A runtime interpreter or tool classthat  file reads format, the such as a compiler,
can use this marking to advise the user that a superceded class, interface, method,
or field is being referred to. DeprecatedThe presence  attribute of a does not alter
the semantics of a class or interface.
The Deprecated attribute has the following format:
Deprecated_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
}
The items of the Deprecated_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing Deprecatedthe string "."
attribute_length
The value of the attribute_length item is zero.
4.7.16The RuntimeVisibleAnnotations attribute
The RuntimeVisibleAnnotations attribute is a variable-length attribute in the
attributes table of ClassFilea  4.1( ), field_info (4.5) or method_info
(4.6) structure. RuntimeVisibleAnnotationsThe  attribute records runtime-
visible Java programming language annotations on the corresponding class, field,
or method.
Each ClassFile, field_info, and method_info structure may contain at most
one RuntimeVisibleAnnotations attribute, which records all the runtime-visible
Java programming language annotations on the corresponding program element.
The Java virtual machine must make these annotations available so they can be
returned by the appropriate reflective APIs.
The RuntimeVisibleAnnotations attribute has the following format:
129
--------------------------------------- 148
4.7.16 The RuntimeVisibleAnnotations attributeTHE CLASS FILE FORMAT
RuntimeVisibleAnnotations_attribute {
    u2         attribute_name_index;
    u4         attribute_length;
    u2         num_annotations;
    annotation annotations[num_annotations];
}
The items of RuntimeVisibleAnnotations_attributethe  structure are as
follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"RuntimeVisibleAnnotations".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the number of
runtime-visible annotations represented by the structure, and their values.
num_annotations
The value of num_annotationsthe  item gives the number of runtime-visible
annotations represented by the structure.
Note that a maximum of 65535 runtime-visible Java programming language annotations
may be directly attached to a program element.
annotations
Each value of annotationsthe  table represents a single runtime-visible
annotation on a program element. The annotation structure has the following
format:
annotation {
    u2 type_index;
    u2 num_element_value_pairs;
    {   u2            element_name_index;
        element_value value;
    } element_value_pairs[num_element_value_pairs];
}
The items of the annotation structure are as follows:
130
--------------------------------------- 149
THE CLASS FILE FORMATThe RuntimeVisibleAnnotations attribute4.7.16
type_index
The value of type_indexthe  item must be a valid index into
the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing a field
descriptor representing the annotation type corresponding to the annotation
represented by this annotation structure.
num_element_value_pairs
The value of num_element_value_pairsthe  item gives the number of
element-value pairs of the annotation represented annotationby this 
structure.
Note that a maximum of 65535 element-value pairs may be contained in a single
annotation.
element_value_pairs
Each value of element_value_pairsthe  table represents a single element-
value pair in the annotation represented annotation structure. by this Each
element_value_pairs entry contains the following two items:
element_name_index
The value of element_name_indexthe  item must be a valid index
into the constant_pool table. constant_poolThe  entry at that index
must be CONSTANT_Utf8_infoa  4.4.7() structure representing a valid
field descriptor 4.3.2) (that denotes the name of the annotation type
element represented by this element_value_pairs entry.
value
The value of valuethe  item represents the value of the element-value
pair represented by this element_value_pairs entry.
4.7.16.1The element_value structure
The element_value structure is a discriminated union representing the
value of an element-value pair. It is used to represent element values
in all attributes that describe RuntimeVisibleAnnotationsannotations (,
RuntimeInvisibleAnnotations, RuntimeVisibleParameterAnnotations, and
RuntimeInvisibleParameterAnnotations).
The element_value structure has the following format:
131
--------------------------------------- 150
4.7.16 The RuntimeVisibleAnnotations attributeTHE CLASS FILE FORMAT
element_value {
    u1 tag;
    union {
        u2 const_value_index;
        {   u2 type_name_index;
            u2 const_name_index;
        } enum_const_value;
        u2 class_info_index;
        annotation annotation_value;
        {   u2            num_values;
            element_value values[num_values];
        } array_value;
    } value;
}
The items of the element_value structure are as follows:
tag
The tag item indicates the type of this annotation element-value pair. The
letters B', C', ''D', 'F', 'I', 'J', 'S', ' and Z' 'indicate a primitive type. These letters
are interpreted BaseTypeas  characters Table ( 4.2). The other legal values for
tag are listed with their interpretations in Table 4.24.
Table 4.24. Interpretation of additional tag values
tag ValueElement Type
sString
eenum constant
cclass
@annotation type
[array
value
The value item represents the value of this annotation element. This item is a
union. The tag item, above, determines which item of the union is to be used:
const_value_index
The const_value_index item is used tagif  item the is one B', Cof ', 'D',''
'F', I', 'J', 'S', 'Z', ' or s'. 'The value const_value_indexof the  item must be
a valid index into constant_poolthe  table. constant_poolThe  entry at
132
--------------------------------------- 151
THE CLASS FILE FORMATThe RuntimeVisibleAnnotations attribute4.7.16
that index must be of the correct entry type for the field type designated by
the tag item, as specified in Table 4.24.
enum_const_value
The enum_const_value item is used if tag the item is e'. 'The
enum_const_value item consists of the following two items:
type_name_index
The value of type_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index
must be CONSTANT_Utf8_infoa  4.4.7() structure representing a valid
field descriptor 4.3.2) (that denotes the internal form of the binary
name 4.2.1() of the type of the enum constant represented by this
element_value structure.
const_name_index
The value of const_name_indexthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the
simple name of the enum constant represented element_valueby this 
structure.
class_info_index
The class_info_index item is used if tag the item is c'. '
The class_info_index item must be a valid index into the
constant_pool table. constant_poolThe  entry at that index must be a
CONSTANT_Utf8_info (4.4.7) structure representing the return descriptor
(4.3.3) of the type that is reified by the class represented by this
element_value structure.
For example, 'V' for Void.class, 'Ljava/lang/Object;' for Object, etc.
annotation_value
The annotation_value item is used if tag the item is @'. 'The
element_value structure represents a "nested" annotation.
array_value
The array_value item is used tagif  item the [is '. 'The array_value item
consists of the following two items:
num_values
The value of num_valuesthe  item gives the number of elements in the
array-typed value represented by this element_value structure.
133
--------------------------------------- 152
4.7.17 The RuntimeInvisibleAnnotations attributeTHE CLASS FILE FORMAT
Note that a maximum of 65535 elements are permitted in an array-typed element
value.
values
Each value of valuesthe  table gives the value of an element of the
array-typed value represented by this element_value structure.
4.7.17The RuntimeInvisibleAnnotations attribute
The RuntimeInvisibleAnnotations attribute is similar to the
RuntimeVisibleAnnotations attribute, except that the annotations represented
by a RuntimeInvisibleAnnotations attribute must not be made available for
return by reflective APIs, unless the Java virtual machine has been instructed to
retain these annotations via some implementation-specific mechanism such as a
command line flag. In the absence of such instructions, the Java virtual machine
ignores this attribute.
The RuntimeInvisibleAnnotations attribute is a variable-length attribute in the
attributes table of ClassFilea  4.1( ), field_info (4.5) or method_info
(4.6) structure. RuntimeInvisibleAnnotationsThe  attribute records runtime-
invisible Java programming language annotations on the corresponding class,
method, or field.
Each ClassFile, field_info, and method_info structure may contain at most one
RuntimeInvisibleAnnotations attribute, which records all the runtime-invisible
Java programming language annotations on the corresponding program element.
The RuntimeInvisibleAnnotations attribute has the following format:
RuntimeInvisibleAnnotations_attribute {
    u2         attribute_name_index;
    u4         attribute_length;
    u2         num_annotations;
    annotation annotations[num_annotations];
}
The items of RuntimeInvisibleAnnotations_attributethe  structure are as
follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"RuntimeInvisibleAnnotations".
134
--------------------------------------- 153
THE CLASS FILE FORMATThe RuntimeVisibleParameterAnnotations attribute4.7.18
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the number of
runtime-invisible annotations represented by the structure, and their values.
num_annotations
The value of num_annotationsthe  item gives the number of runtime-invisible
annotations represented by the structure.
Note that a maximum of 65535 runtime-invisible Java programming language annotations
may be directly attached to a program element.
annotations
Each value of annotationsthe  table represents a single runtime-invisible
annotation on a program element.
4.7.18The RuntimeVisibleParameterAnnotations attribute
The RuntimeVisibleParameterAnnotations attribute is a variable-length
attribute in attributesthe  table of method_infothe  (4.6) structure. The
RuntimeVisibleParameterAnnotations attribute records runtime-visible Java
programming language annotations on the parameters of the corresponding
method.
Each method_info structure may contain at most one
RuntimeVisibleParameterAnnotations attribute, which records all the runtime-
visible Java programming language annotations on the parameters of the
corresponding method. The Java virtual machine must make these annotations
available so they can be returned by the appropriate reflective APIs.
The RuntimeVisibleParameterAnnotations attribute has the following format:
RuntimeVisibleParameterAnnotations_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 num_parameters;
    {   u2         num_annotations;
        annotation annotations[num_annotations];
    } parameter_annotations[num_parameters];
}
The items of RuntimeVisibleParameterAnnotations_attributethe  structure
are as follows:
135
--------------------------------------- 154
4.7.19 The RuntimeInvisibleParameterAnnotations attributeTHE CLASS FILE FORMAT
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"RuntimeVisibleParameterAnnotations".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the number of
parameters, the number of runtime-visible annotations on each parameter, and
their values.
num_parameters
The value of num_parametersthe  item gives the number of parameters of
the method represented method_infoby the  structure on which the annotation
occurs. (This duplicates information that could be extracted from the method
descriptor (4.3.3).)
parameter_annotations
Each value of parameter_annotationsthe  table represents all of the runtime-
visible annotations on a single parameter. The sequence of values in the table
corresponds to the sequence of parameters in the method descriptor. Each
parameter_annotations entry contains the following two items:
num_annotations
The value of num_annotationsthe  item indicates the number of runtime-
visible annotations on the parameter corresponding to the sequence number
of this parameter_annotations element.
annotations
Each value of annotationsthe  table represents a single runtime-visible
annotation on the parameter corresponding to the sequence number of this
parameter_annotations element.
4.7.19The RuntimeInvisibleParameterAnnotations attribute
The RuntimeInvisibleParameterAnnotations attribute is similar to the
RuntimeVisibleParameterAnnotations attribute, except that the annotations
represented RuntimeInvisibleParameterAnnotationsby a  attribute must not be
made available for return by reflective APIs, unless the Java virtual machine has
specifically been instructed to retain these annotations via some implementation-
136
--------------------------------------- 155
THE CLASS FILE FORMATThe RuntimeInvisibleParameterAnnotations attribute4.7.19
specific mechanism such as a command line flag. In the absence of such
instructions, the Java virtual machine ignores this attribute.
The RuntimeInvisibleParameterAnnotations attribute is a variable-length
attribute in attributesthe  table of method_infoa  4.6( ) structure. The
RuntimeInvisibleParameterAnnotations attribute records runtime-invisible
Java programming language annotations on the parameters of the corresponding
method.
Each method_info structure may contain at most one
RuntimeInvisibleParameterAnnotations attribute, which records all the
runtime-invisible Java programming language annotations on the parameters of the
corresponding method.
The RuntimeInvisibleParameterAnnotations attribute has the following
format:
RuntimeInvisibleParameterAnnotations_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 num_parameters;
    {   u2         num_annotations;
        annotation annotations[num_annotations];
    } parameter_annotations[num_parameters];
}
The items of RuntimeInvisibleParameterAnnotations_attributethe  structure
are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"RuntimeInvisibleParameterAnnotations".
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the number of
parameters, the number of runtime-invisible annotations on each parameter,
and their values.
num_parameters
The value of num_parametersthe  item gives the number of parameters of
the method represented method_infoby the  structure on which the annotation
137
--------------------------------------- 156
4.7.20 The AnnotationDefault attributeTHE CLASS FILE FORMAT
occurs. (This duplicates information that could be extracted from the method
descriptor (4.3.3).)
parameter_annotations
Each value of parameter_annotationsthe  table represents all of the runtime-
invisible annotations on a single parameter. The sequence of values in the
table corresponds to the sequence of parameters in the method descriptor. Each
parameter_annotations entry contains the following two items:
num_annotations
The value of num_annotationsthe  item indicates the number of runtime-
invisible annotations on the parameter corresponding to the sequence
number of this parameter_annotations element.
annotations
Each value of annotationsthe  table represents a single runtime-invisible
annotation on the parameter corresponding to the sequence number of this
parameter_annotations element.
4.7.20The AnnotationDefault attribute
The AnnotationDefault attribute is a variable-length attributesattribute in the 
table of certain method_info 4.6( ) structures, namely those representing elements
of annotation types. AnnotationDefaultThe  attribute records the default value
for the element represented by the method_info structure.
Each method_info structure representing an element of an annotation type may
contain at most AnnotationDefaultone  attribute. The Java virtual machine must
make this default value available so it can be applied by appropriate reflective APIs.
The AnnotationDefault attribute has the following format:
AnnotationDefault_attribute {
    u2            attribute_name_index;
    u4            attribute_length;
    element_value default_value;
}
The items of the AnnotationDefault_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"AnnotationDefault".
138
--------------------------------------- 157
THE CLASS FILE FORMATThe BootstrapMethods attribute4.7.21
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the default
value.
default_value
The default_value item represents the default value of the annotation
type element whose default value is represented AnnotationDefaultby this 
attribute.
4.7.21The BootstrapMethods attribute
The BootstrapMethods attribute is a variable-length attributesattribute in the 
table of ClassFilea  (4.1) structure. BootstrapMethodsThe  attribute
records bootstrap method specifiers invokedynamicreferenced  instructionsby 
(invokedynamic).
There must be exactly BootstrapMethodsone  attribute attributesin the  table of
a given ClassFile structure constant_poolif the  table of ClassFilethe  structure
has at least CONSTANT_InvokeDynamic_infoone  entry 4.4.10( ). There can be no
more than one BootstrapMethods attribute attributesin the  table of a given
ClassFile structure.
The BootstrapMethods attribute has the following format:
BootstrapMethods_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 num_bootstrap_methods;
    {   u2 bootstrap_method_ref;
        u2 num_bootstrap_arguments;
        u2 bootstrap_arguments[num_bootstrap_arguments];
    } bootstrap_methods[num_bootstrap_methods];
}
The items of the BootstrapMethods_attribute structure are as follows:
attribute_name_index
The value of attribute_name_indexthe  item must be a valid index
into the constant_pool table. The constant_pool entry at that index
must be CONSTANT_Utf8_infoa  (4.4.7) structure representing the string
"BootstrapMethods".
139
--------------------------------------- 158
4.7.21 The BootstrapMethods attributeTHE CLASS FILE FORMAT
attribute_length
The value of attribute_lengththe  item indicates the length of the attribute,
excluding the initial six bytes.
The value of attribute_lengththe  item is thus dependent on the number of
invokedynamic instructions in this ClassFile structure.
num_bootstrap_methods
The value of num_bootstrap_methodsthe  item determines the number of
bootstrap method specifiers in the bootstrap_methods array.
bootstrap_methods[]
Each entry in bootstrap_methodsthe  array contains an index to a
CONSTANT_MethodHandle_info (4.4.8) structure which specifies a bootstrap
method, and a sequence (perhaps empty) static of indexes arguments for to the
bootstrap method.
Each bootstrap_methods entry must contain the following three items:
bootstrap_method_ref
The value of bootstrap_method_refthe  item must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must be
a CONSTANT_MethodHandle_info (4.4.8) structure.
Commentary: The reference_kind item of CONSTANT_MethodHandle_infothe 
structure should have the value REF_invokeStatic6 ( ) or 8
(REF_newInvokeSpecial) 5.4.3.5() or else invocation of the bootstrap method
handle during call site specifier invokedynamicresolution  instruction for an will
complete abruptly.
num_bootstrap_arguments
The value of num_bootstrap_argumentsthe  item gives the number of
items in the bootstrap_arguments array.
bootstrap_arguments
Each entry in bootstrap_argumentsthe  array must be a valid index into
the constant_pool table. constant_poolThe  entry at that index must
be a CONSTANT_String_info 4.4.3(), CONSTANT_Class_info (4.4.1),
CONSTANT_Integer_info 4.4.4(), CONSTANT_Long_info (4.4.5),
CONSTANT_Float_info 4.4.4(), CONSTANT_Double_info (4.4.5),
CONSTANT_MethodHandle_info 4.4.8(), or CONSTANT_MethodType_info
(4.4.9) structure.
140
--------------------------------------- 159
THE CLASS FILE FORMATFormat Checking 4.8
4.8 Format Checking
When a prospective class file is loaded 5.3) by ( the Java virtual machine, the
Java virtual machine first ensures that the file classhas  filethe basic format of a 
(4.1). This process is format known as checking. The first four bytes must contain
the right magic number. All recognized attributes must be of the proper length. The
class file must not be truncated or have extra bytes at the end. The constant pool
must not contain any superficially unrecognizable information.
This check for classbasic  file integrity is necessary for any interpretation of the
class file contents.
Format checking is distinct from bytecode verification. Both are part of the
verification process. Historically, format checking has been confused with
bytecode verification, because both are a form of integrity check.
4.9 Constraints on Java virtual machine code
The Java virtual machine code for a method, instance 2.9initialization ),method (
or class or interface initialization 2.9) is stored method codein ( the array of the
Code attribute method_infoof a  structure classof  a file 4.7.3( ). This section
describes the constraints associated with Code_attributethe contents of the 
structure.
4.9.1Static Constraints
The static constraints on classa  file are those defining the well-formedness of
the file. With the exception of the static constraints on the Java virtual machine
code of classthe  file, these constraints have been given in the previous sections.
The static constraints on the Java virtual classmachine  file specify code in howa 
Java virtual machine instructions must codebe  laid array out and in what the the
operands of individual instructions must be.
The static constraints on the instructions in the code array are as follows:
 The code array must not be empty, code_lengthso the  item cannot have the
value 0.
 The value of the code_length item must be less than 65536.
 The opcode of the first instruction in the code array begins at index 0.
141
--------------------------------------- 160
4.9.1 Static ConstraintsTHE CLASS FILE FORMAT
 Only instances of the instructions 6.5documented  may appear in in codethe 
array. Instances of instructions using the 6.2) reserved or any opcodesopcodes (
not documented in this specification must not appear in the code array.
 If the class file version number is 51.0 or above, jsr opcode then neither orthe 
the jsr_w opcode may appear in the code array.
 For each instruction codein  array the except the last, the index of the opcode of
the next instruction equals the index of the opcode of the current instruction plus
the length of that instruction, including all its operands.
The wide instruction is treated like any other instruction for these purposes; the
opcode specifying the operation wide instruction that a is to modify is treated as
one of the operands wideof  instruction. that That opcode must never be directly
reachable by the computation.
 The last byte of the last instruction code array in must the be the byte at index
code_length - 1.
The static constraints on the operands of codeinstructions  array are in as the 
follows:
 The target of each jump and branch jsr, instruction jsr_w, goto, goto_w( ,
ifeq, ifne, ifle, iflt, ifge, ifgt, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmple,
if_icmplt, if_icmpge, if_icmpgt, if_acmpeq, if_acmpne) must be the opcode of an
instruction within this method.
The target of a jump or branch instruction must never be the opcode used to
specify the operation to be modified wide instruction; by a a jump or branch
target may be the wide instruction itself.
 Each target, including the default, tableswitchof  instruction each must be the
opcode of an instruction within this method.
Each tableswitch instruction must have a number of entries in its jump table that
is consistent with the lowvalue  and highof  jump its table operands, lowand its 
value must be less than or equal to its high value.
No target of tableswitcha  instruction may be the opcode used to specify the
operation to be modified wide instruction; by a tableswitcha  target may be a
wide instruction itself.
 Each target, including the default, lookupswitchof  instruction each must be the
opcode of an instruction within this method.
142
--------------------------------------- 161
THE CLASS FILE FORMATStatic Constraints4.9.1
Each lookupswitch instruction must have a match-offsetnumber  of pairs that is
consistent with the value npairs of operand. its match-offsetThe  pairs must be
sorted in increasing numerical order by signed match value.
No target lookupswitchof a  instruction may be the opcode used to specify the
operation to be modified wide instruction; by a lookupswitcha  target may be a
wide instruction itself.
 The operand of ldceach  instruction and ldc_weach  instruction must be a valid
index into constant_poolthe  table. The constant pool entry referenced by that
index must be of type:
CONSTANT_Integer, CONSTANT_Float, or CONSTANT_String if the class file
version number is less than 49.0.
CONSTANT_Integer, CONSTANT_Float, CONSTANT_String, or
CONSTANT_Class if the class file version number is 49.0 or 50.0.
CONSTANT_Integer, CONSTANT_Float, CONSTANT_String, CONSTANT_Class,
CONSTANT_MethodType, or CONSTANT_MethodHandle if the class file version
number is 51.0.
 The operands of ldc2_weach  instruction must represent a valid index into the
constant_pool table. The constant pool entry referenced by that index must be
of type CONSTANT_Long or CONSTANT_Double.
In addition, the subsequent constant pool index must also be a valid index into
the constant pool, and the constant pool entry at that index must not be used.
 The operands of getfieldeach , putfield, getstatic, and putstatic instruction must
represent a valid index constant_poolinto the  table. The constant pool entry
referenced by that index must be of type CONSTANT_Fieldref.
 The indexbyte operands of invokevirtualeach , invokespecial, and invokestatic
instruction must represent a valid constant_poolindex into  table.the 
The constant pool entry referenced by that index must be of type
CONSTANT_Methodref.
 The indexbyte operands of invokedynamiceach  instruction must represent a valid
index into constant_poolthe  table. The constant pool entry referenced by that
index must be of type CONSTANT_InvokeDynamic.
The third and fourth operand invokedynamicbytes of each  instruction must have
the value zero.
 Only the invokespecial instruction is allowed to invoke an instance initialization
method (2.9).
143
--------------------------------------- 162
4.9.1 Static ConstraintsTHE CLASS FILE FORMAT
No other method whose name begins with <' the \u003c(' character ') may be'
called by the method invocation instructions. In particular, the class or interface
initialization method specially <clinit> named is never called explicitly from
Java virtual machine instructions, but only implicitly by the Java virtual machine
itself.
 The indexbyte operands of invokeinterfaceeach  instruction must represent a
valid index into constant_poolthe  table. The constant pool entry referenced by
that index must be of type CONSTANT_InterfaceMethodref.
The value of countthe  operand of each invokeinterface instruction
must reflect the number of local variables necessary to store the
arguments to be passed to the interface method, as implied by the
descriptor of CONSTANT_NameAndType_infothe  structure referenced by the
CONSTANT_InterfaceMethodref constant pool entry.
The fourth operand byte invokeinterfaceof each  instruction must have the value
zero.
 The operands of instanceofeach , checkcast, new, and anewarray instruction and
the indexbyte operands of multianewarrayeach  instruction must represent a valid
index into constant_poolthe  table. The constant pool entry referenced by that
index must be of type CONSTANT_Class.
 No anewarray instruction may be used to create an array of more than 255
dimensions.
 No new instruction may reference CONSTANT_Classa  constant_pool table entry
representing an array newclass.  instruction The cannot be used to create an array.
 A multianewarray instruction must be used only to create an array of a type that
has at least as many dimensions as dimensionsthe value  operand. of its That is,
while multianewarraya  instruction is not required to create all of the dimensions
of the array type referenced indexbyteby  operands, its it must not attempt to
create more dimensions than are in the array type.
The dimensions operand of each multianewarray instruction must not be zero.
 The atype operand of newarrayeach  instruction must take one of the values
T_BOOLEAN (4), T_CHAR (5), T_FLOAT (6), T_DOUBLE (7), T_BYTE (8), T_SHORT (9),
T_INT (10), or T_LONG (11).
 The index operand of iloadeach , fload, aload, istore, fstore, astore, iinc, and ret
instruction must be a non-negative integer no greater than max_locals - 1.
144
--------------------------------------- 163
THE CLASS FILE FORMATStructural Constraints4.9.2
 The implicit index iload_<n>of each , fload_<n>, aload_<n>, istore_<n>,
fstore_<n>, and astore_<n> instruction must be no greater than the value of
max_locals - 1.
 The index operand of lloadeach , dload, lstore, and dstore instruction must be
no greater than the value of max_locals - 2.
 The implicit index lload_<n>of each , dload_<n>, lstore_<n>, and dstore_<n>
instruction must be no greater than the value of max_locals - 2.
 The indexbyte operands of wideeach  instruction modifying iload, floadan ,
aload, istore, fstore, astore, ret, or iinc instruction must represent a non-negative
integer no greater than max_locals - 1.
The indexbyte operands of wideeach  instruction modifying lload, dloadan ,
lstore, or dstore instruction must represent a non-negative integer no greater than
max_locals - 2.
4.9.2Structural Constraints
The structural constraints code array on the specify constraints on relationships
between Java virtual machine instructions. The structural constraints are as follows:
 Each instruction must only be executed with the appropriate type and number
of arguments in the operand stack and local variable array, regardless of the
execution path that leads to its invocation.
An instruction operating on values int is of also type permitted to operate on
values of booleantype , byte, char, and short. (As noted 2.3.4in  and 2.11.1,
the Java virtual machine internally converts booleanvalues , byte, charof , types 
and short to type int.)
 If an instruction can be executed along several different execution paths, the
operand stack must have the 2.6.2same ) depth prior (to the execution of the
instruction, regardless of the path taken.
 At no point during execution can the order of the local variable pair holding a
value of type long or double be reversed or the pair split up.
At no point can the local variables of such a pair be operated on individually.
 No local variable (or local variable pair, in the longcase  or of a value of type 
double) can be accessed before it is assigned a value.
 At no point during execution can the operand stack 2.6.2)grow to a depth (
greater than that implied by the max_stack item.
145
--------------------------------------- 164
4.9.2 Structural ConstraintsTHE CLASS FILE FORMAT
 At no point during execution can more values be popped from the operand stack
than it contains.
 Each invokespecial instruction must name an instance initialization method
(2.9), a method in the current class, or a method in a superclass of the current
class.
If an invokespecial instruction names an instance initialization method from a
class that is not the current class or a superclass, and the target reference on
the operand stack is a class instance created new instruction, by an earlier then
invokespecial must name an instance initialization method from the class of that
class instance.
 When the instance initialization 2.9) is method invoked, (an uninitialized class
instance must be in an appropriate position on the operand stack.
An instance initialization method must never be invoked on an initialized class
instance.
 When any instance method is invoked or when any instance variable is accessed,
the class instance that contains the instance method or instance variable must
already be initialized.
 There must never be an uninitialized class instance on the operand stack or in a
local variable at the target of a backwards branch unless the special type of the
uninitialized class instance at the branch instruction is merged with itself at the
target of the branch (4.10.2.4).
 There must never be an uninitialized class instance in a local variable in code
protected by an exception handler (4.10.2.4).
 There must never be an uninitialized class instance on the operand stack or in a
local variable when a jsr or jsr_w instruction is executed.
 Each instance initialization 2.9), method except ( for the instance initialization
method derived from the constructor Object, of must class call either another
instance initialization thismethod  or an of instance initialization method of its
direct superclass super before its instance members are accessed.
However, instance fields this that of are declared in the current class may be
assigned before calling any instance initialization method.
 The arguments to each method invocation must be method invocation compatible
(JLS 5.3) with the method descriptor (4.3.3).
146
--------------------------------------- 165
THE CLASS FILE FORMATStructural Constraints4.9.2
 The type of every class instance that is the target of a method invocation
instruction must be assignment compatible (JLS 5.2) with the class or interface
type specified in the instruction.
In addition, the type of the invokespecialtarget  of instruction an must be
assignment compatible with the current class, unless an instance initialization
method is being invoked.
 Each return instruction must match its method's return type:
If the method returns boolean, a byte, char, short, or int, only ireturnthe 
instruction may be used.
If the method returns float, longa , or double, only freturnan , lreturn, or
dreturn instruction, respectively, may be used.
If the method returns referencea  type, it must do so areturnusing an 
instruction, and the type of the returned value must be assignment compatible
(JLS 5.2) with the return descriptor (4.3.3) of the method.
All instance initialization methods, class or interface initialization methods,
and methods declared to return void must use only the return instruction.
 If getfield or putfield is used to access protecteda  field declared in a superclass
that is a member of a different runtime package than the current class, then the
type of the class instance being accessed must be the same as or a subclass of
the current class.
If invokevirtual or invokespecial is used to access protecteda  method declared
in a superclass that is a member of a different runtime package than the current
class, then the type of the class instance being accessed must be the same as or
a subclass of the current class.
 The type of every class instance getfieldaccessed  instruction by a or modified by
a putfield instruction must be assignment compatible (JLS 5.2) with the class
type specified in the instruction.
 The type of every value stored putfield or by putstatica  instruction must be
compatible with the descriptor 4.3.2of ) the of field the class (instance or class
being stored into:
If the descriptor booleantype , byteis , char, short, or int, then the value
must be an int.
If the descriptor floattype , longis , or double, then the value must float,be a 
long, or double, respectively.
147
--------------------------------------- 166
4.10Verification classof  FilesTHE CLASS FILE FORMAT
If the descriptor referencetype is  type, a then the value must be of a type that
is assignment compatible (JLS 5.2) with the descriptor type.
 The type of every value stored into aastorean  array instruction by an must be
a reference type.
The component type of the array being stored aastore instructioninto by the 
must also be a reference type.
 Each athrow instruction must throw only values that are instances of class
Throwable or of subclasses of Throwable.
Each class mentioned catch_typein a  item of a method's exception table must
be Throwable or a subclass of Throwable.
 Execution never falls off the bottom of the code array.
 No return address (a value returnAddressof type ) may be loaded from a local
variable.
 The instruction following jsr or jsr_weach  instruction may be returned to only
by a single ret instruction.
 No jsr or jsr_w instruction that is returned to may be used to recursively call
a subroutine if that subroutine is already present in the subroutine call chain.
(Subroutines can be nested trywhen -finallyusing  constructs from within a
finally clause.)
 Each instance of type returnAddress can be returned to at most once.
If reta  instruction returns to a point in the subroutine ret call chain above the 
instruction corresponding to a given returnAddressinstance of , then type that
instance can never be used as a return address.
4.10Verification of class Files
Even though any compiler for the Java programming language must only produce
class files that satisfy all the static and structural constraints in the previous
sections, the Java virtual machine has no guarantee that any file it is asked to load
was generated by that compiler or is properly formed. Applications such as web
browsers do not download source code, which they then compile; these applications
download already-compiled class files. The browser needs to determine whether
the class file was produced by a trustworthy compiler or by an adversary
attempting to exploit the Java virtual machine.
148
--------------------------------------- 167
THE CLASS FILE FORMATVerification classof  Files 4.10
An additional problem with compile-time checking is version skew. A user may
have successfully compiled a PurchaseStockOptionsclass, say , to be a subclass of
TradingClass. But the definition TradingClassof  might have changed since the time
the class was compiled in a way that is not compatible with pre-existing binaries. Methods
might have been deleted or had their return types or modifiers changed. Fields might have
changed types or changed from instance variables to class variables. The access modifiers of
a method or variable may have changed public to privatefrom . For a discussion of these
issues, see Chapter 13, "Binary Compatibility," The Java Language in Specification,
Java SE 7 Edition.
Because of these potential problems, the Java virtual machine needs to verify for
itself that the desired constraints classare  satisfied files it by attempts the to
incorporate. A Java virtual machine implementation classverifies  filethat each 
satisfies the necessary constraints at linking time (5.4).
Linking-time verification enhances the performance of the interpreter. Expensive
checks that would otherwise have to be performed to verify constraints at runtime
for each interpreted instruction can be eliminated. The Java virtual machine can
assume that these checks have already been performed. For example, the Java
virtual machine will already know the following:
 There are no operand stack overflows or underflows.
 All local variable uses and stores are valid.
 The arguments to all the Java virtual machine instructions are of valid types.
The verifier also performs verification that can be codedone without looking at the 
array of the Code attribute (4.7.3). The checks performed include the following:
 Ensuring that final classes are not subclassed final and methods that are not
overridden (5.4.5).
 Checking that every class (except Object) has a direct superclass.
 Ensuring that the constant pool satisfies the documented static constraints; for
example, that CONSTANT_Class_infoeach  structure in the constant pool contains
in its name_index item a valid constant pool CONSTANT_Utf8_infoindex for a 
structure.
 Checking that all field references and method references in the constant pool
have valid names, valid classes, and a valid type descriptor.
Note that these checks do not ensure that the given field or method actually exists
in the given class, nor do they check that the type descriptors given refer to real
classes. They ensure only that these items are well formed. More detailed checking
is performed when the bytecodes themselves are verified, and during resolution.
149
--------------------------------------- 168
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
There are two strategies that Java virtual machine implementations may use for
verification:
 Verification by type checking must be classused  files to verify whose version
number is greater than or equal to 50.0.
 Verification by type inference must be supported by all Java virtual machine
implementations, except those conforming to the Java ME CLDC and Java Card
profiles, in order to verify class files whose version number is less than 50.0.
Verification on Java virtual machine implementations supporting the Java ME
CLDC and Java Card profiles is governed by their respective specifications.
4.10.1Verification by Type Checking
A class file whose version number is greater than or equal to 50.0 must be verified
using the typechecking rules given in this section. class file'sIf, and only if, a 
version number equals 50.0, then if the typechecking fails, a Java virtual machine
implementation may choose to attempt to perform verification by type inference.
This is a pragmatic adjustment, designed to ease the transition to the new verification
discipline. Many tools that classmanipulate  files may alter the bytecodes of a method
in a manner that requires adjustment of the method's stack map frames. If a tool does
not make the necessary adjustments to the stack map frames, typechecking may fail even
though the bytecode is in principle valid (and would consequently verify under the old type
inference scheme). To allow implementors time to adapt their tools, Java virtual machine
implementations may fall back to the older verification discipline, but only for a limited
time.
In cases where typechecking fails but type inference is invoked and succeeds, a certain
performance penalty is expected. Such a penalty is unavoidable. It also should serve as a
signal to tool vendors that their output needs to be adjusted, and provides vendors with
additional incentive to make these adjustments.
In summary, failover to verification by type inference supports both the gradual addition
of stack map frames to the Java SE platform (if they classare  not file,present in a 50.0 
failover is allowed) and the gradual jsr and removal jsr_w instructions of the from the Java
SE platform (if they are present in a 50.0 class file, failover is allowed).
If a Java virtual machine implementation ever attempts to perform verification
by type inference on version 50.0 class files, it must do so in all cases where
verification by typechecking fails.
This means that a Java virtual machine implementation cannot choose to resort to type
inference in once case and not in another. classIt  must files either that do reject not verify
via typechecking, or else consistently failover to the type inferencing verifier whenever
typechecking fails.
150
--------------------------------------- 169
THE CLASS FILE FORMATVerification by Type Checking4.10.1
The type checker requires a list of stack map frames Codefor each method with a 
attribute. The type checker reads the stack map frames for each such method and
uses these maps to generate a proof of the type safety of the instructions in the
Code attribute. The list of stack map frames StackMapTableis given  (4.7.4by )the 
attribute of the Code attribute.
The intent is that a stack map frame must appear at the beginning of each basic block in
a method. The stack map frame specifies the verification type of each operand stack entry
and of each local variable at the start of each basic block.
The type rules that the typechecker enforces are specified by means of Prolog
clauses. English language text is used to describe the type rules in an informal way,
while the Prolog code provides a formal specification.
Iff the predicate classIsTypeSafe is not true, the type checker must throw the
exception VerifyError to indicate classthat  the file is malformed. Otherwise, the
class file has type checked successfully and bytecode verification has completed
successfully.
classIsTypeSafe(Class) :-
    classClassName(Class, Name), 
    classDefiningLoader(Class, L),
    superclassChain(Name, L, Chain),
    Chain \= [],
    classSuperClassName(Class, SuperclassName),
    loadedClass(SuperclassName, L, Superclass),
    classIsNotFinal(Superclass),  
    classMethods(Class, Methods), 
    checklist(methodIsTypeSafe(Class), Methods).
classIsTypeSafe(Class) :-
    classClassName(Class, 'java/lang/Object'),
    classDefiningLoader(Class, L),
    isBootstrapClassLoader(L),
    classMethods(Class, Methods), 
    checklist(methodIsTypeSafe(Class), Methods).
Thus, a class is type safe if all its methods are type safe, final and it does not subclass a 
class.
The predicate classIsTypeSafe assumes that Class is a Prolog term representing
a binary class that has been successfully parsed and loaded. This specification
does not mandate the precise structure of this term, but does require that certain
predicates classMethods(e.g., ) be defined upon it, as the specified section in called
Accessors.
151
--------------------------------------- 170
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
For example, we assume a classMethods(Class, predicate Methods) that, given a
term representing a class as described above as its first argument, binds its second argument
to a list comprising all the methods of the class, represented in a convenient form described
below.
We also require the existence of loadedClass(Name,a predicate 
InitiatingLoader, ClassDefinition) which asserts that there exists a class
named Name whose representation (in accordance with this specification) when
loaded by the class InitiatingLoaderloader  is ClassDefinition. Additional
required predicates are discussed in the section called Accessors.
Individual instructions are presented as terms whose functor is the name of the
instruction and whose arguments are its parsed operands.
For example, aloadan  instruction is represented aload(N)as the , which term includes the
index N that is the operand of the instruction.
A few instructions have operands that are constant pool entries representing
methods, dynamic call sites, and fields. A method is represented by
a CONSTANT_InterfaceMethodref_info (for an interface's method) or
CONSTANT_Methodref_info (for a class's method) structure in the constant pool.
A dynamic call site is represented CONSTANT_InvokeDynamic_infoby a  structure
in the constant pool.
Such structures are represented as functor applications of the form:
imethod(MethodIntfName, MethodName, MethodDescriptor) for
an interface's method, MethodIntfNamewhere  is the name of
the interface referenced class_indexby the  item of the
CONSTANT_InterfaceMethodref_info structure, MethodNameand  and
MethodDescriptor correspond to the name and type descriptor referenced by
the name_and_type_index item of CONSTANT_InterfaceMethodref_infothe 
structure;
method(MethodClassName, MethodName, MethodDescriptor) for a class's
method, where MethodClassName is the name of the class referenced by the
class_index item of CONSTANT_Methodref_infothe  structure, MethodNameand 
and MethodDescriptor correspond to the name and type descriptor referenced
by the name_and_type_index item of CONSTANT_Methodref_infothe  structure;
and
dmethod(CallSiteName, MethodDescriptor) for a dynamic call site,
where CallSiteName and MethodDescriptor correspond to the name
and type descriptor referenced name_and_type_indexby the  item of the
CONSTANT_InvokeDynamic_info structure.
152
--------------------------------------- 171
THE CLASS FILE FORMATVerification by Type Checking4.10.1
Similarly, fields are represented CONSTANT_Fieldref_infoby  structures in the
class file. These structures are represented here as functor applications of
the form field(FieldClassName, FieldName, FieldDescriptor) where
FieldClassName is the name of the class referenced class_indexby  item the in
the structure, FieldNameand  and FieldDescriptor correspond to the name and
type descriptor referenced by the name_and_type_index item of the structure.
For clarity, we assume that type descriptors are mapped into more readable names:
the leading L and trailing ; are dropped from class names, and the base type
characters used for primitive types are mapped to the names of those types.
So, getfielda  instruction whose operand was an index into the constant pool that refers
to a field foo of type F in class Bar would be represented getfield(field('Bar',as 
'foo', 'F')).
Constant pool entries that refer to constant CONSTANT_Stringvalues, , such as 
CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long, CONSTANT_Double, and
CONSTANT_Class, are encoded via the functors whose stringnames , int,are 
float, long, double, and classConstant respectively.
So an ldc instruction for loading the integer 91 would be encoded as ldc(int(91)).
The instructions as a whole are represented as a list of terms of the form
instruction(Offset, AnInstruction).
For example, instruction(21, aload(1)).
The order of instructions in this list must be the same as in the class file.
Stack map frames are represented as a list stackMap(Offset,of terms of the form 
TypeState) where Offset is an integer indicating the offset of the instruction the
frame map applies TypeStateto, and  is the expected incoming type state for that
instruction. The order of instructions in this list classmust be the same as in the 
file.
TypeState has the form frame(Locals, OperandStack, Flags).
Locals is a list of verification types, such that the Nth element of the list (with
0 based indexing) represents the type of local variable N. If any local variable in
Locals has the uninitializedThistype , Flags is [flagThisUninit], otherwise
it is an empty list.
OperandStack is a list of types, such that the first element represents the type of the
top of the operand stack, and the elements below the top follow in the appropriate
order.
153
--------------------------------------- 172
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
However, note again that types of size 2 are represented by two entries, with the
first entry being top and the second one being the type itself.
So, a stack with doublea , an int, and longa  would be represented [top, as double,
int, top, long].
Array types are represented by applying arrayOfthe  to functor an argument
denoting the component type of the array.
Other reference types are represented classusing . Hence the class(N, functor L)
represents the class whose binary name is N as loaded by the loader L.
Thus, L is an initiating loader of the class class(N, represented L). It may, by or may
not, be its defining loader.
The type uninitialized(offset) is represented by applying the functor
uninitialized to an argument representing the numerical value of the offset.
Other verification types are represented by Prolog atoms whose name denotes the
verification type in question.
So, the class Object would be represented class('java/lang/Object', as BL),
where BL is the bootstrap loader. int[]The  and types Object[] would be represented by
arrayOf(int) and arrayOf(class('java/lang/Object', BL)) respectively.
Flags is a list which may either be empty or have the single element
flagThisUninit.
This flag is used in constructors, to mark type states where initialization of this has not yet
been completed. In such type states, it is illegal to return from the method.
4.10.1.1The Type Hierarchy
The typechecker enforces a type system based upon a hierarchy of verification
types, illustrated below. Most verifier types have a direct correspondence with Java
virtual machine field type descriptors Table 4.2. as The given only in exceptions are
the field descriptors B, C, S and Z all of which correspond to the verifier type int.
154
--------------------------------------- 173
THE CLASS FILE FORMATVerification by Type Checking4.10.1
Verification types:
                             top
                 ____________/\____________
THE 
THE 
            oneWord                       twoWord
THE 
THE 
        int  float  reference        long        double
THE 
                    /       \____________
THE 
THE 
           uninitialized                Object
THE 
THE 
uninitializedThis  uninitialized(offset)     +----------------------+
                                             |                      |
                                             | Java class hierarchy |
                                             |                      |
                                             +----------------------+
                                                        |
                                                        |
                                                       null
4.10.1.2Subtyping Rules
Subtyping is reflexive.
155
--------------------------------------- 174
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
isAssignable(X, X).
isAssignable(oneWord, top).
isAssignable(twoWord, top).
isAssignable(int, X)    :- isAssignable(oneWord, X).
isAssignable(float, X)  :- isAssignable(oneWord, X).
isAssignable(long, X)   :- isAssignable(twoWord, X).
isAssignable(double, X) :- isAssignable(twoWord, X).
isAssignable(reference, X)   :- isAssignable(oneWord, X).
isAssignable(class(_, _), X) :- isAssignable(reference, X).
isAssignable(arrayOf(_), X)  :- isAssignable(reference, X).
isAssignable(uninitialized, X)     :- isAssignable(reference, X).
isAssignable(uninitializedThis, X) :- isAssignable(uninitialized, X).
isAssignable(uninitialized(_), X)  :- isAssignable(uninitialized, X).
isAssignable(null, class(_, _)).
isAssignable(null, arrayOf(_)).
isAssignable(null, X) :- isAssignable(class('java/lang/Object', BL), X),
                         isBootstrapLoader(BL).
These subtype rules are not necessarily the most obvious formulation of subtyping. There is
a clear split between subtyping rules for reference types in the Java programming language,
and rules for the remaining verification types. The split allows us to state general subtyping
relations between Java programming language types and other verification types. These
relations hold independently of a Java type's position in the class hierarchy, and help to
prevent excessive class loading in a Java virtual machine implementation. For example, we
do not want to start climbing up the Java class hierarchy in response to a query of the form
class(foo,L) <: twoWord.
Subtype rules for the reference types in the Java programming language are specified
recursively in the obvious isJavaAssignableway with . The remaining verification types
have subtype rules of the form:
isAssignable(v, X) :- isAssignable(the_direct_supertype_of_v, X).
That is, v is a subtype of X if the direct supertype of v is a subtype of X.
We also have a rule that says subtyping is reflexive, so together these rules cover most
verification types that are not reference types in the Java programming language.
156
--------------------------------------- 175
THE CLASS FILE FORMATVerification by Type Checking4.10.1
isAssignable(class(X, Lx), class(Y, Ly)) :-
    isJavaAssignable(class(X, Lx), class(Y, Ly)).
isAssignable(arrayOf(X), class(Y, L)) :-
    isJavaAssignable(arrayOf(X), class(Y, L)).
isAssignable(arrayOf(X), arrayOf(Y)) :-
    isJavaAssignable(arrayOf(X), arrayOf(Y)).
For assignments, interfaces are treated like Object.
isJavaAssignable(class(_, _), class(To, L)) :-
    loadedClass(To, L, ToClass),
    classIsInterface(ToClass).
isJavaAssignable(From, To) :-
    isJavaSubclassOf(From, To).
Arrays are subtypes of Object.
isJavaAssignable(arrayOf(_), class('java/lang/Object', BL)) :-
    isBootstrapLoader(BL).
The intent here is that array types are Cloneablesubtypes  and of 
java.io.Serializable.
isJavaAssignable(arrayOf(_), X) :-
    isArrayInterface(X).
Subtyping between arrays of primitive type is the identity relation.
isJavaAssignable(arrayOf(X), arrayOf(Y)) :-
    atom(X),
    atom(Y),
    X = Y.
Subtyping between arrays of reference type is covariant.
157
--------------------------------------- 176
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
isJavaAssignable(arrayOf(X), arrayOf(Y)) :-
    compound(X), compound(Y), isJavaAssignable(X, Y).
isArrayInterface(class('java/lang/Cloneable', BL)) :-
    isBootstrapLoader(BL).
isArrayInterface(class('java/io/Serializable', BL)) :-
    isBootstrapLoader(BL).
Subclassing is reflexive.
isJavaSubclassOf(class(SubclassName, L), class(SubclassName, L)).
isJavaSubclassOf(class(SubclassName, LSub), class(SuperclassName, LSuper)) :-
    superclassChain(SubclassName, LSub, Chain),
    member(class(SuperclassName, L), Chain),
    loadedClass(SuperclassName, L, Sup),
    loadedClass(SuperclassName, LSuper, Sup).
superclassChain(ClassName, L, [class(SuperclassName, Ls) | Rest]) :-
    loadedClass(ClassName, L, Class),
    classSuperClassName(Class, SuperclassName),
    classDefiningLoader(Class, Ls),
    superclassChain(SuperclassName, Ls, Rest).
superclassChain('java/lang/Object', L, []) :-
    loadedClass('java/lang/Object', L, Class),
    classDefiningLoader(Class, BL),
    isBootstrapLoader(BL).
Subtyping is extended pointwise to type states.
The local variable array of a method has a fixed length by construction (in
methodInitialStackFrame) while the operand stack grows and shrinks. Therefore, we
require an explicit check on the length of the operand stacks whose assignability is desired.
frameIsAssignable(frame(Locals1, StackMap1, Flags1),
                  frame(Locals2, StackMap2, Flags2)) :-
    length(StackMap1, StackMapLength),
    length(StackMap2, StackMapLength),
    maplist(isAssignable, Locals1, Locals2),
    maplist(isAssignable, StackMap1, StackMap2),
    subset(Flags1, Flags2).
158
--------------------------------------- 177
THE CLASS FILE FORMATVerification by Type Checking4.10.1
4.10.1.3Typechecking Rules
4.10.1.3.1Accessors
Stipulated Accessors: Throughout this specification, we assume the existence
of certain Prolog predicates whose formal definitions are not given in the
specification. We list these predicates and describe their expected behavior below.
The principle guiding the determination as to which accessors are fully specified and which
are stipulated is that we do not want to over-specify classthe  file.representation of the 
Providing specific accessors to the class or method term would force us to completely
specify a format for the Prolog term representing the class file.
parseFieldDescriptor(Descriptor, Type)
Converts a field descriptor, Descriptor, into the corresponding verification
type Type (see the beginning 4.10.1.1of  for the specification of this
correspondence).
parseMethodDescriptor(Descriptor, ArgTypeList, ReturnType)
Converts a method descriptor, Descriptor, into a list of verification types,
ArgTypeList, corresponding 4.10.1.1() to the method argument types, and a
verification type, ReturnType, corresponding to the return type.
parseCodeAttribute(Class, Method, FrameSize, MaxStack, ParsedCode,
Handlers, StackMap)
Extracts the instruction ParsedCodestream, , of the method Method in Class,
as well as the maximum operand MaxStackstack , size, the maximal number
of local variables, FrameSize, the exception handlers, Handlers, and the stack
map StackMap.
The representation of the instruction stream and stack map attribute must be as
specified in the beginning of 4.10.1.
Each exception handler is represented by a functor application of the
form handler(Start, End, Target, ClassName) whose arguments are,
respectively, the start and end of the range of instructions covered by the
handler, the first instruction of the handler code, and the name of the exception
class that this handler is designed to handle.
classClassName(Class, ClassName)
Extracts the name, ClassName, of the class Class.
classIsInterface(Class)
True iff the class, Class, is an interface.
159
--------------------------------------- 178
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
classIsNotFinal(Class)
True iff the class, Class, is not a final class.
classSuperClassName(Class, SuperClassName)
Extracts the name, SuperClassName, of the superclass of class Class.
classInterfaces(Class, Interfaces)
Extracts a list, Interfaces, of the direct superinterfaces of the class Class.
classMethods(Class, Methods)
Extracts a list, Methods, of the methods declared in the class Class.
classAttributes(Class, Attributes)
Extracts a list, Attributes, of the attributes of the class Class.
Each attribute is represented as a functor application of the form
attribute(AttributeName, AttributeContents), where AttributeName
is the name of the attribute. The format of the attributes contents is unspecified.
classDefiningLoader(Class, Loader)
Extracts the defining class loader, Loader, of the class Class.
isBootstrapLoader(Loader)
True iff the class loader Loader is the bootstrap class loader.
methodName(Method, Name)
Extracts the name, Name, of the method Method.
methodAccessFlags(Method, AccessFlags)
Extracts the access flags, AccessFlags, of the method Method.
methodDescriptor(Method, Descriptor)
Extracts the descriptor, Descriptor, of the method Method.
methodAttributes(Method, Attributes)
Extracts a list, Attributes, of the attributes of the method Method.
isNotFinal(Method, Class)
True iff Method in class Class is not final.
isProtected(MemberClass, MemberName, MemberDescriptor)
True iff there is a member MemberNamenamed  with descriptor
MemberDescriptor in the class MemberClass and it is protected.
160
--------------------------------------- 179
THE CLASS FILE FORMATVerification by Type Checking4.10.1
isNotProtected(MemberClass, MemberName, MemberDescriptor)
True iff there is a member MemberNamenamed  with descriptor
MemberDescriptor in the class MemberClass and it is not protected.
samePackageName(Class1, Class2)
True iff the package names of Class1 and Class2 are the same.
differentPackageName(Class1, Class2)
True iff the package names of Class1 and Class2 are different.
Specified Accessors and : We Utilitiesdefine accessor and utility rules that extract
necessary information from the representation of the class and its methods.
An environment is a six-tuple consisting of:
 a class
 a method
 the declared return type of the method
 the instructions in a method
 the maximal size of the operand stack
 a list of exception handlers
161
--------------------------------------- 180
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
maxOperandStackLength(Environment, MaxStack) :-
    Environment = environment(_Class, _Method, _ReturnType,
                              _Instructions, MaxStack, _Handlers).
exceptionHandlers(Environment, Handlers) :-
    Environment = environment(_Class, _Method, _ReturnType,
                              _Instructions, _, Handlers).
thisMethodReturnType(Environment, ReturnType) :-
    Environment = environment(_Class, _Method, ReturnType,
                              _Instructions, _, _).
thisClass(Environment, class(ClassName, L)) :-
    Environment = environment(Class, _Method, _ReturnType,
                              _Instructions, _, _),
    classDefiningLoader(Class, L),
    classClassName(Class, ClassName).
allInstructions(Environment, Instructions) :-
    Environment = environment(_Class, _Method, _ReturnType,
                              Instructions, _, _).
offsetStackFrame(Environment, Offset, StackFrame) :-
    allInstructions(Environment, Instructions),
    member(stackMap(Offset, StackFrame), Instructions).
currentClassLoader(Environment, Loader) :-
    thisClass(Environment, class(_, Loader)).
notMember(_, []).
notMember(X, [A | More]) :- X \= A, notMember(X, More).
sameRuntimePackage(Class1, Class2) :-
    classDefiningLoader(Class1, L),
    classDefiningLoader(Class2, L),
    samePackageName(Class1, Class2).
differentRuntimePackage(Class1, Class2) :-
    classDefiningLoader(Class1, L1),
    classDefiningLoader(Class2, L2),
    L1 \= L2.
differentRuntimePackage(Class1, Class2) :-
    differentPackageName(Class1, Class2).
162
--------------------------------------- 181
THE CLASS FILE FORMATVerification by Type Checking4.10.1
4.10.1.3.2Abstract and Native Methods
Abstract methods and native methods are considered to be type safe if they do not override
a final method.
methodIsTypeSafe(Class, Method) :-
    doesNotOverrideFinalMethod(Class, Method),
    methodAccessFlags(Method, AccessFlags),
    member(abstract, AccessFlags).
methodIsTypeSafe(Class, Method) :-
    doesNotOverrideFinalMethod(Class, Method),
    methodAccessFlags(Method, AccessFlags),
    member(native, AccessFlags).
doesNotOverrideFinalMethod(class('java/lang/Object', L), Method) :-
    isBootstrapLoader(L).
doesNotOverrideFinalMethod(Class, Method) :-
    classSuperClassName(Class, SuperclassName),
    classDefiningLoader(Class, L),
    loadedClass(SuperclassName, L, Superclass),
    classMethods(Superclass, MethodList),
    finalMethodNotOverridden(Method, Superclass, MethodList).
finalMethodNotOverridden(Method, Superclass, MethodList) :-
    methodName(Method, Name),
    methodDescriptor(Method, Descriptor),
    member(method(_, Name, Descriptor), MethodList),
    isNotFinal(Method, Superclass).
finalMethodNotOverridden(Method, Superclass, MethodList) :-
    methodName(Method, Name),
    methodDescriptor(Method, Descriptor),
    notMember(method(_, Name, Descriptor), MethodList),
    doesNotOverrideFinalMethod(Superclass, Method).
4.10.1.3.3Checking Code
Non-abstract, non-native methods are type correct if they have code and the code is type
correct.
163
--------------------------------------- 182
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
methodIsTypeSafe(Class, Method) :-
    doesNotOverrideFinalMethod(Class, Method),
    methodAccessFlags(Method, AccessFlags),
    methodAttributes(Method, Attributes),
    notMember(native, AccessFlags),
    notMember(abstract, AccessFlags),
    member(attribute('Code', _), Attributes),
    methodWithCodeIsTypeSafe(Class, Method).
A method with code is type safe if it is possible to merge the code and the stack frames into
a single stream such that each stack map precedes the instruction it corresponds to, and the
merged stream is type correct.
methodWithCodeIsTypeSafe(Class, Method) :-
    parseCodeAttribute(Class, Method, FrameSize, MaxStack,
                       ParsedCode, Handlers, StackMap),
    mergeStackMapAndCode(StackMap, ParsedCode, MergedCode),
    methodInitialStackFrame(Class, Method, FrameSize, StackFrame, ReturnType),
    Environment = environment(Class, Method, ReturnType, MergedCode,
                              MaxStack, Handlers),
    handlersAreLegal(Environment),
    mergedCodeIsTypeSafe(Environment, MergedCode, StackFrame).
The initial type state of a method consists of an empty operand stack and local variable
types derived from the thistype  and of the arguments, as well as the appropriate flag,
depending on whether this is an <init> method.
164
--------------------------------------- 183
THE CLASS FILE FORMATVerification by Type Checking4.10.1
methodInitialStackFrame(Class, Method, FrameSize, frame(Locals, [], Flags),
                        ReturnType):-
    methodDescriptor(Method, Descriptor),
    parseMethodDescriptor(Descriptor, RawArgs, ReturnType),
    expandTypeList(RawArgs, Args),
    methodInitialThisType(Class, Method, ThisList),
    flags(ThisList, Flags),
    append(ThisList, Args, ThisArgs),
    expandToLength(ThisArgs, FrameSize, top, Locals).
flags([uninitializedThis], [flagThisUninit]).
flags(X, []) :- X \= [uninitializedThis].
expandToLength(List, Size, _Filler, List) :- length(List, Size).
expandToLength(List, Size, Filler, Result) :-
    length(List, ListLength),
    ListLength < Size,
    Delta is Size - ListLength,
    length(Extra, Delta),
    checklist(=(Filler), Extra),
    append(List, Extra, Result).
For a static method, this is irrelevant; the list is empty. For an instance method, we get
the type of this and put it in a list.
methodInitialThisType(_Class, Method, []) :-
    methodAccessFlags(Method, AccessFlags),
    member(static, AccessFlags),
    methodName(Method, MethodName),
    MethodName \= '<init>'.
methodInitialThisType(Class, Method, [This]) :-
THE 
THE 
    instanceMethodInitialThisType(Class, Method, This).
In the <init> method Objectof , the type thisof  is Object. In other <init> methods,
the type thisof  is uninitializedThis. Otherwise, the thistype  in of an instance
method is class(N, L), where N is the name of the class containing L the method and 
is its defining class loader.
165
--------------------------------------- 184
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
instanceMethodInitialThisType(Class, Method, class('java/lang/Object', L)) :-
    methodName(Method, '<init>'), 
    classDefiningLoader(Class, L),
    isBootstrapLoader(L),
    classClassName(Class, 'java/lang/Object').
instanceMethodInitialThisType(Class, Method, uninitializedThis) :-
    methodName(Method, '<init>'), 
    classClassName(Class, ClassName),
    classDefiningLoader(Class, CurrentLoader),
    superclassChain(ClassName, CurrentLoader, Chain),
    Chain \= [].
instanceMethodInitialThisType(Class, Method, class(ClassName, L)) :-
    methodName(Method, MethodName),
    MethodName \= '<init>',
    classDefiningLoader(Class, L),
    classClassName(Class, ClassName).
Below are the rules for iterating through the code stream. The assumption is that the stream
is a well formed mixture of instructions and stack maps, such that the stack map for bytecode
index N appears just before Ninstruction . The rules for building this mixed stream are given
later, by the predicate mergeStackMapAndCode.
The special marker aftergoto is used to indicate an unconditional branch. If we have an
unconditional branch at the end of the code, stop.
mergedCodeIsTypeSafe(_Environment, [endOfCode(Offset)], afterGoto).
After an unconditional branch, if we have a stack map giving the type state for the following
instructions, we can proceed and typecheck them using the type state provided by the stack
map.
mergedCodeIsTypeSafe(Environment, [stackMap(Offset, MapFrame) | MoreCode],
                     afterGoto):-
    mergedCodeIsTypeSafe(Environment, MoreCode, MapFrame).
If we have a stack map and an incoming type state, the type state must be assignable to the
one in the stack map. We may then proceed to type check the rest of the stream with the
type state given in the stack map.
mergedCodeIsTypeSafe(Environment, [stackMap(Offset, MapFrame) | MoreCode],
                     frame(Locals, OperandStack, Flags)) :-
    frameIsAssignable(frame(Locals, OperandStack, Flags), MapFrame),
    mergedCodeIsTypeSafe(Environment, MoreCode, MapFrame).
166
--------------------------------------- 185
THE CLASS FILE FORMATVerification by Type Checking4.10.1
It is illegal to have code after an unconditional branch without a stack map frame being
provided for it.
mergedCodeIsTypeSafe(_Environment, [instruction(_, _) | _MoreCode],
                     afterGoto) :-
    write_ln('No stack frame after unconditional branch'),
    fail.
A merged code stream is type safe relative to Tan  if incoming it begins type with state an
instruction I that is type safe Trelative , and I satisfies to its exception handlers, and the
tail of the stream is type safe given the type state following that execution of I.
NextStackFrame indicates what falls through to the following instruction.
ExceptionStackFrame indicates what is passed to exception handlers.
mergedCodeIsTypeSafe(Environment, [instruction(Offset, Parse) | MoreCode],
                     frame(Locals, OperandStack, Flags)) :-
    instructionIsTypeSafe(Parse, Environment, Offset,
                          frame(Locals, OperandStack, Flags),
                          NextStackFrame, ExceptionStackFrame),
    instructionSatisfiesHandlers(Environment, Offset, ExceptionStackFrame),
    mergedCodeIsTypeSafe(Environment, MoreCode, NextStackFrame).
Branching to a target is type safe if the target has Framean , associated andstack frame, 
the current stack frame, StackFrame, is assignable to Frame.
targetIsTypeSafe(Environment, StackFrame, Target) :-
    offsetStackFrame(Environment, Target, Frame),
    frameIsAssignable(StackFrame, Frame).
4.10.1.3.4Combining Streams of Stack Maps and Instructions
Merging an empty StackMap and a list of instructions yields the original list of instructions.
mergeStackMapAndCode([], CodeList, CodeList).
Given a list of stack map frames beginning with the type Offsetstate , for the instruction at 
and a list of instructions Offsetbeginning , the merged at list is the head of the stack frame
list, followed by the head of the instruction list, followed by the merge of the tails of the
two lists.
mergeStackMapAndCode([stackMap(Offset, Map) | RestMap],
                     [instruction(Offset, Parse) | RestCode],
                     [stackMap(Offset, Map),
                       instruction(Offset, Parse) | RestMerge]) :-
    mergeStackMapAndCode(RestMap, RestCode, RestMerge).
167
--------------------------------------- 186
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
Otherwise, given a list of stack frames beginning with the type state for the instruction at
OffsetM, and a list of instructions OffsetPbeginning , then, OffsetP at if < OffsetM,
the merged list consists of the head of the instruction list, followed by the merge of the
stack frame list and the tail of the instruction list.
mergeStackMapAndCode([stackMap(OffsetM, Map) | RestMap],
                     [instruction(OffsetP, Parse) | RestCode],
                     [instruction(OffsetP, Parse) | RestMerge]) :-
    OffsetP < OffsetM,
    mergeStackMapAndCode([stackMap(OffsetM, Map) | RestMap], RestCode, RestMerge).
Otherwise, the merge of the two lists is undefined. Since the instruction list has
monotonically increasing offsets, the merge of the two lists is not defined unless every stack
map frame offset has a corresponding instruction offset and the stack map frames are in
monotonically increasing order.
4.10.1.3.5Exception Handling
An instruction satisfies its exception  if handlersit satisfies every exception handler that is
applicable to the instruction.
instructionSatisfiesHandlers(Environment, Offset, ExceptionStackFrame) :-
    exceptionHandlers(Environment, Handlers),
    sublist(isApplicableHandler(Offset), Handlers, ApplicableHandlers),
    checklist(instructionSatisfiesHandler(Environment, ExceptionStackFrame),
              ApplicableHandlers).
An exception handler applicableis  to an instruction if the offset of the instruction is greater
or equal to the start of the handler's range and less than the end of the handler's range.
isApplicableHandler(Offset, handler(Start, End, _Target, _ClassName)) :-
    Offset >= Start,
    Offset < End.
An instruction satisfies an exception handler if its incoming StackFrametype ,state is 
and the handler's target (the initial instruction of the handler code) is type safe assuming
an incoming type T. state The type Tstate  is derived StackFramefrom  by replacing the
operand stack with a stack whose sole element is the handler's exception class.
168
--------------------------------------- 187
THE CLASS FILE FORMATVerification by Type Checking4.10.1
instructionSatisfiesHandler(Environment, StackFrame, Handler) :-
    Handler = handler(_, _, Target, _),
    currentClassLoader(Environment, CurrentLoader),
    handlerExceptionClass(Handler, ExceptionClass, CurrentLoader), 
    /* The stack consists of just the exception. */
    StackFrame = frame(Locals, _, Flags),
    ExcStackFrame = frame(Locals, [ ExceptionClass ], Flags),
    operandStackHasLegalLength(Environment, ExcStackFrame),
    targetIsTypeSafe(Environment, ExcStackFrame, Target).
The exception class of a Throwablehandler  if is the handlers class entry is 0, otherwise
it is the class named in the handler.
handlerExceptionClass(handler(_, _, _, 0), class('java/lang/Throwable', BL), _) :-
    isBootstrapLoader(BL).
handlerExceptionClass(handler(_, _, _, Name), class(Name, L), L) :-
    Name \= 0.
An exception handler is legal Startif ) its is less start than (Endits ), end there ( exists an
instruction whose offset Startis equal , there to exists an instruction whose offset equals
End, and the handler's exception class is assignable to the class Throwable.
handlersAreLegal(Environment) :-
    exceptionHandlers(Environment, Handlers),
    checklist(handlerIsLegal(Environment), Handlers).
handlerIsLegal(Environment, Handler) :-
    Handler = handler(Start, End, Target, _),
    Start < End,
    allInstructions(Environment, Instructions),
    member(instruction(Start, _), Instructions),
    offsetStackFrame(Environment, Target, _),
    instructionsIncludeEnd(Instructions, End),
    currentClassLoader(Environment, CurrentLoader),
    handlerExceptionClass(Handler, ExceptionClass, CurrentLoader), 
    isBootstrapLoader(BL),
    isAssignable(ExceptionClass, class('java/lang/Throwable', BL)).
instructionsIncludeEnd(Instructions, End) :-
    member(instruction(End, _), Instructions).
instructionsIncludeEnd(Instructions, End) :-
    member(endOfCode(End), Instructions).
169
--------------------------------------- 188
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
4.10.1.4Instructions
4.10.1.4.1Isomorphic Instructions
Many bytecodes have type rules that are completely isomorphic to the rules for other
bytecodes. If a bytecode b1 is isomorphic to another b2, bytecode then the type rule for
b1 is the same as the type rule for b2.
instructionIsTypeSafe(Instruction, Environment, Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    instructionHasEquivalentTypeRule(Instruction, IsomorphicInstruction),
    instructionIsTypeSafe(IsomorphicInstruction, Environment, Offset, StackFrame,
                          NextStackFrame, ExceptionStackFrame).
4.10.1.4.2Manipulating the Operand Stack
This section defines the rules for legally manipulating the type state's operand stack.
Manipulation of the operand stack is complicated by the fact that some types occupy two
entries on the stack. The predicates given in this section take this into account, allowing the
rest of the specification to abstract from this issue.
canPop(frame(Locals, OperandStack, Flags), Types,
       frame(Locals, PoppedOperandStack, Flags)) :-
    popMatchingList(OperandStack, Types, PoppedOperandStack).
popMatchingList(OperandStack, [], OperandStack).
popMatchingList(OperandStack, [P | Rest], NewOperandStack) :-
    popMatchingType(OperandStack, P, TempOperandStack, _ActualType),
    popMatchingList(TempOperandStack, Rest, NewOperandStack).
sizeOf(X, 2) :- isAssignable(X, twoWord).
sizeOf(X, 1) :- isAssignable(X, oneWord).
sizeOf(top, 1).
Pop an individual type off the stack. More precisely, if the logical top of the stack is some
subtype of the specified Type, type, then pop it. If a type occupies two stack slots, the
logical top of stack type is really the type just below the top, and the top of stack is the
unusable type top.
170
--------------------------------------- 189
THE CLASS FILE FORMATVerification by Type Checking4.10.1
popMatchingType([ActualType | OperandStack], Type, OperandStack, ActualType) :-
    sizeOf(Type, 1),
    isAssignable(ActualType, Type).
popMatchingType([top, ActualType | OperandStack], Type, OperandStack, ActualType) :-
    sizeOf(Type, 2),
    isAssignable(ActualType, Type).
Push a logical type onto the stack. The exact behavior varies with the size of the type. If
the pushed type is of size 1, we just push it onto the stack. If the pushed type is of size 2,
we push it, and then push top.
pushOperandStack(OperandStack, 'void', OperandStack).
pushOperandStack(OperandStack, Type, [Type | OperandStack]) :-
    sizeOf(Type, 1).
pushOperandStack(OperandStack, Type, [top, Type | OperandStack]) :-
    sizeOf(Type, 2).
The length of the operand stack must not exceed the declared maximum stack length.
operandStackHasLegalLength(Environment, OperandStack) :-
    length(OperandStack, Length),
    maxOperandStackLength(Environment, MaxStack),
    Length =< MaxStack.
Category 1 types occupy a single stack slot. Popping a Typelogical ,type of category 1, 
off the stack is possible if the Typetop  and of Typethe  is stack not top is (otherwise it
could denote the upper half of a category 2 type). The result is the incoming stack, with
the top slot popped off.
popCategory1([Type | Rest], Type, Rest) :-
    Type \= top,
    sizeOf(Type, 1).
Category 2 types occupy two stack slots. Popping a logical Type, offtype of category 2, 
the stack is possible if the top topof , the and stack the slot is type directly Typebelow .it is 
The result is the incoming stack, with the top 2 slots popped off.
171
--------------------------------------- 190
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
popCategory2([top, Type | Rest], Type, Rest) :-
    sizeOf(Type, 2).
canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack) :-
    pushOperandStack(InputOperandStack, Type, OutputOperandStack),
    operandStackHasLegalLength(Environment, OutputOperandStack).
canSafelyPushList(Environment, InputOperandStack, Types, OutputOperandStack) :-
    canPushList(InputOperandStack, Types, OutputOperandStack),
    operandStackHasLegalLength(Environment, OutputOperandStack).
canPushList(InputOperandStack, [Type | Rest], OutputOperandStack) :-
    pushOperandStack(InputOperandStack, Type, InterimOperandStack),
    canPushList(InterimOperandStack, Rest, OutputOperandStack).
canPushList(InputOperandStack, [], InputOperandStack).
4.10.1.4.3Loads
All load instructions are variations on a common pattern, varying the type of the value that
the instruction loads.
Loading a value of Typetype  from local variable Index is type safe, if the type of
that local variable ActualTypeis , ActualType is assignable Type, to and pushing
ActualType onto the incoming operand stack is a valid type transition that yields a new
type state NextStackFrame. After execution of the load instruction, the type state will be
NextStackFrame.
loadIsTypeSafe(Environment, Index, Type, StackFrame, NextStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, _Flags),
    nth0(Index, Locals, ActualType),
    isAssignable(ActualType, Type),
    validTypeTransition(Environment, [], ActualType, StackFrame, NextStackFrame).
4.10.1.4.4Stores
All store instructions are variations on a common pattern, varying the type of the value that
the instruction stores.
In general, a store instruction is type safe if the local variable it references is of a type that
is a supertype Typeof , and the top of the operand stack Typeis of , wherea subtype of 
Type is the type the instruction is designed to store.
More precisely, the store is type safe if ActualTypeone can  that pop a "matches"type 
Type (i.e., is a subtype Type) off of the operand stack, and then legally assign that type
the local variable LIndex.
172
--------------------------------------- 191
THE CLASS FILE FORMATVerification by Type Checking4.10.1
storeIsTypeSafe(_Environment, Index, Type,
                frame(Locals, OperandStack, Flags),
                frame(NextLocals, NextOperandStack, Flags)) :-
    popMatchingType(OperandStack, Type, NextOperandStack, ActualType),
    modifyLocalVariable(Index, ActualType, Locals, NextLocals).
Given local variables Locals, modifying Index to have type Type results in the local
variable NewLocalslist . The modifications are somewhat involved, because some values
(and their corresponding types) occupy two local variables. LN may Hence, modifying 
require modifying LN+1 (because the type will occupy N and both N+1 slots) the LN-1or 
(because local N used to be the upper half of the two word value/type N-1,starting at local 
and so local N-1 must be invalidated), or both. This is described further below. We start
at L0 and count up.
modifyLocalVariable(Index, Type, Locals, NewLocals) :-
    modifyLocalVariable(0, Index, Type, Locals, NewLocals).
Given LocalsRest, the suffix of the local variable Ilist , modifying starting localat index 
variable Index to have Typetype  results in the local variable NewLocalsRestlist suffix .
If I < Index-1, just copy the input to the output and I = recurse Index-1,forward. If 
the type of Ilocal  may change. This can LIoccur  has a if type of size 2. LOnce I+1we set 
to the new type (and the corresponding value), LI will the be type/value invalidated, of as
its upper half will be trashed. Then we recurse forward.
When we find the variable, and it only occupies one Typeword,  and we we'rechange it to 
done.
When we find the variable, and it occupies two words, Typewe  and change the its type to 
next word to top.
173
--------------------------------------- 192
4.10.1 Verification by Type CheckingTHE CLASS FILE FORMAT
modifyLocalVariable(I, Index, Type,
                    [Locals1 | LocalsRest], [Locals1 | NextLocalsRest] ) :-
    I < Index - 1, 
    I1 is I + 1,
    modifyLocalVariable(I1, Index, Type, LocalsRest, NextLocalsRest).
modifyLocalVariable(I, Index, Type,
                    [Locals1 | LocalsRest], [NextLocals1 | NextLocalsRest] ) :-
    I =:= Index - 1,
    modifyPreIndexVariable(Locals1, NextLocals1),
    modifyLocalVariable(Index, Index, Type, LocalsRest, NextLocalsRest).
modifyLocalVariable(Index, Index, Type,
                    [_ | LocalsRest], [Type | LocalsRest]) :-
    sizeOf(Type, 1).
modifyLocalVariable(Index, Index, Type,
                    [_, _ | LocalsRest], [Type, top | LocalsRest]) :-
    sizeOf(Type, 2).
We refer to a local whose index immediately precedes a local whose type will be modified as
a pre-index variable. The future type of a pre-index InputTypevariable  is Resultof type .
If the type, Type, of the pre-index local is of size 1, it doesn't change. If the type of the pre-
index local, Type, is 2, we need to mark the lower half of its two word value as unusable,
by setting its type to top.
modifyPreIndexVariable(Type, Type) :- sizeOf(Type, 1).
modifyPreIndexVariable(Type, top) :- sizeOf(Type, 2).
Given a list of types, this clause produces a list where every type of size 2 has been
substituted by two entries: one for top itself, entry. The and result one then corresponds to
the representation of the list as 32-bit words in the Java virtual machine.
expandTypeList([], []).
expandTypeList([Item | List], [Item | Result]) :-
    sizeOf(Item, 1),
    expandTypeList(List, Result).
expandTypeList([Item | List], [Item, top | Result]) :-
    sizeOf(Item, 2),
    expandTypeList(List, Result).
174
--------------------------------------- 193
THE CLASS FILE FORMATVerification by Type Checking4.10.1
4.10.1.4.5List of all Instructions
In general, the type rule for an instruction is given relative to an environment
Environment that defines the class and method in which the instruction occurs, and
the offset Offset within the method at which the instruction occurs. The rule states
that if the incoming type state StackFrame fulfills certain requirements, then:
 The instruction is type safe.
 It is provable that the type state after the instruction completes normally has
a particular form given NextStackFrameby , and that the type state after the
instruction completes abruptly is given by ExceptionStackFrame.
The natural language description of the rule is intended to be readable, intuitive and
concise. As such, the description avoids repeating all the contextual assumptions
given above. In particular:
 We do not explicitly mention the environment.
 When we speak of the operand stack or local variables in the following, we are
referring to the operand stack and local variable components of a type state: either
the incoming type state or the outgoing one.
 The type state after the instruction completes abruptly is almost always identical
to the incoming type state. We only discuss the type state after the instruction
completes abruptly when that is not the case.
 We speak of popping and pushing types onto the operand stack. We do not
explicitly discuss issues of stack underflow or overflow, but assume that these
operations can be completed successfully. The formal rules for operand stack
manipulation ensure that the necessary checks are made.
 Similarly, the text discusses only the manipulation of logical types. In practice,
some types take more than one word. We abstract from these representation
details in our discussion, but the logical rules that manipulate data do not.
Any ambiguities can be resolved by referring to the formal Prolog rules.
175
--------------------------------------- 194
aaloadTHE CLASS FILE FORMAT
aaloadaaload
An aaload instruction is type safe iff one can validly intreplace  and antypes matching 
array type with component ComponentTypetype  where ComponentType is a subtype of
Object, with ComponentType yielding the outgoing type state.
instructionIsTypeSafe(aaload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    nth1OperandStackIs(2, StackFrame, ArrayType),
    arrayComponentType(ArrayType, ComponentType),
    isBootstrapLoader(BL),
    validTypeTransition(Environment,
                        [int, arrayOf(class('java/lang/Object', BL))],
                        ComponentType, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The component type of an X is array X. We of define the component nulltype  to be nullof .
arrayComponentType(arrayOf(X), X).
arrayComponentType(null, null).
176
--------------------------------------- 195
THE CLASS FILE FORMATaastore
aastoreaastore
An aastore instruction is type safe iff one can validly Objectpop , inttypes ,matching 
and an array of Object off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(aastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    isBootstrapLoader(BL),
    canPop(StackFrame,
           [class('java/lang/Object', BL),
            int,
            arrayOf(class('java/lang/Object', BL))],
           NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
177
--------------------------------------- 196
aconst_nullTHE CLASS FILE FORMAT
aconst_nullaconst_null
An aconst_null instruction is type safe if one can validly null onto push thethe type 
incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(aconst_null, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [], null, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
178
--------------------------------------- 197
THE CLASS FILE FORMATaload
aloadaload
An aload instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a load instruction Indexwith  and operand type reference is type
safe and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(aload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    loadIsTypeSafe(Environment, Index, reference, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
179
--------------------------------------- 198
aload_<n>THE CLASS FILE FORMAT
aload_<n>aload_<n>
The instructions aload_<n>, for d n0  d 3, are type safe iff the aloadequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(aload_0, aload(0)).
instructionHasEquivalentTypeRule(aload_1, aload(1)).
instructionHasEquivalentTypeRule(aload_2, aload(2)).
instructionHasEquivalentTypeRule(aload_3, aload(3)).
180
--------------------------------------- 199
THE CLASS FILE FORMATanewarray
anewarrayanewarray
An anewarray instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting either a class type or an array type, and one can legally replace a type matching
int on the incoming operand stack with an array with CP yielding component thetype 
outgoing type state.
instructionIsTypeSafe(anewarray(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    (CP = class(_, _) ; CP = arrayOf(_)),
    validTypeTransition(Environment, [int], arrayOf(CP),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
181
--------------------------------------- 200
areturnTHE CLASS FILE FORMAT
areturnareturn
An areturn instruction is type safe iff the enclosing method has a declared return type,
ReturnType, that is referencea  type, and one can validly pop a type matching
ReturnType off the incoming operand stack.
instructionIsTypeSafe(areturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, ReturnType),
    isAssignable(ReturnType, reference),
    canPop(StackFrame, [ReturnType], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
182
--------------------------------------- 201
THE CLASS FILE FORMATarraylength
arraylengtharraylength
An arraylength instruction is type safe iff one can validly replace an array type on the
incoming operand stack with the type int yielding the outgoing type state.
instructionIsTypeSafe(arraylength, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    nth1OperandStackIs(1, StackFrame, ArrayType),
    arrayComponentType(ArrayType, _),
    validTypeTransition(Environment, [top], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
183
--------------------------------------- 202
astoreTHE CLASS FILE FORMAT
astoreastore
An astore instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a store instruction Indexwith  and operand type reference is type
safe and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(astore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    storeIsTypeSafe(Environment, Index, reference, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
184
--------------------------------------- 203
THE CLASS FILE FORMATastore_<n>
astore_<n>astore_<n>
The instructions astore_<n>, for d n0  d 3, are type safe iff the astoreequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(astore_0, astore(0)).
instructionHasEquivalentTypeRule(astore_1, astore(1)).
instructionHasEquivalentTypeRule(astore_2, astore(2)).
instructionHasEquivalentTypeRule(astore_3, astore(3)).
185
--------------------------------------- 204
athrowTHE CLASS FILE FORMAT
athrowathrow
An athrow instruction is type safe iff the top of the operand stack matches Throwable.
instructionIsTypeSafe(athrow, _Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    isBootstrapLoader(BL),
    canPop(StackFrame, [class('java/lang/Throwable', BL)], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
186
--------------------------------------- 205
THE CLASS FILE FORMATbaload
baloadbaload
A baload instruction is type safe iff one can validly intreplace  and a smalltypes matching 
array type on the incoming operand stack with int yielding the outgoing type state.
An array type small is a array  typeif it is an bytearray , an of array booleanof , or a
subtype thereof (null).
instructionIsTypeSafe(baload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :
    nth1OperandStackIs(2, StackFrame, Array),
    isSmallArray(Array),
    validTypeTransition(Environment, [int, top], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
isSmallArray(arrayOf(byte)).
isSmallArray(arrayOf(boolean)).
isSmallArray(null).
187
--------------------------------------- 206
bastoreTHE CLASS FILE FORMAT
bastorebastore
A bastore instruction is type safe iff one can validly int, intpop  and types a matching 
small array type off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(bastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    nth1OperandStackIs(3, StackFrame, Array),
    isSmallArray(Array),
    canPop(StackFrame, [int, int, top], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
188
--------------------------------------- 207
THE CLASS FILE FORMATbipush
bipushbipush
A bipush instruction is type safe iff the equivalent sipush instruction is type safe.
instructionHasEquivalentTypeRule(bipush(Value), sipush(Value)).
189
--------------------------------------- 208
caloadTHE CLASS FILE FORMAT
caloadcaload
A caload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of char on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(caload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(char)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
190
--------------------------------------- 209
THE CLASS FILE FORMATcastore
castorecastore
A castore instruction is type safe iff one can validly int, intpop  and types arraymatching 
of char off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(castore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [int, int, arrayOf(char)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
191
--------------------------------------- 210
checkcastTHE CLASS FILE FORMAT
checkcastcheckcast
A checkcast instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting either a class or an array, and one can Objectvalidly  on replace top of the type 
the incoming operand stack with the type denoted by CP yielding the outgoing type state.
instructionIsTypeSafe(checkcast(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object', BL)], CP,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
192
--------------------------------------- 211
THE CLASS FILE FORMATd2f
d2fd2f
A d2f instruction is type safe if one doublecan  off validly the incoming pop operand stack
and replace it with float, yielding the outgoing type state.
instructionIsTypeSafe(d2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [double], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
193
--------------------------------------- 212
d2iTHE CLASS FILE FORMAT
d2id2i
A d2i instruction is type safe if one doublecan  off validly the incoming pop operand stack
and replace it with int, yielding the outgoing type state.
instructionIsTypeSafe(d2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
194
--------------------------------------- 213
THE CLASS FILE FORMATd2l
d2ld2l
A d2l instruction is type safe if one doublecan  off validly the incoming pop operand stack
and replace it with long, yielding the outgoing type state.
instructionIsTypeSafe(d2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [double], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
195
--------------------------------------- 214
daddTHE CLASS FILE FORMAT
dadddadd
A dadd instruction is type safe iff one can validly doublereplace  andtypes matching 
double on the incoming operand stack with double yielding the outgoing type state.
instructionIsTypeSafe(dadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double, double], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
196
--------------------------------------- 215
THE CLASS FILE FORMATdaload
daloaddaload
A daload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of double on the incoming operand stack with double yielding the outgoing type state.
instructionIsTypeSafe(daload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(double)], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
197
--------------------------------------- 216
dastoreTHE CLASS FILE FORMAT
dastoredastore
A dastore instruction is type safe iff one can validly doublepop , inttypes  and matching 
array of double off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(dastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [double, int, arrayOf(double)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
198
--------------------------------------- 217
THE CLASS FILE FORMATdcmp<op>
dcmp<op>dcmp<op>
A dcmpg instruction is type safe iff one can validly doublereplace  and types matching 
double on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(dcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [double, double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dcmpl instruction is type safe iff the equivalent dcmpg instruction is type safe.
instructionHasEquivalentTypeRule(dcmpl, dcmpg).
199
--------------------------------------- 218
dconst_<d>THE CLASS FILE FORMAT
dconst_<d>dconst_<d>
A dconst_0 instruction is type safe if one can validly double onto push thethe type 
incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(dconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [], double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dconst_1 instruction is type safe iff the equivalent dconst_0 instruction is type safe.
instructionHasEquivalentTypeRule(dconst_1, dconst_0).
200
--------------------------------------- 219
THE CLASS FILE FORMATddiv
ddivddiv
A ddiv instruction is type safe iff the equivalent dadd instruction is type safe.
instructionHasEquivalentTypeRule(ddiv, dadd).
201
--------------------------------------- 220
dloadTHE CLASS FILE FORMAT
dloaddload
A dload instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a load instruction Indexwith  and operand type double is type safe
and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(dload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    loadIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
202
--------------------------------------- 221
THE CLASS FILE FORMATdload_<n>
dload_<n>dload_<n>
The instructions dload_<n>, for d n0  d 3, are typesafe iff the dloadequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(dload_0, dload(0)).
instructionHasEquivalentTypeRule(dload_1, dload(1)).
instructionHasEquivalentTypeRule(dload_2, dload(2)).
instructionHasEquivalentTypeRule(dload_3, dload(3)).
203
--------------------------------------- 222
dmulTHE CLASS FILE FORMAT
dmuldmul
A dmul instruction is type safe iff the equivalent dadd instruction is type safe.
instructionHasEquivalentTypeRule(dmul, dadd).
204
--------------------------------------- 223
THE CLASS FILE FORMATdneg
dnegdneg
A dneg instruction is type safe iff there doubleis a  on type the matching incoming operand
stack. The dneg instruction does not alter the type state.
instructionIsTypeSafe(dneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [double], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
205
--------------------------------------- 224
dremTHE CLASS FILE FORMAT
dremdrem
A drem instruction is type safe iff the equivalent dadd instruction is type safe.
instructionHasEquivalentTypeRule(drem, dadd).
206
--------------------------------------- 225
THE CLASS FILE FORMATdreturn
dreturndreturn
A dreturn instruction is type safe if the enclosing method has a declared return type of
double, and one can validly pop a type doublematching  off the incoming operand stack.
instructionIsTypeSafe(dreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, double),
    canPop(StackFrame, [double], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
207
--------------------------------------- 226
dstoreTHE CLASS FILE FORMAT
dstoredstore
A dstore instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a store instruction Indexwith  and operand type double is type safe
and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(dstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    storeIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
208
--------------------------------------- 227
THE CLASS FILE FORMATdstore_<n>
dstore_<n>dstore_<n>
The instructions dstore_<n>, for d n0  d 3, are type safe iff the dstoreequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(dstore_0, dstore(0)).
instructionHasEquivalentTypeRule(dstore_1, dstore(1)).
instructionHasEquivalentTypeRule(dstore_2, dstore(2)).
instructionHasEquivalentTypeRule(dstore_3, dstore(3)).
209
--------------------------------------- 228
dsubTHE CLASS FILE FORMAT
dsubdsub
A dsub instruction is type safe iff the equivalent dadd instruction is type safe.
instructionHasEquivalentTypeRule(dsub, dadd).
210
--------------------------------------- 229
THE CLASS FILE FORMATdup
dupdup
A dup instruction is type safe iff one can validly Typereplace , with a category the1 type, 
types Type, Type, yielding the outgoing type state.
instructionIsTypeSafe(dup, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
211
--------------------------------------- 230
dup_x1THE CLASS FILE FORMAT
dup_x1dup_x1
A dup_x1 instruction is type safe iff one can validly replace Type1, two category 1 types, 
and Type2, on the incoming operand stack Type1with , Type2the types , Type1, yielding
the outgoing type state.
instructionIsTypeSafe(dup_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
212
--------------------------------------- 231
THE CLASS FILE FORMATdup_x2
dup_x2dup_x2
A dup_x2 instruction is type safe iff it is a type safe form of the dup_x2 instruction.
instructionIsTypeSafe(dup_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                             OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dup_x2 instruction a type is safe form dup_x2of the  instruction iff it is a type safe form
1 dup_x2 instruction or a type safe form 2 dup_x2 instruction.
dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
A dup_x2 instruction a type is safe form dup_x21  instruction iff one can validly replace
three category 1 Type1types, , Type2, Type3 on the incoming operand stack with the types
Type1, Type2, Type3, Type1, yielding the outgoing type state.
dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
A dup_x2 instruction a type is safe form dup_x22  instruction iff one can validly replace a
category 1 type, Type1, and a category Type22 type, , on the incoming operand stack with
the types Type1, Type2, Type1, yielding the outgoing type state.
dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
213
--------------------------------------- 232
dup2THE CLASS FILE FORMAT
dup2dup2
A dup2 instruction is type safe iff it is a type safe form of the dup2 instruction.
instructionIsTypeSafe(dup2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2SomeFormIsTypeSafe(Environment,InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dup2 instruction a type is safe form dup2of  instructionthe  iff it is a type safe form 1
dup2 instruction or a type safe form 2 dup2 instruction.
dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form1IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).
dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form2IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).
A dup2 instruction a type is safe form dup2 instruction1  iff one can validly replace two
category 1 types, Type1 and Type2 on the incoming operand stack with Type1,the types 
Type2, Type1, Type2, yielding the outgoing type state.
dup2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory1(InputOperandStack, Type1, TempStack),
    popCategory1(TempStack, Type2, _),
    canSafelyPushList(Environment, InputOperandStack, [Type1, Type2],
                      OutputOperandStack).
A dup2 instruction a type is safe form dup2 2 instruction iff one can validly replace a
category 2 type, Type on the incoming operand stack Typewith , Typethe , types yielding
the outgoing type state.
dup2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory2(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack).
214
--------------------------------------- 233
THE CLASS FILE FORMATdup2_x1
dup2_x1dup2_x1
A dup2_x1 instruction is type safe iff it is a type safe form of the dup2_x1 instruction.
instructionIsTypeSafe(dup2_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dup2_x1 instruction a type is safe form dup2_x1of the  instruction iff it is a type safe
form 1 dup2_x1 instruction or a type safe form 2 dup_x2 instruction.
dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
A dup2_x1 instruction a type is safe form dup2_x11  instruction iff one can validly replace
three category 1 Type1types, , Type2, Type3, on the incoming operand stack with the types
Type1, Type2, Type3, Type1, Type2, yielding the outgoing type state.
dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
A dup2_x1 instruction a type is safe form dup2_x12  instruction iff one can validly replace
a category 2 Type1type, , and a category Type21 type, , on the incoming operand stack
with the types Type1, Type2, Type1, yielding the outgoing type state.
dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
215
--------------------------------------- 234
dup2_x2THE CLASS FILE FORMAT
dup2_x2dup2_x2
A dup2_x2 instruction is type safe iff it is a type safe form of the dup2_x2 instruction.
instructionIsTypeSafe(dup2_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A dup2_x2 instruction a type is safe form dup2_x2of the  instruction iff one of the following
holds:
 it is a type safe form 1 dup2_x2 instruction.
 it is a type safe form 2 dup2_x2 instruction.
 it is a type safe form 3 dup2_x2 instruction.
 it is a type safe form 4 dup2_x2 instruction.
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
A dup2_x2 instruction a type is safe form dup2_x21  instruction iff one can validly replace
four category 1 Type1types, , Type2, Type3, Type4, on the incoming operand stack with
the types Type1, Type2, Type3, Type4, Type1, Type2, yielding the outgoing type state.
216
--------------------------------------- 235
THE CLASS FILE FORMATdup2_x2
dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Stack3),
    popCategory1(Stack3, Type4, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type4, Type3, Type2, Type1],
                      OutputOperandStack).
A dup2_x2 instruction a type is safe form dup2_x22  instruction iff one can validly replace a
category 2 type, Type1, and two category Type21 types, , Type3, on the incoming operand
stack with the types Type1, Type2, Type3, Type1, yielding the outgoing type state.
dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
A dup2_x2 instruction a type is safe form dup2_x23  instruction iff one can validly replace
two category 1 Type1types, , Type2, and a category Type32 type, , on the incoming
operand stack with the Type1types , Type2, Type3, Type1, Type2, yielding the outgoing
type state.
dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory2(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
A dup2_x2 instruction a type is safe form dup2_x24  instruction iff one can validly replace
two category 2 Type1types, , Type2, on the incoming operand stack Type1with , the types 
Type2, Type1, yielding the outgoing type state.
dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
217
--------------------------------------- 236
f2dTHE CLASS FILE FORMAT
f2df2d
An f2d instruction is type safe if one floatcan  off validly the incoming pop operand stack
and replace it with double, yielding the outgoing type state.
instructionIsTypeSafe(f2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
218
--------------------------------------- 237
THE CLASS FILE FORMATf2i
f2if2i
An f2i instruction is type safe if one floatcan  off validly the incoming pop operand stack
and replace it with int, yielding the outgoing type state.
instructionIsTypeSafe(f2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
219
--------------------------------------- 238
f2lTHE CLASS FILE FORMAT
f2lf2l
An f2l instruction is type safe if one floatcan  off validly the incoming pop operand stack
and replace it with long, yielding the outgoing type state.
instructionIsTypeSafe(f2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
220
--------------------------------------- 239
THE CLASS FILE FORMATfadd
faddfadd
An fadd instruction is type safe iff one can validly floatreplace  and floattypes matching 
on the incoming operand stack with float yielding the outgoing type state.
instructionIsTypeSafe(fadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float, float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
221
--------------------------------------- 240
faloadTHE CLASS FILE FORMAT
faloadfaload
An faload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of float on the incoming operand stack with float yielding the outgoing type state.
instructionIsTypeSafe(faload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(float)], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
222
--------------------------------------- 241
THE CLASS FILE FORMATfastore
fastorefastore
An fastore instruction is type safe iff one can validly floatpop , int types andmatching 
array of float off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(fastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [float, int, arrayOf(float)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
223
--------------------------------------- 242
fcmp<op>THE CLASS FILE FORMAT
fcmp<op>fcmp<op>
An fcmpg instruction is type safe iff one can validly floatreplace  and types matching 
float on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(fcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float, float], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
An fcmpl instruction is type safe iff the equivalent fcmpg instruction is type safe.
instructionHasEquivalentTypeRule(fcmpl, fcmpg).
224
--------------------------------------- 243
THE CLASS FILE FORMATfconst_<f>
fconst_<f>fconst_<f>
An fconst_0 instruction is type safe if one can validly float onto push thethe type 
incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(fconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [], float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The rules for the other variants of fconst are equivalent:
instructionHasEquivalentTypeRule(fconst_1, fconst_0).
instructionHasEquivalentTypeRule(fconst_2, fconst_0).
225
--------------------------------------- 244
fdivTHE CLASS FILE FORMAT
fdivfdiv
An fdiv instruction is type safe iff the equivalent fadd instruction is type safe.
instructionHasEquivalentTypeRule(fdiv, fadd).
226
--------------------------------------- 245
THE CLASS FILE FORMATfload
floadfload
An fload instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a load instruction Indexwith  and operand type float is type safe
and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(fload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    loadIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
227
--------------------------------------- 246
fload_<n>THE CLASS FILE FORMAT
fload_<n>fload_<n>
The instructions fload_<n>, for d n0  d 3, are typesafe iff the floadequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(fload_0, fload(0)).
instructionHasEquivalentTypeRule(fload_1, fload(1)).
instructionHasEquivalentTypeRule(fload_2, fload(2)).
instructionHasEquivalentTypeRule(fload_3, fload(3)).
228
--------------------------------------- 247
THE CLASS FILE FORMATfmul
fmulfmul
An fmul instruction is type safe iff the equivalent fadd instruction is type safe.
instructionHasEquivalentTypeRule(fmul, fadd).
229
--------------------------------------- 248
fnegTHE CLASS FILE FORMAT
fnegfneg
An fneg instruction is type safe iff there floatis  a on type the matching incoming operand
stack. The fneg instruction does not alter the type state.
instructionIsTypeSafe(fneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
230
--------------------------------------- 249
THE CLASS FILE FORMATfrem
fremfrem
An frem instruction is type safe iff the equivalent fadd instruction is type safe.
instructionHasEquivalentTypeRule(frem, fadd).
231
--------------------------------------- 250
freturnTHE CLASS FILE FORMAT
freturnfreturn
An freturn instruction is type safe if the enclosing method has a declared return type of
float, and one can validly pop a type matching float off the incoming operand stack.
instructionIsTypeSafe(freturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, float),
    canPop(StackFrame, [float], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
232
--------------------------------------- 251
THE CLASS FILE FORMATfstore
fstorefstore
An fstore instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a store instruction Indexwith  and operand type float is type safe
and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(fstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    storeIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
233
--------------------------------------- 252
fstore_<n>THE CLASS FILE FORMAT
fstore_<n>fstore_<n>
The instructions fstore_<n>, for d n0  d 3, are typesafe iff the fstoreequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(fstore_0, fstore(0)).
instructionHasEquivalentTypeRule(fstore_1, fstore(1)).
instructionHasEquivalentTypeRule(fstore_2, fstore(2)).
instructionHasEquivalentTypeRule(fstore_3, fstore(3)).
234
--------------------------------------- 253
THE CLASS FILE FORMATfsub
fsubfsub
An fsub instruction is type safe iff the equivalent fadd instruction is type safe.
instructionHasEquivalentTypeRule(fsub, fadd).
235
--------------------------------------- 254
getfieldTHE CLASS FILE FORMAT
getfieldgetfield
A getfield instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting a field whose declared FieldTypetype , declared is in FieldClassa class ,
and one can validly replace a FieldClasstype matching  with type FieldType on the
incoming operand stack yielding the outgoing FieldClasstype  must state. not be an array
type. protected fields are subject to additional checks.
instructionIsTypeSafe(getfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, StackFrame),
    validTypeTransition(Environment, [class(FieldClass)], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The protected check applies only to members of superclasses of the current class. Other
cases will be caught by the access checking done at resolution time. If the name of a class
is not the name of any superclass, it cannot be a superclass, and so it can safely be ignored.
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    notMember(class(MemberClassName, _), Chain).
Using a superclass member that is not protected is trivially correct.
If the MemberClassName is the same as the name of a superclass, the class being resolved
may indeed be a superclass. In this case, if MemberClassNameno superclass  in named a
different runtime package protectedhas  a member named MemberName with descriptor
MemberDescriptor, the protected check need not apply.
This is because the actual class being resolved will either be one of these superclasses, in
which case we know that it is either in the same runtime package, and the access is legal;
or the member in question protectedis not  and the check does not apply; or it will be a
subclass, in which case the check would succeed anyway; or it will be some other class in
the same runtime package, in which case the access is legal and the check need not take
place; or the verifier need not flag this as a problem, since it will be caught anyway because
resolution will per force fail.
236
--------------------------------------- 255
THE CLASS FILE FORMATgetfield
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, []).
If there does protectedexist a  superclass member in a different runtime package, then
load MemberClassName; if the member in question protectedis , not the check does not
apply.
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,
                     frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWIthProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
    List /= [],
    loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
    isNotProtected(ReferencedClass, MemberName, MemberDescriptor).
Otherwise, use of a member of an Targetobject  requires of type Targetthat  be assignable
to the type of the current class.
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,
                     frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
    List /= [],
    loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
    isProtected(ReferencedClass, MemberName, MemberDescriptor),
    isAssignable(Target, class(CurrentClassName, CurrentLoader)).
The predicate classesInOtherPkgWithProtectedMember(Class, MemberName,
MemberDescriptor, MemberClassName, Chain, List) is true Listif  is the set of
237
--------------------------------------- 256
getfieldTHE CLASS FILE FORMAT
classes Chainin  with name MemberClassName that are in a different runtime package
than Class which have protecteda  member named MemberName with descriptor
MemberDescriptor.
classesInOtherPkgWithProtectedMember(_, _, _, _, [], []).
classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     [class(MemberClassName, L) | T]) :-
    differentRuntimePackage(Class, class(MemberClassName, L)),
    loadedClass(MemberClassName, L, Super),
    isProtected(Super, MemberName, MemberDescriptor),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).
classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T) :-
    differentRuntimePackage(Class, class(MemberClassName, L)),
    loadedClass(MemberClassName, L, Super),
    isNotProtected(Super, MemberName, MemberDescriptor),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).
classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T] :-
    sameRuntimePackage(Class, class(MemberClassName, L)),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).
238
--------------------------------------- 257
THE CLASS FILE FORMATgetstatic
getstaticgetstatic
A getstatic instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting a field whose declared FieldTypetype , and is one can validly FieldTypepush 
on the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(getstatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    validTypeTransition(Environment, [], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
239
--------------------------------------- 258
gotoTHE CLASS FILE FORMAT
gotogoto
A goto instruction is type safe iff its target operand is a valid branch target.
instructionIsTypeSafe(goto(Target), Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    targetIsTypeSafe(Environment, StackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
240
--------------------------------------- 259
THE CLASS FILE FORMATgoto_w
goto_wgoto_w
A goto_w instruction is type safe iff the equivalent goto instruction is type safe.
instructionHasEquivalentTypeRule(goto_w(Target), goto(Target)).
241
--------------------------------------- 260
i2bTHE CLASS FILE FORMAT
i2bi2b
An i2b instruction is type safe iff the equivalent ineg instruction is type safe.
instructionHasEquivalentTypeRule(i2b, ineg).
242
--------------------------------------- 261
THE CLASS FILE FORMATi2c
i2ci2c
An i2c instruction is type safe iff the equivalent ineg instruction is type safe.
instructionHasEquivalentTypeRule(i2c, ineg).
243
--------------------------------------- 262
i2dTHE CLASS FILE FORMAT
i2di2d
An i2d instruction is type safe if one intcan  off validly the incoming pop operand stack
and replace it with double, yielding the outgoing type state.
instructionIsTypeSafe(i2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
244
--------------------------------------- 263
THE CLASS FILE FORMATi2f
i2fi2f
An i2f instruction is type safe if one intcan  off validly the incoming pop operand stack
and replace it with float, yielding the outgoing type state.
instructionIsTypeSafe(i2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
245
--------------------------------------- 264
i2lTHE CLASS FILE FORMAT
i2li2l
An i2l instruction is type safe if one intcan  off validly the incoming pop operand stack
and replace it with long, yielding the outgoing type state.
instructionIsTypeSafe(i2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
246
--------------------------------------- 265
THE CLASS FILE FORMATi2s
i2si2s
An i2s instruction is type safe iff the equivalent ineg instruction is type safe.
instructionHasEquivalentTypeRule(i2s, ineg).
247
--------------------------------------- 266
iaddTHE CLASS FILE FORMAT
iaddiadd
An iadd instruction is type safe iff one can validly intreplace  and int ontypes matching 
the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(iadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, int], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
248
--------------------------------------- 267
THE CLASS FILE FORMATiaload
ialoadiaload
An iaload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of int on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(iaload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(int)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
249
--------------------------------------- 268
iandTHE CLASS FILE FORMAT
iandiand
An iand instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(iand, iadd).
250
--------------------------------------- 269
THE CLASS FILE FORMATiastore
iastoreiastore
An iastore instruction is type safe iff one can validly int, intpop  andtypes matching 
array of int off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(iastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [int, int, arrayOf(int)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
251
--------------------------------------- 270
if_acmp<cond>THE CLASS FILE FORMAT
if_acmp<cond>if_acmp<cond>
An if_acmpeq instruction is type safe iff one can validly referencepop types matching 
and reference on the incoming operand stack yielding the outgoing type state
NextStackFrame, and the operand of the Targetinstruction, , is a valid branch target
assuming an incoming type state of NextStackFrame.
instructionIsTypeSafe(if_acmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [reference, reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The rule for if_acmpne is identical.
instructionHasEquivalentTypeRule(if_acmpne(Target), if_acmpeq(Target)).
252
--------------------------------------- 271
THE CLASS FILE FORMATif_icmp<cond>
if_icmp<cond>if_icmp<cond>
An if_icmpeq instruction is type safe iff one can validly int and pop inttypes matching 
on the incoming operand stack yielding the NextStackFrameoutgoing type , and state the
operand of the instruction, Target, is a valid branch target assuming an incoming type
state of NextStackFrame.
instructionIsTypeSafe(if_icmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [int, int], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The rules for all other variants of the if_icmp<cond> instruction are identical.
instructionHasEquivalentTypeRule(if_icmpge(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpgt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmple(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmplt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpne(Target), if_icmpeq(Target)).
253
--------------------------------------- 272
if<cond>THE CLASS FILE FORMAT
if<cond>if<cond>
An ifeq instruction is type safe iff one can validly int off pop the a type incomingmatching 
operand stack yielding the outgoing NextStackFrametype state , and the operand of
the instruction, Target, is a valid branch target assuming an incoming type state of
NextStackFrame.
instructionIsTypeSafe(ifeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int], NextStackFrame), 
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The rules for all other variations of the if<cond> instruction are identical.
instructionHasEquivalentTypeRule(ifge(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifgt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifle(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(iflt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifne(Target), ifeq(Target)).
254
--------------------------------------- 273
THE CLASS FILE FORMATifnonnull
ifnonnullifnonnull
An ifnonnull instruction is type safe iff one can validly referencepop a type matching 
off the incoming operand stack yielding the NextStackFrameoutgoing type , and state the
operand of the instruction, Target, is a valid branch target assuming an incoming type
state of NextStackFrame.
instructionIsTypeSafe(ifnonnull(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
255
--------------------------------------- 274
ifnullTHE CLASS FILE FORMAT
ifnullifnull
An ifnull instruction is type safe iff the equivalent ifnonnull instruction is type safe.
instructionHasEquivalentTypeRule(ifnull(Target), ifnonnull(Target)).
256
--------------------------------------- 275
THE CLASS FILE FORMATiinc
iinciinc
An iinc instruction with first Indexoperand  is type safe LIndexiff  has type int. The iinc
instruction does not change the type state.
instructionIsTypeSafe(iinc(Index, _Value), _Environment, _Offset,
                      StackFrame, StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, _Flags),
    nth0(Index, Locals, int),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
257
--------------------------------------- 276
iloadTHE CLASS FILE FORMAT
iloadiload
An iload instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a load instruction Indexwith  and operand type int is type safe and
yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(iload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    loadIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
258
--------------------------------------- 277
THE CLASS FILE FORMATiload_<n>
iload_<n>iload_<n>
The instructions iload_<n>, for d n0  d 3, are typesafe iff the iloadequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(iload_0, iload(0)).
instructionHasEquivalentTypeRule(iload_1, iload(1)).
instructionHasEquivalentTypeRule(iload_2, iload(2)).
instructionHasEquivalentTypeRule(iload_3, iload(3)).
259
--------------------------------------- 278
imulTHE CLASS FILE FORMAT
imulimul
An imul instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(imul, iadd).
260
--------------------------------------- 279
THE CLASS FILE FORMATineg
inegineg
An ineg instruction is type safe iff there intis  on a the type incoming matching operand
stack. The ineg instruction does not alter the type state.
instructionIsTypeSafe(ineg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
261
--------------------------------------- 280
instanceofTHE CLASS FILE FORMAT
instanceofinstanceof
An instanceof instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting either a class or an array, and one can Objectvalidly  on replace top of the type 
the incoming operand stack with type int yielding the outgoing type state.
instructionIsTypeSafe(instanceof(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object'), BL], int,
                        StackFrame,NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
262
--------------------------------------- 281
THE CLASS FILE FORMATinvokedynamic
invokedynamicinvokedynamic
An invokedynamic instruction is type safe iff all of the following conditions hold:
 Its first operand, CP, refers to a constant pool entry denoting an dynamic call site with
name CallSiteName with descriptor Descriptor.
CallSiteName is not <init>.
CallSiteName is not <clinit>.
 One can validly replace types matching the argument Descriptortypes  on given in 
the incoming operand stack with the return Descriptortype , given yielding in the
outgoing type state.
instructionIsTypeSafe(invokedynamic(CP,0,0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :- 
    CP = dmethod(CallSiteName, Descriptor),
    CallSiteName \= '<init>',
    CallSiteName \= '<clinit>',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
263
--------------------------------------- 282
invokeinterfaceTHE CLASS FILE FORMAT
invokeinterfaceinvokeinterface
An invokeinterface instruction is type safe iff all of the following conditions hold:
 Its first operand, CP, refers to a constant pool entry denoting an interface method
named MethodName with descriptor Descriptor that is a member of an interface
MethodIntfName.
MethodName is not <init>.
MethodName is not <clinit>.
 Its second operand, Count, is a valid count operand (see below).
 One can validly replace types matching MethodIntfNamethe type  and the argument
types given Descriptorin  on the incoming operand stack with the return type given
in Descriptor, yielding the outgoing type state.
instructionIsTypeSafe(invokeinterface(CP, Count, 0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :- 
    CP = imethod(MethodIntfName, MethodName, Descriptor),
    MethodName \= '<init>',
    MethodName \= '<clinit>',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    currentClassLoader(Environment, L),
    reverse([class(MethodIntfName, L) | OperandArgList], StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    validTypeTransition(Environment, [], ReturnType, TempFrame, NextStackFrame),
    countIsValid(Count, StackFrame, TempFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The Count operand of invokeinterfacean  instruction is valid if it equals the size of the
arguments to the instruction. This is equal to the difference InputFrame between the size of 
and OutputFrame.
countIsValid(Count, InputFrame, OutputFrame) :-
    InputFrame = frame(_Locals1, OperandStack1, _Flags1),
    OutputFrame = frame(_Locals2, OperandStack2, _Flags2),
    length(OperandStack1, Length1),
    length(OperandStack2, Length2),
    Count =:= Length1 - Length2.
264
--------------------------------------- 283
THE CLASS FILE FORMATinvokespecial
invokespecialinvokespecial
An invokespecial instruction is type safe iff all of the following conditions hold:
 Its first operand, CP, refers to a constant pool entry denoting a method
named MethodName with descriptor Descriptor that is a member of a class
MethodClassName.
Either:
MethodName is not <init>.
MethodName is not <clinit>.
 One can validly replace types matching the current class and the argument types given in
Descriptor on the incoming operand stack with the return Descriptortype ,given in 
yielding the outgoing type state.
 One can validly replace types matching MethodClassNamethe class  and the argument
types given Descriptorin  on the incoming operand stack with the return type given
in Descriptor.
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= '<init>',
    MethodName \= '<clinit>',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    thisClass(Environment, CurrentClass), 
    reverse([CurrentClass | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList2),
    validTypeTransition(Environment, StackArgList2, ReturnType,
                        StackFrame, _ResultStackFrame),
    isAssignable(class(CurrentClassName, L), class(MethodClassName, L)).
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
Or:
 MethodName is <init>.
Descriptor specifies a void return type.
 One can validly pop types matching the argument Descriptortypes  andgiven in 
an uninitialized UninitializedArgtype, , off the incoming operand stack, yielding
OperandStack.
265
--------------------------------------- 284
invokespecialTHE CLASS FILE FORMAT
 The outgoing type state is derived from the incoming type state by first replacing
the incoming operand stack OperandStackwith  and then replacing all instances of
UninitializedArg with the type of instance being initialized.
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, '<init>', Descriptor),
    parseMethodDescriptor(Descriptor, OperandArgList, void), 
    reverse(OperandArgList, StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    TempFrame = frame(Locals, FullOperandStack, Flags),
    FullOperandStack = [UninitializedArg | OperandStack],
    currentClassLoader(Environment, CurrentLoader),
    rewrittenUninitializedType(UninitializedArg, Environment,
                               class(MethodClassName, CurrentLoader), This), 
    rewrittenInitializationFlags(UninitializedArg, Flags, NextFlags), 
    substitute(UninitializedArg, This, OperandStack, NextOperandStack),
    substitute(UninitializedArg, This, Locals, NextLocals),
    NextStackFrame = frame(NextLocals, NextOperandStack, NextFlags),
    ExceptionStackFrame = frame(NextLocals, [], Flags),
    passesProtectedCheck(Environment, MethodClassName, '<init>',
                         Descriptor, NextStackFrame).
Special rule for invokespecial of an <init> method.
This rule is the sole motivation for passing back a distinct exception stack frame. The
concern is invokespecialthat  can cause a superclass <init> method to be invoked, and
that invocation could fail, this uninitialized. leaving This situation cannot be created using
source code in the Java programming language, but can be created by programming in
bytecode directly.
The original frame holds an uninitialized object in a local and has flag
uninitializedThis. Normal termination invokespecialof  initializes the uninitialized
object and turns uninitializedThisoff the  flag. But if the invocation <init> of an 
method throws an exception, the uninitialized object might be left in a partially
initialized state, and needs to be made permanently unusable. This is represented by
an exception frame containing the broken object (the new value of the local) and the
uninitializedThis flag (the old flag). There is no way to get from an apparently-
initialized object bearing uninitializedThisthe  flag to a properly initialized object, so
the object is permanently unusable. If not for this case, the exception stack frame could be
the same as the input stack frame.
266
--------------------------------------- 285
THE CLASS FILE FORMATinvokespecial
rewrittenUninitializedType(uninitializedThis, Environment,
                           _MethodClass, This) :-
    thisClass(Environment, This).
rewrittenUninitializedType(uninitialized(Address), Environment,
                           MethodClass, MethodClass) :-
    allInstructions(Environment, Instructions),
    member(instruction(Address, new(MethodClass)), Instructions).
Computes what type the uninitialized argument's type needs to be rewritten to. There are
2 cases.
If we are initializing an object within its constructor, its type is initially
uninitializedThis. This type will be rewritten to the type <init>of the class of the 
method.
The second case arises from initialization of newan . The object uninitializedcreated by 
arg type is rewritten MethodClassto , the type of the method <init>holder . We of check
whether there really is a new instruction at Address.
rewrittenInitializationFlags(uninitializedThis, _Flags, []).
rewrittenInitializationFlags(uninitialized(_), Flags, Flags).
substitute(_Old, _New, [], []).
substitute(Old, New, [Old | FromRest], [New | ToRest]) :-
    substitute(Old, New, FromRest, ToRest).
substitute(Old, New, [From1 | FromRest], [From1 | ToRest]) :-
    From1 \= Old,
    substitute(Old, New, FromRest, ToRest).
267
--------------------------------------- 286
invokestaticTHE CLASS FILE FORMAT
invokestaticinvokestatic
An invokestatic instruction is type safe iff all of the following conditions hold:
 Its first operand, CP, refers to a constant pool entry denoting a method named
MethodName with descriptor Descriptor.
MethodName is not <init>.
MethodName is not <clinit>.
 One can validly replace types matching the argument Descriptortypes  on given in 
the incoming operand stack with the return Descriptortype , given yielding in the
outgoing type state.
instructionIsTypeSafe(invokestatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = method(_MethodClassName, MethodName, Descriptor),
    MethodName \= '<init>',
    MethodName \= '<clinit>',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType), 
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
268
--------------------------------------- 287
THE CLASS FILE FORMATinvokevirtual
invokevirtualinvokevirtual
An invokevirtual instruction is type safe iff all of the following conditions hold:
 Its first operand, CP, refers to a constant pool entry denoting a method
named MethodName with descriptor Descriptor that is a member of a class
MethodClassName.
MethodName is not <init>.
MethodName is not <clinit>.
 One can validly replace types matching MethodClassNamethe class  and the argument
types given Descriptorin  on the incoming operand stack with the return type given
in Descriptor, yielding the outgoing type state.
 If the method protectedis , the usage conforms to the special rules governing access
to protected members.
instructionIsTypeSafe(invokevirtual(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= '<init>',
    MethodName \= '<clinit>',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType), 
    reverse(OperandArgList, ArgList),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    canPop(StackFrame, ArgList, PoppedFrame),
    passesProtectedCheck(Environment, MethodClassName, MethodName,
                         Descriptor, PoppedFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
269
--------------------------------------- 288
iorTHE CLASS FILE FORMAT
iorior
An ior instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(ior, iadd).
270
--------------------------------------- 289
THE CLASS FILE FORMATirem
iremirem
An irem instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(irem, iadd).
271
--------------------------------------- 290
ireturnTHE CLASS FILE FORMAT
ireturnireturn
An ireturn instruction is type safe if the enclosing method has a declared return type of
int, and one can validly pop a type matching int off the incoming operand stack.
instructionIsTypeSafe(ireturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, int),
    canPop(StackFrame, [int], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
272
--------------------------------------- 291
THE CLASS FILE FORMATishl
ishlishl
An ishl instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(ishl, iadd).
273
--------------------------------------- 292
ishrTHE CLASS FILE FORMAT
ishrishr
An ishr instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(ishr, iadd).
274
--------------------------------------- 293
THE CLASS FILE FORMATistore
istoreistore
An istore instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a store instruction Indexwith  and operand type int is type safe and
yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(istore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    storeIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
275
--------------------------------------- 294
istore_<n>THE CLASS FILE FORMAT
istore_<n>istore_<n>
The instructions istore_<n>, for d n0  d 3, are type safe iff the istoreequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(istore_0, istore(0)).
instructionHasEquivalentTypeRule(istore_1, istore(1)).
instructionHasEquivalentTypeRule(istore_2, istore(2)).
instructionHasEquivalentTypeRule(istore_3, istore(3)).
276
--------------------------------------- 295
THE CLASS FILE FORMATisub
isubisub
An isub instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(isub, iadd).
277
--------------------------------------- 296
iushrTHE CLASS FILE FORMAT
iushriushr
An iushr instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(iushr, iadd).
278
--------------------------------------- 297
THE CLASS FILE FORMATixor
ixorixor
An ixor instruction is type safe iff the equivalent iadd instruction is type safe.
instructionHasEquivalentTypeRule(ixor, iadd).
279
--------------------------------------- 298
l2dTHE CLASS FILE FORMAT
l2dl2d
An l2d instruction is type safe if one longcan  off validly the incoming pop operand stack
and replace it with double, yielding the outgoing type state.
instructionIsTypeSafe(l2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
280
--------------------------------------- 299
THE CLASS FILE FORMATl2f
l2fl2f
An l2f instruction is type safe if one longcan  off validly the incoming pop operand stack
and replace it with float, yielding the outgoing type state.
instructionIsTypeSafe(l2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
281
--------------------------------------- 300
l2iTHE CLASS FILE FORMAT
l2il2i
An l2i instruction is type safe if one longcan  off validly the incoming pop operand stack
and replace it with int, yielding the outgoing type state.
instructionIsTypeSafe(l2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
282
--------------------------------------- 301
THE CLASS FILE FORMATladd
laddladd
An ladd instruction is type safe iff one can validly longreplace  and longtypes matching 
on the incoming operand stack with long yielding the outgoing type state.
instructionIsTypeSafe(ladd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
283
--------------------------------------- 302
laloadTHE CLASS FILE FORMAT
laloadlaload
An laload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of long on the incoming operand stack with long yielding the outgoing type state.
instructionIsTypeSafe(laload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(long)], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
284
--------------------------------------- 303
THE CLASS FILE FORMATland
landland
An land instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(land, ladd).
285
--------------------------------------- 304
lastoreTHE CLASS FILE FORMAT
lastorelastore
An lastore instruction is type safe iff one can validly long, pop int types andmatching 
array of long off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(lastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [long, int, arrayOf(long)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
286
--------------------------------------- 305
THE CLASS FILE FORMATlcmp
lcmplcmp
A lcmp instruction is type safe iff one can validly longreplace  and longtypes matching 
on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(lcmp, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long, long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
287
--------------------------------------- 306
lconst_<l>THE CLASS FILE FORMAT
lconst_<l>lconst_<l>
An lconst_0 instruction is type safe if one can longvalidly  onto push the the incomingtype 
operand stack yielding the outgoing type state.
instructionIsTypeSafe(lconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [], long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
An lconst_1 instruction is type safe iff the equivalent lconst_0 instruction is type safe.
instructionHasEquivalentTypeRule(lconst_1, lconst_0).
288
--------------------------------------- 307
THE CLASS FILE FORMATldc
ldcldc
An ldc instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting an entity Typeof , type where Type is either int, float, String, Class,
java.lang.invoke.MethodType, or java.lang.invoke.MethodHandle, and one
can validly push Type onto the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(ldc(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    functor(CP, Tag, _),
    isBootstrapLoader(BL),
    member([Tag, Type], [
        [int, int],
        [float, float],
        [string, class('java/lang/String', BL)],
        [classConst, class('java/lang/Class', BL)],
        [methodTypeConst, class('java/lang/invoke/MethodType', BL)],
        [methodHandleConst, class('java/lang/invoke/MethodHandle', BL)],
    ]),
    validTypeTransition(Environment, [], Type, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
289
--------------------------------------- 308
ldc_wTHE CLASS FILE FORMAT
ldc_wldc_w
An ldc_w instruction is type safe iff the equivalent ldc instruction is type safe.
instructionHasEquivalentTypeRule(ldc_w(CP), ldc(CP))
290
--------------------------------------- 309
THE CLASS FILE FORMATldc2_w
ldc2_wldc2_w
An ldc2_w instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting an entity Tagof , type where Tag is either long or double, and one can validly
push Tag onto the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(ldc2_w(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    functor(CP, Tag, _),
    member(Tag, [long, double]), 
    validTypeTransition(Environment, [], Tag, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
291
--------------------------------------- 310
ldivTHE CLASS FILE FORMAT
ldivldiv
An ldiv instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(ldiv, ladd).
292
--------------------------------------- 311
THE CLASS FILE FORMATlload
lloadlload
An lload instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a load instruction Indexwith  and operand type long is type safe and
yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(lload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    loadIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
293
--------------------------------------- 312
lload_<n>THE CLASS FILE FORMAT
lload_<n>lload_<n>
The instructions lload_<n>, for d n0  d 3, are type safe iff the lloadequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(lload_0, lload(0)).
instructionHasEquivalentTypeRule(lload_1, lload(1)).
instructionHasEquivalentTypeRule(lload_2, lload(2)).
instructionHasEquivalentTypeRule(lload_3, lload(3)).
294
--------------------------------------- 313
THE CLASS FILE FORMATlmul
lmullmul
An lmul instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(lmul, ladd).
295
--------------------------------------- 314
lnegTHE CLASS FILE FORMAT
lneglneg
An lneg instruction is type safe iff there longis  on a type the incoming matching operand
stack. The lneg instruction does not alter the type state.
instructionIsTypeSafe(lneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
296
--------------------------------------- 315
THE CLASS FILE FORMATlookupswitch
lookupswitchlookupswitch
A lookupswitch instruction is type safe if its keys are sorted, intone can validly pop 
off the incoming operand stack yielding BranchStackFramea new type state , and all
of the instruction's targets are valid branch BranchStackFrametargets assuming  as their
incoming type state.
instructionIsTypeSafe(lookupswitch(Targets, Keys), Environment, _, StackFrame, 
                      afterGoto, ExceptionStackFrame) :-
    sort(Keys, Keys),
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
297
--------------------------------------- 316
lorTHE CLASS FILE FORMAT
lorlor
A lor instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(lor, ladd).
298
--------------------------------------- 317
THE CLASS FILE FORMATlrem
lremlrem
An lrem instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(lrem, ladd).
299
--------------------------------------- 318
lreturnTHE CLASS FILE FORMAT
lreturnlreturn
An lreturn instruction is type safe if the enclosing method has a declared return type of
long, and one can validly pop a type matching long off the incoming operand stack.
instructionIsTypeSafe(lreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, long),
    canPop(StackFrame, [long], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
300
--------------------------------------- 319
THE CLASS FILE FORMATlshl
lshllshl
An lshl instruction is type safe if one can validly int and replace long on the the types 
incoming operand stack with the type long yielding the outgoing type state.
instructionIsTypeSafe(lshl, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
301
--------------------------------------- 320
lshrTHE CLASS FILE FORMAT
lshrlshr
An lshr instruction is type safe iff the equivalent lshl instruction is type safe.
instructionHasEquivalentTypeRule(lshr, lshl).
302
--------------------------------------- 321
THE CLASS FILE FORMATlstore
lstorelstore
An lstore instruction with Indexoperand  is type safe and yields an outgoing type state
NextStackFrame, if a store instruction Indexwith  and operand type long is type safe
and yields an outgoing type state NextStackFrame.
instructionIsTypeSafe(lstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    storeIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
303
--------------------------------------- 322
lstore_<n>THE CLASS FILE FORMAT
lstore_<n>lstore_<n>
The instructions lstore_<n>, for d n0  d 3, are type safe iff the lstoreequivalent  instruction
is type safe.
instructionHasEquivalentTypeRule(lstore_0, lstore(0)).
instructionHasEquivalentTypeRule(lstore_1, lstore(1)).
instructionHasEquivalentTypeRule(lstore_2, lstore(2)).
instructionHasEquivalentTypeRule(lstore_3, lstore(3)).
304
--------------------------------------- 323
THE CLASS FILE FORMATlsub
lsublsub
An lsub instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(lsub, ladd).
305
--------------------------------------- 324
lushrTHE CLASS FILE FORMAT
lushrlushr
An lushr instruction is type safe iff the equivalent lshl instruction is type safe.
instructionHasEquivalentTypeRule(lushr, lshl).
306
--------------------------------------- 325
THE CLASS FILE FORMATlxor
lxorlxor
An lxor instruction is type safe iff the equivalent ladd instruction is type safe.
instructionHasEquivalentTypeRule(lxor, ladd).
307
--------------------------------------- 326
monitorenterTHE CLASS FILE FORMAT
monitorentermonitorenter
A monitorenter instruction is type safe iff one can validly referencepop a type matching 
off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(monitorenter, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
308
--------------------------------------- 327
THE CLASS FILE FORMATmonitorexit
monitorexitmonitorexit
A monitorexit instruction is type safe iff monitorenterthe equivalent  instruction is type safe.
instructionHasEquivalentTypeRule(monitorexit, monitorenter).
309
--------------------------------------- 328
multianewarrayTHE CLASS FILE FORMAT
multianewarraymultianewarray
A multianewarray instruction with CPoperands  and Dim is type safe CP refers iff to a
constant pool entry denoting an array type whose dimension Dim, Dimis greater or equal to 
is strictly positive, and one can Dimvalidly  int types replace on the incoming operand
stack with the type denoted by CP yielding the outgoing type state.
instructionIsTypeSafe(multianewarray(CP, Dim), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :- 
    CP = arrayOf(_),
    classDimension(CP, Dimension),
    Dimension >= Dim,
    Dim > 0, 
    /* Make a list of Dim ints */
    findall(int, between(1, Dim, _), IntList),
    validTypeTransition(Environment, IntList, CP, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The dimension of an array type whose component type is also an array type is 1 more than
the dimension of its component type.
classDimension(arrayOf(X), Dimension) :-
    classDimension(X, Dimension1), 
    Dimension is Dimension1 + 1. 
classDimension(_, Dimension) :-
    Dimension = 0.
310
--------------------------------------- 329
THE CLASS FILE FORMATnew
newnew
A new instruction with CPoperand  at offset Offset is type safe CP refers iff to a constant
pool entry denoting a class uninitialized(Offset)type, the type  does not appear in
the incoming operand stack, and one uninitialized(Offset)can validly push  onto the
incoming operand stack and uninitialized(Offset)replace  with top in the incoming
local variables yielding the outgoing type state.
instructionIsTypeSafe(new(CP), Environment, Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, OperandStack, Flags), 
    CP = class(_, _), 
    NewItem = uninitialized(Offset),
    notMember(NewItem, OperandStack),
    substitute(NewItem, top, Locals, NewLocals),
    validTypeTransition(Environment, [], NewItem,
                        frame(NewLocals, OperandStack, Flags),
                        NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
311
--------------------------------------- 330
newarrayTHE CLASS FILE FORMAT
newarraynewarray
A newarray instruction with TypeCodeoperand  is type safe TypeCodeiff  corresponds to
the primitive ElementTypetype , and one can validly replace int on the the type incoming
operand stack with the type 'array of ElementType', yielding the outgoing type state.
instructionIsTypeSafe(newarray(TypeCode), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    primitiveArrayInfo(TypeCode, _TypeChar, ElementType, _VerifierType),
    validTypeTransition(Environment, [int], arrayOf(ElementType),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
The correspondence between type codes and primitive types is specified by the following
predicate:
primitiveArrayInfo(4,  0'Z, boolean, int).
primitiveArrayInfo(5,  0'C, char,    int).
primitiveArrayInfo(6,  0'F, float,   float).
primitiveArrayInfo(7,  0'D, double,  double).
primitiveArrayInfo(8,  0'B, byte,    int).
primitiveArrayInfo(9,  0'S, short,   int).
primitiveArrayInfo(10, 0'I, int,     int). 
primitiveArrayInfo(11, 0'J, long,    long).
312
--------------------------------------- 331
THE CLASS FILE FORMATnop
nopnop
A nop instruction is always type safe. The nop instruction does not affect the type state.
instructionIsTypeSafe(nop, _Environment, _Offset, StackFrame,
                      StackFrame, ExceptionStackFrame) :-
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
313
--------------------------------------- 332
popTHE CLASS FILE FORMAT
poppop
A pop instruction is type safe iff one can validly pop a category 1 type off the incoming
operand stack yielding the outgoing type state.
instructionIsTypeSafe(pop, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, [Type | Rest], Flags),
    Type \= top,
    sizeOf(Type, 1),
    NextStackFrame = frame(Locals, Rest, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
314
--------------------------------------- 333
THE CLASS FILE FORMATpop2
pop2pop2
A pop2 instruction is type safe iff it is a type safe form of the pop2 instruction.
instructionIsTypeSafe(pop2, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(Locals, InputOperandStack, Flags),
    pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
A pop2 instruction a type is safe form pop2of  instructionthe  iff it is a type safe form 1
pop2 instruction or a type safe form 2 pop2 instruction.
pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form1IsTypeSafe(InputOperandStack, OutputOperandStack).
pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form2IsTypeSafe(InputOperandStack, OutputOperandStack).
A pop2 instruction a type is safe form pop2 instruction1  iff one can validly pop two types
of size 1 off the incoming operand stack yielding the outgoing type state.
pop2Form1IsTypeSafe([Type1, Type2 | Rest], Rest) :-
    sizeOf(Type1, 1),
    sizeOf(Type2, 1).
A pop2 instruction a type is safe form pop2 instruction2  iff one can validly pop a type of
size 2 off the incoming operand stack yielding the outgoing type state.
pop2Form2IsTypeSafe([top, Type | Rest], Rest) :- sizeOf(Type, 2).
315
--------------------------------------- 334
putfieldTHE CLASS FILE FORMAT
putfieldputfield
A putfield instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting a field whose declared FieldTypetype , declared is in FieldClassa class , and
one can validly pop types FieldTypematching  and FieldClass off the incoming operand
stack yielding the outgoing type state.
instructionIsTypeSafe(putfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType), 
    canPop(StackFrame, [FieldType], PoppedFrame),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, PoppedFrame),
    currentClassLoader(Environment, CurrentLoader),
    canPop(StackFrame, [FieldType, class(FieldClass, CurrentLoader)],
           NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
316
--------------------------------------- 335
THE CLASS FILE FORMATputstatic
putstaticputstatic
A putstatic instruction with CPoperand  is type safe CP refers iff to a constant pool entry
denoting a field whose declared FieldTypetype , and is one can validly pop a type
matching FieldType off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(putstatic(CP), _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    canPop(StackFrame, [FieldType], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
317
--------------------------------------- 336
returnTHE CLASS FILE FORMAT
returnreturn
A return instruction is type safe if the enclosing void method return declares type, anda 
either:
 The enclosing method is not an <init> method, or
this has already been completely initialized at the point where the instruction occurs.
instructionIsTypeSafe(return, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :- 
    thisMethodReturnType(Environment, void),
    StackFrame = frame(_Locals, _OperandStack, Flags),
    notMember(flagThisUninit, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
318
--------------------------------------- 337
THE CLASS FILE FORMATsaload
saloadsaload
An saload instruction is type safe iff one can validly intreplace  and arraytypes matching 
of short on the incoming operand stack with int yielding the outgoing type state.
instructionIsTypeSafe(saload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [int, arrayOf(short)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
319
--------------------------------------- 338
sastoreTHE CLASS FILE FORMAT
sastoresastore
An sastore instruction is type safe iff one can validly int, intpop , types andmatching 
array of short off the incoming operand stack yielding the outgoing type state.
instructionIsTypeSafe(sastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    canPop(StackFrame, [int, int, arrayOf(short)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
320
--------------------------------------- 339
THE CLASS FILE FORMATsipush
sipushsipush
An sipush instruction is type safe iff one can intvalidly  onto push the incomingthe type 
operand stack yielding the outgoing type state.
instructionIsTypeSafe(sipush(_Value), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    validTypeTransition(Environment, [], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
321
--------------------------------------- 340
swapTHE CLASS FILE FORMAT
swapswap
A swap instruction is type safe iff one can validly replace Type1 two category 1 types, 
and Type2, on the incoming operand stack Type2with  and the Type1types  yielding the
outgoing type state.
instructionIsTypeSafe(swap, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :- 
    StackFrame = frame(_Locals, [Type1, Type2 | Rest], _Flags),
    sizeOf(Type1, 1),
    sizeOf(Type2, 1),
    NextStackFrame = frame(_Locals, [Type2, Type1 | Rest], _Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
322
--------------------------------------- 341
THE CLASS FILE FORMATtableswitch
tableswitchtableswitch
A tableswitch instruction is type safe if its keys are sorted, int offone can validly pop 
the incoming operand stack yielding a BranchStackFramenew type state , and all of
the instruction's targets are valid branch BranchStackFrametargets assuming  as their
incoming type state.
instructionIsTypeSafe(tableswitch(Targets, Keys), Environment, _Offset,
                      StackFrame, afterGoto, ExceptionStackFrame) :- 
    sort(Keys, Keys), 
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
323
--------------------------------------- 342
wideTHE CLASS FILE FORMAT
widewide
The wide instructions follow the same rules as the instructions they widen.
instructionHasEquivalentTypeRule(wide(WidenedInstruction),
                                 WidenedInstruction).
The type state after an instruction completes abruptly is the same as the incoming type state,
except that the operand stack is empty.
exceptionStackFrame(StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, Flags),
    ExceptionStackFrame = frame(Locals, [], Flags).
Most of the type rules in this specification depend on the notion of a valid type transition.
A type transition is valid if one can pop a list of expected types off the incoming type state's
operand stack and replace them with an expected result type, resulting in a new valid type
state. In particular, the size of the operand stack in the new type state must not exceed its
maximum declared size.
validTypeTransition(Environment, ExpectedTypesOnStack, ResultType,
                    frame(Locals, InputOperandStack, Flags),
                    frame(Locals, NextOperandStack, Flags)) :-
    popMatchingList(InputOperandStack, ExpectedTypesOnStack, InterimOperandStack),
    pushOperandStack(InterimOperandStack, ResultType, NextOperandStack),
    operandStackHasLegalLength(Environment, NextOperandStack).
Access Ith element of the operand stack from a type state.
nth1OperandStackIs(I, frame(_Locals, OperandStack, _Flags), Element) :-
    nth1(I, OperandStack, Element).
4.10.2Verification by Type Inference
A class file that does not StackMapTablecontain a  attribute (which necessarily
has a version number of 49.0 or below) must be verified using type inference.
4.10.2.1The Process of Verification by Type Inference
During linking, the verifier codechecks  array the of Codethe  attribute for each
method of classthe  file by performing data-flow analysis on each method. The
324
--------------------------------------- 343
THE CLASS FILE FORMATVerification by Type Inference4.10.2
verifier ensures that at any given point in the program, no matter what code path
is taken to reach that point, the following is true:
 The operand stack is always the same size and contains the same types of values.
 No local variable is accessed unless it is known to contain a value of an
appropriate type.
 Methods are invoked with the appropriate arguments.
 Fields are assigned only using values of appropriate types.
 All opcodes have appropriate type arguments on the operand stack and in the
local variable array.
 There is never an uninitialized class instance in a local variable in code protected
by an exception handler. However, an uninitialized class instance may be on the
operand stack in code protected by an exception handler. When an exception is
thrown, the contents of the operand stack are discarded.
For efficiency reasons, certain tests that could in principle be performed by the
verifier are delayed until the first time the code for the method is actually invoked.
In so doing, the verifier avoids loading class files unless it has to.
For example, if a method invokes another method that returns A, andan instance of class 
that instance is assigned only to a field of the same type, the verifier does not bother to
check if the A class actually exists. However, if it is assigned B, to thea field of the type 
definitions of both A and B must be loaded in to ensure that A is a subclass of B.
4.10.2.2The Bytecode Verifier
The code for each method is verified independently. First, the bytes that make up
the code are broken up into a sequence of instructions, code and the index into the 
array of the start of each instruction is placed in an array. The verifier then goes
through the code a second time and parses the instructions. During this pass a data
structure is built to hold information about each Java virtual machine instruction
in the method. The operands, if any, of each instruction are checked to make sure
they are valid. For instance:
 Branches must be within the bounds of the code array for the method.
 The targets of all control-flow instructions are each the start of an instruction.
In the case wideof  instruction, a widethe  opcode is considered the start of the
instruction, and the opcode giving the operation wide instructionmodified by that 
is not considered to start an instruction. Branches into the middle of an instruction
are disallowed.
325
--------------------------------------- 344
4.10.2 Verification by Type InferenceTHE CLASS FILE FORMAT
 No instruction can access or modify a local variable at an index greater than or
equal to the number of local variables that its method indicates it allocates.
 All references to the constant pool must be to an entry of the appropriate type.
(For example, the instruction getfield must reference a field.)
 The code does not end in the middle of an instruction.
 Execution cannot fall off the end of the code.
 For each exception handler, the starting and ending point of code protected by
the handler must be at the beginning of an instruction or, in the case of the ending
point, immediately past the end of the code. The starting point must be before
the ending point. The exception handler code must start at a valid instruction,
and it must not start at an opcode being modified by the wide instruction.
For each instruction of the method, the verifier records the contents of the operand
stack and the contents of the local variable array prior to the execution of that
instruction. For the operand stack, it needs to know the stack height and the type
of each value on it. For each local variable, it needs to know either the type of the
contents of that local variable or that the local variable contains an unusable or
unknown value (it might be uninitialized). The bytecode verifier does not need to
distinguish between the integral byte, types short, char(e.g., ) when determining
the value types on the operand stack.
Next, a data-flow analyzer is initialized. For the first instruction of the method,
the local variables that represent parameters initially contain values of the types
indicated by the method's type descriptor; the operand stack is empty. All other
local variables contain an illegal value. For the other instructions, which have not
been examined yet, no information is available regarding the operand stack or local
variables.
Finally, the data-flow analyzer is run. For each instruction, a "changed" bit
indicates whether this instruction needs to be looked at. Initially, the "changed" bit
is set only for the first instruction. The data-flow analyzer executes the following
loop:
1. Select a Java virtual machine instruction whose "changed" bit is set. If no
instruction remains whose "changed" bit is set, the method has successfully
been verified. Otherwise, turn off the "changed" bit of the selected instruction.
2. Model the effect of the instruction on the operand stack and local variable array
by doing the following:
326
--------------------------------------- 345
THE CLASS FILE FORMATVerification by Type Inference4.10.2
 If the instruction uses values from the operand stack, ensure that there are a
sufficient number of values on the stack and that the top values on the stack
are of an appropriate type. Otherwise, verification fails.
 If the instruction uses a local variable, ensure that the specified local variable
contains a value of the appropriate type. Otherwise, verification fails.
 If the instruction pushes values onto the operand stack, ensure that there is
sufficient room on the operand stack for the new values. Add the indicated
types to the top of the modeled operand stack.
 If the instruction modifies a local variable, record that the local variable now
contains the new type.
3. Determine the instructions that can follow the current instruction. Successor
instructions can be one of the following:
 The next instruction, if the current instruction is not an unconditional control
transfer instruction (for goto, instance, return, or athrow). Verification fails
if it is possible to "fall off" the last instruction of the method.
 The target(s) of a conditional or unconditional branch or switch.
 Any exception handlers for this instruction.
4. Merge the state of the operand stack and local variable array at the end of the
execution of the current instruction into each of the successor instructions.
In the special case of control transfer to an exception handler, the operand stack
is set to contain a single object of the exception type indicated by the exception
handler information. There must be sufficient room on the operand stack for
this single value, as if an instruction had pushed it.
 If this is the first time the successor instruction has been visited, record that
the operand stack and local variable values calculated in steps 2 and 3 are
the state of the operand stack and local variable array prior to executing the
successor instruction. Set the "changed" bit for the successor instruction.
 If the successor instruction has been seen before, merge the operand stack
and local variable values calculated in steps 2 and 3 into the values already
there. Set the "changed" bit if there is any modification to the values.
5. Continue at step 1.
To merge two operand stacks, the number of values on each stack must be identical.
The types of values on the stacks must also be identical, except that differently
typed reference values may appear at corresponding places on the two stacks. In
327
--------------------------------------- 346
4.10.2 Verification by Type InferenceTHE CLASS FILE FORMAT
this case, the merged operand stack referencecontains  to an a instance of the first
common superclass of the two types. referenceSuch  type a always exists because
the type Object is a superclass of all class and interface types. If the operand stacks
cannot be merged, verification of the method fails.
To merge two local variable array states, corresponding pairs of local variables are
compared. If the two types are not identical, then referenceunless both contain 
values, the verifier records that the local variable contains an unusable value. If both
of the pair of local variables referencecontain  values, the merged state contains
a reference to an instance of the first common superclass of the two types.
If the data-flow analyzer runs on a method without reporting a verification failure,
then the method has been successfully verified by the class file verifier.
Certain instructions and data types complicate the data-flow analyzer. We now
examine each of these in more detail.
4.10.2.3Values of Types long and double
Values of longthe  and double types are treated specially by the verification
process.
Whenever a value of longtype  or double is moved into a local variable at index
n, index n+1 is specially marked to indicate that it has been reserved by the value
at index n and must not be used as a local variable index. Any value previously at
index n+1 becomes unusable.
Whenever a value is moved to a local nvariable , the index n-1 at is index examined
to see if it is the index of longa  value or doubleof . If type so, the local variable
at index n-1 is changed to indicate that it now contains an unusable value. Since
the local variable n at has index been overwritten, the local nvariable -1at index 
cannot represent a value of type long or double.
Dealing with values longof  types or double on the operand stack is simpler; the
verifier treats them as single values on the stack. For example, the verification code
for the dadd opcode (add doubletwo  values) checks that the top two items on the
stack are both doubleof type . When calculating operand stack length, values of
type long and double have length two.
Untyped instructions that manipulate the operand stack must treat values of type
long and double as atomic (indivisible). For example, the verifier reports a failure
if the top value on the doublestack  and is it a encounters an instruction such as
pop or dup. The instructions pop2 or dup2 must be used instead.
328
--------------------------------------- 347
THE CLASS FILE FORMATVerification by Type Inference4.10.2
4.10.2.4Instance Initialization Methods and Newly Created Objects
Creating a new class instance is a multistep process. The statement:
...
new myClass(i, j, k);
...
can be implemented by the following:
...
new #1            // Allocate uninitialized space for myClass
dup               // Duplicate object on the operand stack
iload_1           // Push i
iload_2           // Push j
iload_3           // Push k
invokespecial #5  // Invoke myClass.<init>
...
This instruction sequence leaves the newly created and initialized object on top of
the operand stack. (Additional examples of compilation to the instruction set of
the Java virtual machine are given in Chapter 3, "Compiling for the Java Virtual
Machine.")
The instance initialization 2.9) method for class (myClass sees the new
uninitialized object this as argument its in local variable 0. Before that method
invokes another instance initialization myClass or method its direct of superclass
on this, the only operation the method can this perform is assigning on fields
declared within myClass.
When doing dataflow analysis on instance methods, the verifier initializes local
variable 0 to contain an object of the current class, or, for instance initialization
methods, local variable 0 contains a special type indicating an uninitialized object.
After an appropriate instance initialization method is invoked (from the current
class or the current superclass) on this object, all occurrences of this special type
on the verifier's model of the operand stack and in the local variable array are
replaced by the current class type. The verifier rejects code that uses the new
object before it has been initialized or that initializes the object more than once. In
addition, it ensures that every normal return of the method has invoked an instance
initialization method either in the class of this method or in the direct superclass.
Similarly, a special type is created and pushed on the verifier's model of the operand
stack as the result of the Java virtual newmachine . The special instruction type
indicates the instruction by which the class instance was created and the type of
the uninitialized class instance created. When an instance initialization method
declared in the class of the uninitialized class instance is invoked on that class
instance, all occurrences of the special type are replaced by the intended type of
329
--------------------------------------- 348
4.10.2 Verification by Type InferenceTHE CLASS FILE FORMAT
the class instance. This change in type may propagate to subsequent instructions
as the dataflow analysis proceeds.
The instruction number needs to be stored as part of the special type, as there
may be multiple not-yet-initialized instances of a class in existence on the operand
stack at one time. For example, the Java virtual machine instruction sequence that
implements:
new InputStream(new Foo(), new InputStream("foo"))
may have two uninitialized InputStreaminstances  on of the operand stack at once.
When an instance initialization method is invoked on a class instance, only those
occurrences of the special type on the operand stack or in the local variable array
that are the same object as the class instance are replaced.
A valid instruction sequence must not have an uninitialized object on the operand
stack or in a local variable at the target of a backwards branch if the special type of
the uninitialized object is merged with a special type other than itself, or in a local
variable in code protected by an exception finally handler clause. or Otherwise,a 
a devious piece of code might fool the verifier into thinking it had initialized a class
instance when it had, in fact, initialized a class instance created in a previous pass
through a loop.
4.10.2.5Exceptions and finally
To implement trythe -finally construct, a compiler for the Java programming
language that generates class files with version number 50.0 or below may use
the exception-handling facilities together with jsrtwo  ("jumpspecial instructions: 
to subroutine") ret ("return and from subroutine"). finally clause The is compiled
as a subroutine within the Java virtual machine code for its method, much like the
code for an exception handler. jsr instruction When a that invokes the subroutine is
executed, it pushes its return address, the address jsrof  thatthe instruction after the 
is being executed, onto the operand stack returnAddressas a value . Theof type 
code for the subroutine stores the return address in a local variable. At the end of
the subroutine, ret instruction a fetches the return address from the local variable
and transfers control to the instruction at the return address.
Control can be transferred finallyto  clause the (the finally subroutine can
be invoked) in several different try ways. clause If completes the normally, the
finally subroutine is invoked jsr instruction via a before evaluating the next
expression. breakA  or continue inside trythe  clause that transfers control outside
the try clause executes jsr to a the code for finallythe  clause first. tryIf the 
clause executes a return, the compiled code does the following:
330
--------------------------------------- 349
THE CLASS FILE FORMATVerification by Type Inference4.10.2
1. Saves the return value (if any) in a local variable.
2. Executes a jsr to the code for the finally clause.
3. Upon return from finallythe  clause, returns the value saved in the local
variable.
The compiler sets up a special exception handler, which catches any exception
thrown by trythe  clause. If an exception is trythrown  clause, in this the exception
handler does the following:
1. Saves the exception in a local variable.
2. Executes a jsr to the finally clause.
3. Upon return from the finally clause, rethrows the exception.
For more information about the implementation try-finally of construct, the 3.13see .
The code for finallythe  clause presents a special problem to the verifier. Usually,
if a particular instruction can be reached via multiple paths and a particular local
variable contains incompatible values through those multiple paths, then the local
variable becomes unusable. However, finally clause a might be called from
several different places, yielding several different circumstances:
 The invocation from the exception handler may have a certain local variable that
contains an exception.
 The invocation to implement return may have some local variable that contains
the return value.
 The invocation from the bottom try clause of the may have an indeterminate
value in that same local variable.
The code for finallythe  clause itself might pass verification, but after completing
the updating all the successors ret instruction, of the the verifier would note that the
local variable that the exception handler expects to hold an exception, or that the
return code expects to hold a return value, now contains an indeterminate value.
Verifying code that contains finally clause a is complicated. The basic idea is
the following:
 Each instruction keeps track of jsr targets the list needed of to reach that
instruction. For most code, this list is empty. For instructions inside code for the
finally clause, it is of length one. For finallymultiply  code (extremelynested 
rare!), it may be longer than one.
331
--------------------------------------- 350
4.11Limitations of the Java virtual machineTHE CLASS FILE FORMAT
 For each instruction jsrand  needed each to reach that instruction, a bit vector
is maintained of all local variables accessed or modified since the execution of
the jsr instruction.
 When executing retthe  instruction, which implements a return from a subroutine,
there must be only one possible subroutine from which the instruction can be
returning. Two different subroutines cannot "merge" their execution to a single
ret instruction.
 To perform the data-flow analysis ret instruction, on a a special procedure is
used. Since the verifier knows the subroutine from which the instruction must be
returning, it can find jsr instructions all the that call the subroutine and merge the
state of the operand stack and local variable retarray  instructionat the time of the 
into the operand stack and local variable array of the instructions following the
jsr. Merging uses a special set of values for local variables:
For any local variable that the bit vector (constructed above) indicates has been
accessed or modified by the subroutine, use the type of the local variable at
the time of the ret.
For other local variables, use the type of the local jsrvariable before the 
instruction.
4.11Limitations of the Java virtual machine
The following limitations of the Java virtual machine class fileare implicit in the 
format:
 The per-class or per-interface constant pool is limited to 65535 entries by the 16-
bit constant_pool_count field of ClassFilethe  structure 4.1). ( This acts as
an internal limit on the total complexity of a single class or interface.
 The number of fields that may be declared by a class or interface is limited to
65535 by the size of the fields_count item of the ClassFile structure (4.1).
Note that the value fields_countof the  item of ClassFilethe  structure does
not include fields that are inherited from superclasses or superinterfaces.
 The number of methods that may be declared by a class or interface is limited to
65535 by the size methods_countof the  item of ClassFilethe  structure 4.1).(
Note that the value methods_countof the  item of ClassFilethe  structure does
not include methods that are inherited from superclasses or superinterfaces.
332
--------------------------------------- 351
THE CLASS FILE FORMATLimitations of the Java virtual 4.11machine
 The number of direct superinterfaces of a class or interface is limited to 65535
by the size of the interfaces_count item of the ClassFile structure (4.1).
 The greatest number of local variables in the local variables array of a frame
created upon invocation of 2.6a ) method is limited (to 65535 by the size of the
max_locals item of Codethe  attribute 4.7.3() giving the code of the method,
and by the 16-bit local variable indexing of the Java virtual machine instruction
set.
Note that values longof  type and double are each considered to reserve two
local variables and contribute two max_localsunits toward  value, the so use of
local variables of those types further reduces this limit.
 The size of an operand stack 2.6in ) is a frame limited ( to 65535 values by the
max_stack field of the Code attribute (4.7.3).
Note that values longof  type and double are each considered to contribute two
units toward max_stackthe  value, so use of values of these types on the operand
stack further reduces this limit.
 The number of method parameters is limited to 255 by the definition of a method
descriptor 4.3.3(), where the limit includes thisone  in unit the for case of
instance or interface method invocations.
Note that a method descriptor is defined in terms of a notion of method parameter
length in which a parameter long of or doubletype  contributes two units to the
length, so parameters of these types further reduce the limit.
 The length of field and method names, field and method descriptors, and other
constant string values (including those ConstantValuereferenced  (4.7.2by )
attributes) is limited to 65535 characters lengthby the  item 16-bit of unsigned 
the CONSTANT_Utf8_info structure (4.4.7).
Note that the limit is on the number of bytes in the encoding and not on
the number of encoded characters. UTF-8 encodes some characters using two
or three bytes. Thus, strings incorporating multibyte characters are further
constrained.
 The number of dimensions in an array is limited to 255 by the size of the
dimensions opcode of multianewarraythe  instruction and by the constraints
imposed on multianewarraythe , anewarray, and newarray instructions 4.9.1by 
and 4.9.2.
333
--------------------------------------- 352
4.11Limitations of the Java virtual machineTHE CLASS FILE FORMAT
334
--------------------------------------- 353
CHAPTER5
Loading, Linking, and
Initializing
THE Java virtual machine dynamically loads, links and initializes classes and
interfaces. Loading is the process of finding the binary representation of a class
or interface type with a particular creating name a class and or interface from
that binary representation. Linking is the process of taking a class or interface and
combining it into the runtime state of the Java virtual machine so that it can be
executed. Initialization of a class or interface consists of executing the class or
interface initialization method <clinit> (2.9).
In this chapter, 5.1 describes how the Java virtual machine derives symbolic
references from the binary representation of 5.2a  explains class or howinterface. 
the processes of loading, linking, and initialization are first initiated by the Java
virtual machine. 5.3 specifies how binary representations of classes and interfaces
are loaded by class loaders and how classes and interfaces are created. Linking
is described 5.4in . 5.5 details how classes and interfaces 5.6are initialized. 
introduces the notion of binding native 5.7methods.  describes Finally, when a
Java virtual machine exits.
5.1 The Runtime Constant Pool
The Java virtual machine maintains a per-type 2.5.5), constant a runtimepool (
data structure that serves many of the purposes of the symbol table of a conventional
programming language implementation.
The constant_pool table 4.4() in the binary representation of a class or interface
is used to construct the runtime constant pool upon 5.3class ). or interface creation (
All references in the runtime constant pool are initially symbolic. The symbolic
335
--------------------------------------- 354
5.1The Runtime Constant PoolLOADING, LINKING, AND INITIALIZING
references in the runtime constant pool are derived from structures in the binary
representation of the class or interface as follows:
 A symbolic reference to a class or interface is derived from a
CONSTANT_Class_info structure 4.4.1() in the binary representation of a class
or interface. Such a reference gives the name of the class or interface in the form
returned by the Class.getName method, that is:
For a nonarray class or an interface, the name 4.2.1is ) the ofbinary name (
the class or interface.
For an array class n dimensions, of the name begins n occurrences with of the
ASCII "[" character followed by a representation of the element type:
VIf the element type is a primitive type, it is represented by the corresponding
field descriptor (4.3.2).
VOtherwise, if the element type is a reference type, it is represented by the
ASCII "L" character followed by the 4.2.1binary ) of name the element(
type followed by the ASCII ";" character.
Whenever this chapter refers to the name of a class or interface, it should be
understood to be in the form returned by the Class.getName method.
 A symbolic reference to a field of a class or an interface is derived from a
CONSTANT_Fieldref_info structure 4.4.2() in the binary representation of a
class or interface. Such a reference gives the name and descriptor of the field,
as well as a symbolic reference to the class or interface in which the field is to
be found.
 A symbolic reference to a method of a class is derived from a
CONSTANT_Methodref_info structure 4.4.2() in the binary representation of a
class or interface. Such a reference gives the name and descriptor of the method,
as well as a symbolic reference to the class in which the method is to be found.
 A symbolic reference to a method of an interface is derived from
a CONSTANT_InterfaceMethodref_info structure 4.4.2() in the binary
representation of a class or interface. Such a reference gives the name and
descriptor of the interface method, as well as a symbolic reference to the interface
in which the method is to be found.
 A symbolic reference to a method handle is derived from a
CONSTANT_MethodHandle_info structure 4.4.8() in the binary representation of
a class or interface.
336
--------------------------------------- 355
LOADING, LINKING, AND INITIALIZINGThe Runtime Constant Pool5.1
 A symbolic reference to a method type is derived from a
CONSTANT_MethodType_info structure 4.4.9() in the binary representation of a
class or interface.
 A symbolic reference call to a site specifier is derived from a
CONSTANT_InvokeDynamic_info structure 4.4.10() in the binary representation
of a class or interface. Such a reference gives:
a symbolic reference to a method handle, which will serve as a bootstrap
method for an invokedynamic instruction (invokedynamic);
a sequence of symbolic references (to classes, method types, and method
handles), string literals, and runtime constants (i.e. primitive numeric values),
which will serve as static arguments to a bootstrap method;
a method name and method descriptor.
In addition, certain runtime values which are not symbolic references are derived
from items found in the constant_pool table:
 A string literal referenceis a  to an instance Stringof class , and is derived
from CONSTANT_String_infoa  structure 4.4.3() in the binary representation of
a class or interface. CONSTANT_String_infoThe  structure gives the sequence of
Unicode code points constituting the string literal.
The Java programming language requires that identical string literals (that
is, literals that contain the same sequence of code points) must refer to the
same instance of Stringclass  (JLS 3.10.5). In addition, if the method
String.intern is called on any string, referencethe result  to the is a same
class instance that would be returned if that string appeared as a literal. Thus, the
following expression must have the value true:
("a" + "b" + "c").intern() == "abc"
To derive a string literal, the Java virtual machine examines the sequence of code
points given by the CONSTANT_String_info structure.
If the method String.intern has previously been called on an instance of
class String containing a sequence of Unicode code points identical to that
given by CONSTANT_String_infothe  structure, then the result of string literal
derivation is a reference to that same instance of class String.
Otherwise, a new instance Stringof  class is created containing the sequence
of Unicode code points given CONSTANT_String_infoby the  structure; a
reference to that class instance is the result of string literal derivation. Finally,
the intern method of the new String instance is invoked.
337
--------------------------------------- 356
5.2Virtual Machine Start-upLOADING, LINKING, AND INITIALIZING
 Runtime constant values are derived CONSTANT_Integer_infofrom ,
CONSTANT_Float_info, CONSTANT_Long_info, or CONSTANT_Double_info
structures (4.4.4, 4.4.5) in the binary representation of a class or interface.
Note that CONSTANT_Float_info structures represent values in IEEE 754 single
format and CONSTANT_Double_info structures represent values in IEEE 754
double format 4.4.4(, 4.4.5). The runtime constant values derived from these
structures must thus be values that can be represented using IEEE 754 single and
double formats, respectively.
The remaining structures constant_poolin the  table of the binary representation
of a class or interface CONSTANT_NameAndType_info- the  4.4.6() and
CONSTANT_Utf8_info (4.4.7) structures - are only used indirectly when deriving
symbolic references to classes, interfaces, methods, fields, method types, and
method handles, and when deriving string literals and call site specifiers.
5.2 Virtual Machine Start-up
The Java virtual machine starts up by creating an initial class, which is specified
in an implementation-dependent manner, using the bootstrap 5.3.1).class loader (
The Java virtual machine then links the initial class, initializes it, and invokes
the public class method void main(String[]). The invocation of this method
drives all further execution. Execution of the Java virtual machine instructions
constituting mainthe  method may cause linking (and consequently creation) of
additional classes and interfaces, as well as invocation of additional methods.
In an implementation of the Java virtual machine, the initial class could be provided
as a command line argument. Alternatively, the implementation could provide an
initial class that sets up a class loader which in turn loads an application. Other
choices of the initial class are possible so long as they are consistent with the
specification given in the previous paragraph.
5.3 Creation and Loading
Creation of a class or C denoted interface by the N name consists of the construction
in the method area of the Java virtual 2.5.4) of machine an implementation-(
specific internal representation C. Class or of interface creation is triggered by
another class or interface D, which references C through its runtime constant pool.
338
--------------------------------------- 357
LOADING, LINKING, AND INITIALIZINGCreation and Loading5.3
Class or interface creation may also D invoking be triggered methods by in certain
Java class libraries (2.12) such as reflection.
If C is not an array class, it is created by loading C a (4)binary representation of 
using a class loader. Array classes do not have an external binary representation;
they are created by the Java virtual machine rather than by a class loader.
There are two kinds of class loaders: the bootstrap class loader supplied by the Java
virtual machine, and user-defined class loaders. Every user-defined class loader is
an instance of a subclass of the ClassLoaderabstract . Applications class employ
user-defined class loaders in order to extend the manner in which the Java virtual
machine dynamically loads and thereby creates classes. User-defined class loaders
can be used to create classes that originate from user-defined sources. For example,
a class could be downloaded across a network, generated on the fly, or extracted
from an encrypted file.
A class loader L may create C by defining it directly or by delegating to another
class loader. L creates If C directly, we say L definesthat  C or, equivalently, Lthat 
is the defining loader of C.
When one class loader delegates to another class loader, the loader that initiates the
loading is not necessarily the same loader that completes the loading and defines
the class. L creates If C, either by defining it directly or by delegation, we say that
L initiates loading of C or, equivalently, that L is an initiating loader of C.
At runtime, a class or interface is determined not by its name alone, but by a pair:
its binary name 4.2.1) ( and its defining class loader. Each such class or interface
belongs to a runtime single package. The runtime package of a class or interface is
determined by the package name and defining class loader of the class or interface.
The Java virtual machine uses one of three procedures to create class or interface
C denoted by N:
 If N denotes a nonarray class or an interface, one of the two following methods
is used to load and thereby create C:
If D was defined by the bootstrap class loader, then the bootstrap class loader
initiates loading of C (5.3.1).
If D was defined by a user-defined class loader, then that same user-defined
class loader initiates loading of C (5.3.2).
 Otherwise N denotes an array class. An array class is created directly by the Java
virtual machine 5.3.3), ( not by a class loader. However, the defining class loader
of D is used in the process of creating array class C.
339
--------------------------------------- 358
5.3.1 Loading Using the Bootstrap Class LoaderLOADING, LINKING, AND INITIALIZING
If an error occurs during class loading, then an instance of a subclass of
LinkageError must be thrown at a point in the program that (directly or indirectly)
uses the class or interface being loaded.
If the Java virtual machine ever attempts C during to load verificationa class 
(5.4.1) or resolution 5.4.3) ((but not initialization 5.5)), and (the class loader
that is used to initiate C throws loading an of instance ClassNotFoundExceptionof ,
then the Java virtual machine must throw NoClassDefFoundErroran instance of 
whose cause is the instance of ClassNotFoundException.
(A subtlety here is that recursive class loading to load superclasses is performed
as part of resolution 5.3.5, step (3). Therefore, ClassNotFoundExceptiona  that
results from a class loader failing to load a superclass must be wrapped in a
NoClassDefFoundError.)
Commentary: A well-behaved class loader should maintain three properties:
 Given the same name, a good class loader should always Class object.return the same 
 If a class Lloader 1 delegates loading of C to a another class loader L2, then for any type
T that occurs as the direct superclass or a Cdirect , or as superinterface the type of aof 
field Cin , or as the type of a formal parameter of a method C, or as or aconstructor in 
return type of a method in C, L1 and L2 should return the same Class object.
 If a user-defined classloader prefetches binary representations of classes and interfaces,
or loads a group of related classes together, then it must reflect loading errors only at
points in the program where they could have arisen without prefetching or group loading.
We will sometimes represent a class or interface <N, Ld>using , wherethe notation 
N denotes the name of the class or Ld denotes interface the and defining loader of
the class or interface.
Li
We will also represent a class or interface N , using where N denotesthe notation 
the name of the class or interface Li denotes and an initiating loader of the class
or interface.
5.3.1Loading Using the Bootstrap Class Loader
The following steps are used to load and thereby create the nonarray class or
interface C denoted by N using the bootstrap class loader.
First, the Java virtual machine determines whether the bootstrap class loader has
already been recorded as an initiating loader of a class N. If or interface denoted by 
so, this class or interface is C, and no class creation is necessary.
Otherwise, the Java virtual machine passes N to the an invocation argument of a
method on the bootstrap class loader to search for a purported Crepresentation of 
340
--------------------------------------- 359
LOADING, LINKING, AND INITIALIZINGLoading Using a User-defined Class 5.3.2Loader
in a platform-dependent manner. Typically, a class or interface will be represented
using a file in a hierarchical file system, and the name of the class or interface will
be encoded in the pathname of the file.
Note that there is no guarantee that a purported representation found is valid or is
a representation of C. This phase of loading must detect the following error:
 If no purported representation C is found, of loading throws an instance of
ClassNotFoundException.
Then the Java virtual machine attempts to derive N using a class the denoted by 
bootstrap class loader from the purported representation using the algorithm found
in 5.3.5. That class is C.
5.3.2Loading Using a User-defined Class Loader
The following steps are used to load and thereby create the nonarray class or
interface C denoted by N using a user-defined class loader L.
First, the Java virtual machine determines L has already whether been recorded as
an initiating loader of a class or interface N. If so, denoted this class by or interface
is C, and no class creation is necessary.
Otherwise, the Java virtual machine loadClass(invokes N) on L. The value
returned by the invocation is the created C. class The Java or interface virtual
machine then records L is that an initiating C loader (5.3.4). of The remainder of
this section describes this process in more detail.
When the loadClass method of the class L is loader invoked with the N of name a
class or interface C to be loaded, L must perform one of the following two operations
in order to load C:
1. The class loader L can create an array of bytes C as representing the bytes of
a ClassFile structure 4.1); ( it then must invoke defineClassthe method  of
class ClassLoader. Invoking defineClass causes the Java virtual machine to
derive a class or interface N using denoted L from by the array of bytes using
the algorithm found in 5.3.5.
2. The class loader L can delegate the loading C to some of other class L'.loader 
This is accomplished by passing Nthe  directly argument or indirectly to an
invocation of a method L' (typically on loadClassthe  method). The result of
the invocation is C.
In either (1) or (2), if Lthe  is class unable loader to load a class or interface denoted
by N for any reason, it must throw an instance of ClassNotFoundException.
341
--------------------------------------- 360
5.3.3 Creating Array ClassesLOADING, LINKING, AND INITIALIZING
Since JDK release 1.1, Oracles Java virtual machine implementation has invoked the
loadClass method of a class loader in order to cause it to load a class or interface.
The argument loadClassto  is the name of the class or interface to be loaded. There is
also a two-argument version loadClassof the  method, where the second argument is a
boolean that indicates whether the class or interface is to be linked or not. Only the two-
argument version was supplied in JDK release 1.0.2, and Oracles Java virtual machine
implementation relied on it to link the loaded class or interface. From JDK release 1.1
onward, Oracles Java virtual machine implementation links the class or interface directly,
without relying on the class loader.
5.3.3Creating Array Classes
The following steps are used to create C denoted the array Nby  using class class
loader L. Class loader L may be either the bootstrap class loader or a user-defined
class loader.
If L has already been recorded as an initiating loader of an array class with the same
component type as N, that class is C, and no array class creation is necessary.
Otherwise, the following steps are performed to create C:
1. If the component type referenceis a  type, the algorithm of 5.3this ) section (
is applied recursively using L in class order loader to load and thereby create
the component type of C.
2. The Java virtual machine creates a new array class with the indicated
component type and number of dimensions.
If the component type referenceis a  type, C is marked as having been defined
by the defining class loader of the component C is type. marked Otherwise, as
having been defined by the bootstrap class loader.
In any case, the Java virtual machine L then is an records initiating that loader
for C (5.3.4).
If the component type referenceis a  type, the accessibility of the array
class is determined by the accessibility of its component type. Otherwise, the
accessibility of the array class is public.
5.3.4Loading Constraints
Ensuring type safe linkage in the presence of class loaders requires special care. It is
possible that when two different class loaders initiate loading of a class or interface
denoted by N, the name N may denote a different class or interface in each loader.
When a class or interface C = <N1, L1> makes a symbolic reference to a field or
method of another class or D = <interface N2, L2>, the symbolic reference includes
342
--------------------------------------- 361
LOADING, LINKING, AND INITIALIZINGLoading Constraints5.3.4
a descriptor specifying the type of the field, or the return and argument types of
the method. It is essential that N mentioned any type name in the field or method
descriptor denote the same class or interface L1 and when when loaded loadedby 
by L2.
To ensure this, the Java virtual loading machine constraintsimposes  of the form
L1L2
N = N during preparation 5.4.2) (and resolution 5.4.3). ( To enforce these
constraints, the Java virtual machine will, at certain 5.3.1, prescribed times (see 
5.3.2, 5.3.3, and 5.3.5), record that a particular loader is an initiating loader of
a particular class. After recording that a loader is an initiating loader of a class,
the Java virtual machine must immediately check to see if any loading constraints
are violated. If so, the record is retracted, the Java virtual machine throws a
LinkageError, and the loading operation that caused the recording to take place
fails.
Similarly, after imposing a loading 5.4.2constraint , 5.4.3.2, 5.4.3.3(see , and
5.4.3.4), the Java virtual machine must immediately check to see if any loading
constraints are violated. If so, the newly imposed loading constraint is retracted,
the Java virtual machine LinkageErrorthrows a , and the operation that caused the
constraint to be imposed (either resolution or preparation, as the case may be) fails.
The situations described here are the only times at which the Java virtual machine
checks whether any loading constraints have been violated. A loading constraint is
violated if, and only if, all the following four conditions hold:
 There exists a L loader such that L has been recorded by the Java virtual machine
as an initiating loader of a class C named N.
 There exists a L' loader such that L' has been recorded by the Java virtual machine
as an initiating loader of a class C ' named N.
 The equivalence relation defined by the (transitive closure of the) set of imposed
LL'
constraints implies N = N.
C ` C '.
A full discussion of class loaders and type safety is beyond the scope of this specification.
For a more comprehensive discussion, readers Dynamic are referred Class Loading to in
the Java Virtual  Machineby Sheng Liang and Gilad Proceedings Bracha ( of the 1998
ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and
Applications).
343
--------------------------------------- 362
5.3.5 Deriving a Class classfrom  File a RepresentationLOADING, LINKING, AND INITIALIZING
5.3.5Deriving a Class from a class File Representation
The following steps are used Classto  derive object a for the nonarray class or
interface C denoted Nby  using loader L from a purported representation classin 
file format.
1. First, the Java virtual machine determines whether it has already recorded that
L is an initiating loader of a class or N. interface If so, this denoted creationby 
attempt is invalid and loading throws a LinkageError.
2. Otherwise, the Java virtual machine attempts to parse the purported
representation. However, the purported representation may not in fact be a
valid representation of C.
This phase of loading must detect the following errors:
 If the purported representation ClassFileis  structure not a 4.1, (4.8),
loading throws an instance of ClassFormatError.
 Otherwise, if the purported representation is not of a supported
major or minor version 4.1), (loading throws an instance of
UnsupportedClassVersionError.
UnsupportedClassVersionError, a subclass ClassFormatErrorof , was
introduced to enable easy identification ClassFormatErrorof a  caused by
an attempt to load a class whose representation uses an unsupported version
of the class file format. In JDK release 1.1 and earlier, an instance of
NoClassDefFoundError or ClassFormatError was thrown in case of an
unsupported version, depending on whether the class was being loaded by the
system class loader or a user-defined class loader.
 Otherwise, if the purported representation does not actually represent a
class named N, loading throws an instance NoClassDefFoundErrorof  or an
instance of one of its subclasses.
3. If C has a direct superclass, the symbolic C to reference its direct from superclass
is resolved using the algorithm 5.4.3.1. Note of that C is if an interface it must
have Object as its direct superclass, which must already have been loaded.
Only Object has no direct superclass.
Any exceptions that can be thrown due to class or interface resolution can be
thrown as a result of this phase of loading. In addition, this phase of loading
must detect the following errors:
 If the class or interface named as the Cdirect  is in superclass fact anof 
interface, loading throws an IncompatibleClassChangeError.
344
--------------------------------------- 363
LOADING, LINKING, AND INITIALIZINGLinking5.4
 Otherwise, if any of the superclasses C is C itself, of loading throws a
ClassCircularityError.
4. If C has any direct superinterfaces, the symbolic C to its references direct from 
superinterfaces are resolved using the algorithm of 5.4.3.1.
Any exceptions that can be thrown due to class or interface resolution can be
thrown as a result of this phase of loading. In addition, this phase of loading
must detect the following errors:
 If any of the classes or interfaces named as direct C is notsuperinterfaces of 
in fact an interface, loading throws an IncompatibleClassChangeError.
 Otherwise, if any of the superinterfaces C is C itself, of loading throws a
ClassCircularityError.
5. The Java virtual machine C as marks having L as its defining class loader and
records that L is an initiating loader of C (5.3.4).
5.4 Linking
Linking a class or interface involves verifying and preparing that class or interface,
its direct superclass, its direct superinterfaces, and its element type (if it is an array
type), if necessary. Resolution of symbolic references in the class or interface is
an optional part of linking.
This specification allows an implementation flexibility as to when linking activities
(and, because of recursion, loading) take place, provided that all of the following
properties are maintained:
 A class or interface is completely loaded before it is linked.
 A class or interface is completely verified and prepared before it is initialized.
 Errors detected during linkage are thrown at a point in the program where some
action is taken by the program that might, directly or indirectly, require linkage
to the class or interface involved in the error.
For example, a Java virtual machine implementation may choose to resolve each
symbolic reference in a class or interface individually when it is used ("lazy"
or "late" resolution), or to resolve them all at once when the class is being
verified ("eager" or "static" resolution). This means that the resolution process may
continue, in some implementations, after a class or interface has been initialized.
Whichever strategy is followed, any error detected during resolution must be
345
--------------------------------------- 364
5.4.1 VerificationLOADING, LINKING, AND INITIALIZING
thrown at a point in the program that (directly or indirectly) uses a symbolic
reference to the class or interface.
Because linking involves the allocation of new data structures, it may fail with an
OutOfMemoryError.
5.4.1Verification
Verification (4.10) ensures that the binary representation of a class or interface is
structurally correct 4.9). Verification (may cause additional classes and interfaces
to be loaded (5.3) but need not cause them to be verified or prepared.
If the binary representation of a class or interface does not satisfy the static or
structural constraints 4.9, listed then VerifyErrora in  must be thrown at the point
in the program that caused the class or interface to be verified.
If an attempt by the Java virtual machine to verify a class or interface fails because
an error is thrown that is an LinkageErrorinstance  (or of a subclass), then
subsequent attempts to verify the class or interface always fail with the same error
that was thrown as a result of the initial verification attempt.
5.4.2Preparation
Preparation involves creating the static fields for a class or interface and initializing
such fields to their default 2.3, 2.4values ). This ( does not require the execution
of any Java virtual machine code; explicit initializers for static fields are executed
as part of initialization (5.5), not preparation.
During preparation of a class C, or the interface Java virtual machine also imposes
loading constraints 5.3.4). (Let L1 be the defining loader C. For of each method
m declared C in that overrides 5.4.5) (a method declared in a superclass or
superinterface <D, L2>, the Java virtual machine imposes the following loading
constraints:
Given that the return m is type Tr, and of that the formal parameter m are types of 
Tf1, ..., Tfn, then:
If Tr not an array type, T0 be Tr; let otherwise, T0 be let the element 2.4type ) of Tr(.
For i = 1 nto : If Tfi is not an array Ttype, i be Tfi; let otherwise, Ti be let the
element type (2.4) of Tfi.
L1L2
Then Ti = Ti for i = 0 to n.
346
--------------------------------------- 365
LOADING, LINKING, AND INITIALIZINGResolution5.4.3
Furthermore, C implements if a method m declared in a superinterface <I, L3> of C,
but C does not itself declare m, the then method <Dlet , L2> be the superclass C thatof 
declares the implementation of method m inherited by C. The Java virtual machine
imposes the following constraints:
Given that the return m is type Tr, and of that the formal parameter m are types of 
Tf1, ..., Tfn, then:
If Tr not an array type, T0 be Tr; let otherwise, T0 be let the element 2.4type ) of Tr(.
For i = 1 nto : If Tfi is not an array Ttype, i be Tfi; let otherwise, Ti be let the
element type (2.4) of Tfi.
L2L3
Then Ti = Ti for i = 0 to n.
Preparation may occur at any time following creation but must be completed prior
to initialization.
5.4.3Resolution
The Java virtual machine instructions anewarray, checkcast, getfield,
getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic,
invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic make
symbolic references to the runtime constant pool. Execution of any of these
instructions requires resolution of its symbolic reference.
Resolution is the process of dynamically determining concrete values from
symbolic references in the runtime constant pool.
Resolution of the symbolic reference of one invokedynamicoccurrence of an 
instruction does not imply that the same symbolic reference is considered resolved
for any other invokedynamic instruction.
For all other instructions above, resolution of the symbolic reference of one
occurrence of an instruction does imply that the same symbolic reference is
considered resolved for any other non-invokedynamic instruction.
(The above text implies that the concrete value determined by resolution for a
specific invokedynamic instruction is a call site object bound to that specific
invokedynamic instruction.)
Resolution can be attempted on a symbolic reference that has already been
resolved. An attempt to resolve a symbolic reference that has already successfully
been resolved always succeeds trivially and always results in the same entity
produced by the initial resolution of that reference.
347
--------------------------------------- 366
5.4.3 ResolutionLOADING, LINKING, AND INITIALIZING
If an error occurs during resolution of a symbolic reference, then an instance of
IncompatibleClassChangeError (or a subclass) must be thrown at a point in the
program that (directly or indirectly) uses the symbolic reference.
If an attempt by the Java virtual machine to resolve a symbolic reference fails
because an error is thrown that LinkageErroris an instance  (or a of subclass), then
subsequent attempts to resolve the reference always fail with the same error that
was thrown as a result of the initial resolution attempt.
A symbolic reference to a call site specifier invokedynamicby  instructiona specific 
must not be resolved prior to execution of that instruction.
In the case of failed resolution invokedynamicof  instruction, an the bootstrap
method is not re-executed on subsequent resolution attempts.
Certain of the instructions above require additional linking checks when resolving
symbolic references. For instance, getfieldin  order instruction for a to successfully
resolve the symbolic reference to the field on which it operates, it must not only
complete the field resolution 5.4.3.2steps  but given also in check that the field is
not static. If it is a static field, a linking exception must be thrown.
Notably, in order invokedynamicfor an  instruction to successfully resolve the
symbolic reference to a call site specifier, the bootstrap method specified therein
must complete normally and return a suitable call site object. If the bootstrap
method completes abruptly or returns an unsuitable call site object, a linking
exception must be thrown.
Linking exceptions generated by checks that are specific to the execution of a
particular Java virtual machine instruction are given in the description of that
instruction and are not covered in this general discussion of resolution. Note
that such exceptions, although described as part of the execution of Java virtual
machine instructions rather than resolution, are still properly considered failures
of resolution.
The following sections describe the process of resolving a symbolic reference in
the runtime constant 5.1) pool of a ( class or Dinterface . Details of resolution differ
with the kind of symbolic reference to be resolved.
5.4.3.1Class and Interface Resolution
To resolve an unresolved symbolic Dreference  to a class from or Cinterface  denoted
by N, the following steps are performed:
1. The defining class loader D is used of to create a class or interface denoted by
N. This class or interface is C. The details of the process are given in 5.3.
348
--------------------------------------- 367
LOADING, LINKING, AND INITIALIZINGResolution5.4.3
Any exception that can be thrown as a result of failure of class or interface
creation can thus be thrown as a result of failure of class and interface
resolution.
2. If C is an array class and its element reference type type, is then a the symbolic
reference to the class or interface representing the element type is resolved by
invoking the algorithm in 5.4.3.1 recursively.
3. Finally, access permissions to C are checked:
 If C is not accessible 5.4.4) to (D, class or interface resolution throws an
IllegalAccessError.
This condition can occur, for C is example, a class if that was originally declared to
be public but was changed to be non-public after D was compiled.
If steps 1 and 2 succeed but C is step still 3 fails, valid and usable. Nevertheless,
resolution fails, and D is prohibited from accessing C.
5.4.3.2Field Resolution
To resolve an unresolved symbolic Dreference  to a field from in a class or interface
C, the symbolic reference C given to by the field reference must first be resolved
(5.4.3.1). Therefore, any exception that can be thrown as a result of failure of
resolution of a class or interface reference can be thrown as a result of field
resolution. If the reference C can be successfully to resolved, an exception relating
to the failure of resolution of the field reference itself can be thrown.
When resolving a field reference, field resolution first attempts to look up the
referenced field in C and its superclasses:
1. If C declares a field with the name and descriptor specified by the field
reference, field lookup succeeds. The declared field is the result of the field
lookup.
2. Otherwise, field lookup is applied recursively to the direct superinterfaces of
the specified class or interface C.
3. Otherwise, if C has a superclass S, field lookup is applied recursively to S.
4. Otherwise, field lookup fails.
Then:
 If field lookup fails, field resolution throws a NoSuchFieldError.
349
--------------------------------------- 368
5.4.3 ResolutionLOADING, LINKING, AND INITIALIZING
 Otherwise, if field lookup succeeds but the referenced field is not accessible
(5.4.4) to D, field resolution throws an IllegalAccessError.
 Otherwise, <Elet , L1> be the class or interface in which the referenced field is
actually declared and let L2 be the defining loader of D.
Given that the type of the referenced Tf, let T be Tfield f if Tf is is not an array
type, and let T be the element type (2.4) of Tf otherwise.
L1L2
The Java virtual machine must impose the loading T = Tconstraint that 
(5.3.4).
5.4.3.3Method Resolution
To resolve an unresolved symbolic Dreference  to a method from in Ca , class the
symbolic reference C given to by the method reference is 5.4.3.1first ). resolved (
Therefore, any exception that can be thrown as a result of failure of resolution of
a class reference can be thrown as a result of method resolution. If the reference to
C can be successfully resolved, exceptions relating to the resolution of the method
reference itself can be thrown.
When resolving a method reference:
1. Method resolution checks whether C is a class or an interface.
 If C is an interface, method resolution throws an
IncompatibleClassChangeError.
2. Method resolution attempts to look up the referenced C and its method in 
superclasses:
 If C declares exactly one method with the name specified by the method
reference, and the declaration is a signature 2.9polymorphic ), thenmethod (
method lookup succeeds. All the class names mentioned in the descriptor
are resolved (5.4.3.1).
The resolved method is the signature polymorphic  It method isdeclaration.
not necessary C to for declare a method with the descriptor specified by the
method reference.
 Otherwise, C declares if a method with the name and descriptor specified by
the method reference, method lookup succeeds.
 Otherwise, C if has a superclass, step 2 of method lookup is recursively
invoked on the direct superclass of C.
350
--------------------------------------- 369
LOADING, LINKING, AND INITIALIZINGResolution5.4.3
3. Otherwise, method lookup attempts to locate the referenced method in any of
the superinterfaces of the specified class C.
 If any superinterface C declares of a method with the name and descriptor
specified by the method reference, method lookup succeeds.
 Otherwise, method lookup fails.
Then:
 If method lookup fails, method resolution throws a NoSuchMethodError.
 Otherwise, if method lookup succeeds and abstractthe , method but C is is not
abstract, method resolution throws an AbstractMethodError.
 Otherwise, if method lookup succeeds but the referenced method is not
accessible (5.4.4) to D, method resolution throws an IllegalAccessError.
 Otherwise, <Elet , L1> be the class or interface in which the m referenced method 
is actually declared, and let L2 be the defining loader of D.
Given that the return m is type Tr, and of that the formal parameter mtypes of 
are Tf1, ..., Tfn, then:
If Tr is not an array T0type,  be Tr; let otherwise, T0 be let the element 2.4type )(
of Tr.
For i = 1 nto : If Tfi is not an array Ttype, i be Tfi; let otherwise, Ti be let the
element type (2.4) of Tfi.
L1L2
The Java virtual machine must impose the loading Ti = Ti constraints  for i
= 0 to n (5.3.4).
5.4.3.4Interface Method Resolution
To resolve an unresolved symbolic reference D to an interface from method in an
interface C, the symbolic reference C given to by the interface method reference is
first resolved 5.4.3.1(). Therefore, any exception that can be thrown as a result of
failure of resolution of an interface reference can be thrown as a result of interface
method resolution. If the Creference  can be successfully to resolved, exceptions
relating to the resolution of the interface method reference itself can be thrown.
When resolving an interface method reference:
 If C is not an interface, interface method resolution throws an
IncompatibleClassChangeError.
351
--------------------------------------- 370
5.4.3 ResolutionLOADING, LINKING, AND INITIALIZING
 Otherwise, if the referenced method does not have the same name and descriptor
as a method C or in in one of the superinterfaces C, or in Objectclass of , interface
method resolution throws a NoSuchMethodError.
 Otherwise, <Elet , L1> be the class or interface in which the referenced interface
method m is actually declared, and let L2 be the defining loader of D.
Given that the return m is type Tr, and of that the formal parameter mtypes of 
are Tf1, ..., Tfn, then:
If Tr is not an array T0type,  be Tr; let otherwise, T0 be let the element 2.4type )(
of Tr.
For i = 1 nto : If Tfi is not an array Ttype, i be Tfi; let otherwise, Ti be let the
element type (2.4) of Tfi.
L1L2
The Java virtual machine must impose the loading Ti = Ti constraints  for i
= 0 to n (5.3.4).
5.4.3.5Method Type and Method Handle Resolution
To resolve an unresolved symbolic reference to a method type, all symbolic
references to classes mentioned in the method descriptor encapsulated by the
method type are resolved 5.4.3.1). (Therefore, any exception that can be thrown
as a result of failure of resolution of a class reference can be thrown as a result of
method type resolution.
The result of method type resolution reference is to a an instance of
java.lang.invoke.MethodType which represents the method descriptor.
Resolution of an unresolved symbolic reference to a method handle is more
complicated. Each method handle resolved by the Java virtual machine has an
equivalent instruction sequence bytecode called behaviorits , indicated by the
method handle's kind. The integer values and descriptions of the nine kinds of
method handle are given in Table 5.1.
Symbolic references by an instruction sequence to fields or methods are indicated
by C.x:T, where x and T are the name and descriptor 4.3.2, 4.3.3) ( of the field or
method, and C is the class or interface in which the field or method is to be found.
352
--------------------------------------- 371
LOADING, LINKING, AND INITIALIZINGResolution5.4.3
Table 5.1. Bytecode Behaviors for Method Handles
KindDescriptionInterpretation
1REF_getFieldgetfield C.f:T
2REF_getStaticgetstatic C.f:T
3REF_putFieldputfield C.f:T
4REF_putStaticputstatic C.f:T
5REF_invokeVirtualinvokevirtual C.m:(A*)T
6REF_invokeStaticinvokestatic C.m:(A*)T
7REF_invokeSpecialinvokespecial C.m:(A*)T
8REF_newInvokeSpecial new C; dup; invokespecial
C.<init>:(A*)void
9REF_invokeInterfaceinvokeinterface C.m:(A*)T
Let MH be the symbolic reference to a method handle (5.1) being resolved. Then:
 Let R be the symbolic reference to the field or method contained within MH.
(R is derived from CONSTANT_Fieldrefthe , CONSTANT_Methodref, or
CONSTANT_InterfaceMethodref structure referred reference_indexto by the 
item of the CONSTANT_MethodHandle from which MH is derived.)
 Let C be a symbolic reference to the type referenced by R.
(C is derived from CONSTANT_Classthe  structure referred to by the
class_index item in CONSTANT_Fieldrefthe , CONSTANT_Methodref, or
CONSTANT_InterfaceMethodref represented by R.)
 Let f or m be the name of the field or method referenced by R.
(f or m is derived from CONSTANT_NameAndTypethe  structure referred to by the
name_and_type_index item in CONSTANT_Fieldrefthe , CONSTANT_Methodref,
or CONSTANT_InterfaceMethodref structure from which R is derived.)
 Let T and (in the case of Aa * method) be the return type and argument type
sequence of the field or method referenced by R.
(T and A* are derived from CONSTANT_NameAndTypethe  structure
referred to by name_and_type_indexthe  item in CONSTANT_Fieldrefthe ,
CONSTANT_Methodref, or CONSTANT_InterfaceMethodref structure from
which R is derived.)
353
--------------------------------------- 372
5.4.3 ResolutionLOADING, LINKING, AND INITIALIZING
To resolve MH, all symbolic references to classes, fields, MH'sand methods in 
bytecode behavior are 5.4.3.1resolved , 5.4.3.2( , 5.4.3.3, 5.4.3.4). That C,is, 
f, m, T, and A* are resolved. Therefore, any exception that can be thrown as a result
of failure of resolution of a symbolic reference to a class, field, method, or interface
method can be thrown as a result of method handle resolution.
(In general, resolving a method handle can be done in exactly the same
circumstances that the Java virtual machine would successfully resolve the
symbolic references in the bytecode behavior. In particular, method handles to
private and protected members can be created in exactly those classes for which
the corresponding normal accesses are legal.)
If all such symbolic references can be referenceresolved,  to an then instancea 
of java.lang.invoke.MethodType is obtained as if by resolution of a symbolic
reference to the method descriptor (4.3.3) given for the kind of MH in Table 5.2.
Table 5.2. Method Descriptors for Method Handles
KindDescriptionMethod descriptor
1REF_getField(C)T
2REF_getStatic()T
3REF_putField(C,T)V
4REF_putStatic(T)V
5REF_invokeVirtual(C,A*)T
6REF_invokeStatic(A*)T
7REF_invokeSpecial(C,A*)T
8REF_newInvokeSpecial (A*)C
9REF_invokeInterface(C,A*)T
The result of method handle resolution reference o is to a an instance of
java.lang.invoke.MethodHandle which represents the method MH. If handle the
method m has the ACC_VARARGS flag set 4.6), ( then o is a variable arity method
handle; otherwise, o is a fixed arity method handle.
(A variable arity method handle performs argument list boxing (JLS 15.12.4.2)
when invoked invokevia , while its behavior with invokeExactrespect  is to as if
the ACC_VARARGS flag were not set.)
Method handle resolution IncompatibleClassChangeErrorthrows an  if m has the
ACC_VARARGS flag set and m's either argument type sequence is empty or the last
354
--------------------------------------- 373
LOADING, LINKING, AND INITIALIZINGResolution5.4.3
parameter m's in argument type sequence is not an array type. (That is, creation of
a variable arity method handle fails.)
The type descriptor java.lang.invoke.MethodHandleof the  instance referenced
by o is the java.lang.invoke.MethodType instance produced by method type
resolution mentioned earlier.
(The type descriptor of a method handle is such invokeExactthat a valid call to 
in java.lang.invoke.MethodHandle on the method handle has exactly the same
stack effects as the bytecode behavior. Calling this method handle on a valid set
of arguments has exactly the same effect and returns the same result (if any) as the
corresponding bytecode behavior.)
An implementation of the Java virtual machine is not required to intern
method types or method handles. That is, two distinct symbolic references
to method types or method handles which are structurally identical might
not resolve to the same instance java.lang.invoke.MethodTypeof  or
java.lang.invoke.MethodHandle respectively.
The java.lang.invoke.MethodHandles class in the Java SE platform API allows
creation of method handles with no bytecode behavior. Their behavior is defined by
the method java.lang.invoke.MethodHandlesof  that creates them. For example, a
method handle may, when invoked, first apply transformations to its argument values, then
supply the transformed values to the invocation of another method handle, then apply a
transformation to the value returned from that invocation, then return the transformed value
as its own result.
5.4.3.6Call Site Specifier Resolution
To resolve an unresolved symbolic reference to a call site specifier involves three
steps:
 A call site specifier gives a symbolic reference to a method handle which
is to serve as bootstrap the method for a dynamic call site. The method
handle is resolved 5.4.3.5) ( to obtain a reference to an instance of
java.lang.invoke.MethodHandle.
 A call site specifier gives a method TD. A descriptor, reference to an instance
of java.lang.invoke.MethodType is obtained as if by resolution of a symbolic
reference to a method 5.4.3.5type ) with (the same parameter and return types
as TD.
 A call site specifier gives static zero or argumentsmore , which communicate
application-specific metadata to the bootstrap method. Any static arguments
which are symbolic references to classes, method handles, or method types
are resolved, as if by invocation ldc instruction of the ldc), ( to obtain
355
--------------------------------------- 374
5.4.4 Access ControlLOADING, LINKING, AND INITIALIZING
references Classto  objects, java.lang.invoke.MethodHandle objects, and
java.lang.invoke.MethodType objects respectively. Any static arguments that
are string literals are used to obtain references to String objects.
The result of call site specifier resolution is a tuple consisting of:
 the reference to an instance of java.lang.invoke.MethodHandle,
 the reference to an instance of java.lang.invoke.MethodType,
 the references to instances Classof , java.lang.invoke.MethodHandle,
java.lang.invoke.MethodType, and String.
During resolution of the symbolic reference to the method handle in the call site
specifier, or resolution of the symbolic reference to the method type for the method
descriptor in the call site specifier, or resolution of a symbolic reference to any
static argument, any of the exceptions pertaining to method type or method handle
resolution (5.4.3.5) may be thrown.
5.4.4Access Control
A class or interface C is accessible to a class or interface D if and only if either of
the following conditions is true:
C is public.
C and D are members of the same runtime package (5.3).
A field or method R is accessible to a class D if or and interface only if any of the
following conditions are true:
R is public.
R is protected and is declared in C, a and class D is either a subclass C orof 
C itself. Furthermore, R is not staticif , then the symbolic reference R mustto 
contain a symbolic reference T, to such a that class T is either a subclass D, aof 
superclass of D, or D itself.
R is either protected or has default access (that publicis,  nor protectedneither 
nor private), and is declared by a class in the same runtime package as D.
R is private and is declared in D.
This discussion of access control omits a related restriction on the target of a
protected field access or method invocation (the target D ormust be of class 
a subtype D). of That requirement is checked as part of the verification process
(5.4.1); it is not part of link-time access control.
356
--------------------------------------- 375
LOADING, LINKING, AND INITIALIZINGMethod overriding5.4.5
5.4.5Method overriding
An instance method m1 declared in C class overrides another instance m2method 
declared in class A iff all of the following are true:
C is a subclass of A.
m2 has the same name and descriptor as m1.
 Either:
m2 is marked ACC_PUBLIC; or is marked ACC_PROTECTED; or is marked neither
ACC_PUBLIC nor ACC_PROTECTED nor ACC_PRIVATE and belongs to the same
runtime package as C, or
m1 overrides a method m3, m3 distinct mfrom 1, m3 distinct mfrom 2, such that m3
overrides m2.
5.5 Initialization
Initialization of a class or interface consists of executing its class or interface
initialization method (2.9).
A class or interface may be initialized only as a result of:
 The execution of any one of the Java virtual newmachine , getstatic,instructions 
putstatic, or invokestatic that references the class newor , interface getstatic,(
putstatic, invokestatic). All of these instructions reference a class directly or
indirectly through either a field reference or a method reference.
Upon execution newof  a instruction, the referenced class or interface is
initialized if it has not been initialized already.
Upon execution getstaticof a , putstatic, or invokestatic instruction, the class or
interface that declared the resolved field or method is initialized if it has not been
initialized already.
 The first invocation java.lang.invoke.MethodHandleof a  instance which
was the result of resolution of a method handle by the Java virtual machine
(5.4.3.5) and which has a kind REF_getStaticof 2 ( ), 4 REF_putStatic(), or
6 (REF_invokeStatic).
 Invocation of certain reflective methods 2.12in ), the for class example,library (
in class Class or in package java.lang.reflect.
 The initialization of one of its subclasses.
357
--------------------------------------- 376
5.5InitializationLOADING, LINKING, AND INITIALIZING
 Its designation as the initial class at Java virtual machine start-up (5.2).
Prior to initialization, a class or interface must be linked, that is, verified, prepared,
and optionally resolved.
Because the Java virtual machine is multithreaded, initialization of a class or
interface requires careful synchronization, since some other thread may be trying
to initialize the same class or interface at the same time. There is also the possibility
that initialization of a class or interface may be requested recursively as part
of the initialization of that class or interface. The implementation of the Java
virtual machine is responsible for taking care of synchronization and recursive
initialization by using the following procedure. ClassIt  objectassumes that the 
has already been verified and prepared, Class and object that contains the state
that indicates one of four situations:
 This Class object is verified and prepared but not initialized.
 This Class object is being initialized by some particular thread.
 This Class object is fully initialized and ready for use.
 This Class object is in an erroneous state, perhaps because initialization was
attempted and failed.
For each class or Cinterface , there is a unique initialization LC. The mappinglock 
from C to LC is left to the discretion of the Java virtual machine implementation.
For example, LC could be Classthe  object Cfor , or the monitor associated with
that Class object. The procedure for initializing C is then as follows:
1. Synchronize on the initialization LC, for C. This lock, involves waiting until the
current thread can acquire LC.
2. If the Class object Cfor  indicates that initialization C is by in someprogress for 
other thread, then LC release and block the current thread until informed that the
in-progress initialization has completed, at which time repeat this procedure.
3. If the Class object Cfor  indicates that initialization C is by in theprogress for 
current thread, then this must be a recursive request for initialization. Release
LC and complete normally.
4. If the Class object Cfor  indicates C that has already been initialized, then no
further action is required. Release LC and complete normally.
5. If the Class object Cfor  is in an erroneous state, then initialization is not
possible. Release LC and throw a NoClassDefFoundError.
6. Otherwise, record the fact that initialization Class object Cfor  of is the in
progress by the current thread, LC. and Then, release initialize finaleach 
358
--------------------------------------- 377
LOADING, LINKING, AND INITIALIZINGInitialization5.5
static field C of with the constant value ConstantValuein its  attribute
(4.7.2), in the order the fields appear in the ClassFile structure.
7. Next, Cif  is a class rather than an interface, SC and has its not superclass 
yet been initialized, then recursively perform this SC. Ifentire procedure for 
necessary, verify and prepare SC first.
If the initialization SC completes of abruptly because of a thrown exception,
then acquire LC, label Classthe  object Cfor  as erroneous, notify all waiting
threads, release LC, and complete abruptly, throwing the same exception that
resulted from initializing SC.
8. Next, determine whether assertions Care  by enabled querying for its defining
class loader.
9. Next, execute the class or interface initialization method of C.
10.If the execution of the class or interface initialization method completes
normally, then acquire LC, label Classthe  object C for as fully initialized, notify
all waiting threads, release LC, and complete this procedure normally.
11.Otherwise, the class or interface initialization method must have completed
abruptly by throwing some Eexception . If the class E is of not Error
or one of its subclasses, then create a new instance of the class
ExceptionInInitializerError with E as the argument, and use this object
in place of E in the following step.
If a new instance ExceptionInInitializerErrorof  cannot be created
because OutOfMemoryErroran  occurs, then OutOfMemoryErroruse an  object
in place of E in the following step.
12.Acquire LC, label Classthe  object Cfor  as erroneous, notify all waiting
threads, release LC, and complete this procedure abruptly E or with its reason 
replacement as determined in the previous step.
A Java virtual machine implementation may optimize this procedure by eliding the
lock acquisition in step 1 (and release in step 4/5) when it can determine that the
initialization of the class has already completed, provided that, in terms of the Java
memory model, happens-beforeall  orderings (JLS 17.4.5) that would exist if the
lock were acquired, still exist when the optimization is performed.
359
--------------------------------------- 378
5.6Binding Native Method ImplementationsLOADING, LINKING, AND INITIALIZING
5.6 Binding Native Method Implementations
Binding is the process by which a function written in a language other than the
Java programming language and implementing native method a is integrated
into the Java virtual machine so that it can be executed. Although this process is
traditionally referred to as linking, the term binding is used in the specification to
avoid confusion with linking of classes or interfaces by the Java virtual machine.
5.7 Virtual Machine Exit
The Java virtual machine exits when some exitthread  method invokes of classthe 
Runtime or class System, or the halt method of class Runtime, and the exit or
halt operation is permitted by the security manager.
In addition, the JNI (Java Native Interface) Specification describes termination of
the Java virtual machine when the JNI Invocation API is used to load and unload
the Java virtual machine.
360
--------------------------------------- 379
CHAPTER6
The Java Virtual Machine
Instruction Set
A Java virtual machine instruction consists of an opcode specifying the operation
to be performed, followed by zero or more operands embodying values to be
operated upon. This chapter gives details about the format of each Java virtual
machine instruction and the operation it performs.
6.1 Assumptions: The Meaning of "Must"
The description of each instruction is always given in the context of Java virtual
machine code that satisfies the static and structural 4. In theconstraints of 
description of individual Java virtual machine instructions, we frequently state that
some situation "must" or "must not" value2be the  must case: be "The of inttype ."
The constraints 4 guarantee of that all such expectations will in fact be met. If
some constraint (a "must" or "must not") in an instruction description is not satisfied
at runtime, the behavior of the Java virtual machine is undefined.
The Java virtual machine checks that Java virtual machine code satisfies the static
and structural constraints at link class time file using verifier 4.10a ). (Thus,
a Java virtual machine will only attempt to execute class files.code from valid 
Performing verification at link time is attractive in that the checks are performed
just once, substantially reducing the amount of work that must be done at runtime.
Other implementation strategies are possible, provided Thethat they comply with 
Java Language Specification and The Java Virtual Machine Specification.
361
--------------------------------------- 380
6.2Reserved OpcodesTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
6.2 Reserved Opcodes
In addition to the opcodes of the instructions specified later in this chapter, which
are used classin  files 4), ( three opcodes are reserved for internal use by a Java
virtual machine implementation. If the instruction set of the Java virtual machine
is extended in the future, these reserved opcodes are guaranteed not to be used.
Two of the reserved opcodes, numbers 254 (0xfe) and 255 (0xff), have
the mnemonics impdep1 and impdep2, respectively. These instructions are
intended to provide "back doors" or traps to implementation-specific functionality
implemented in software and hardware, respectively. The third reserved opcode,
number 202 (0xca), has the breakpointmnemonic  and is intended to be used by
debuggers to implement breakpoints.
Although these opcodes have been reserved, they may be used only inside a Java
virtual machine implementation. They cannot classappear  files. in Toolsvalid 
such as debuggers or JIT code 2.13generators ) that might (directly interact with
Java virtual machine code that has been already loaded and executed may encounter
these opcodes. Such tools should attempt to behave gracefully if they encounter
any of these reserved instructions.
6.3 Virtual Machine Errors
A Java virtual machine implementation throws an object that is an instance of
a subclass of the VirtualMethodErrorclass  when an internal error or resource
limitation prevents it from implementing the semantics described in this chapter.
This specification cannot predict where internal errors or resource limitations may
be encountered and does not mandate precisely when they can be reported. Thus,
any of the VirtualMethodError subclasses defined below may be thrown at any
time during the operation of the Java virtual machine:
InternalError: An internal error has occurred in the Java virtual machine
implementation because of a fault in the software implementing the virtual
machine, a fault in the underlying host system software, or a fault in the hardware.
This error is delivered asynchronously 2.10) when it (is detected and may occur
at any point in a program.
OutOfMemoryError: The Java virtual machine implementation has run out of
either virtual or physical memory, and the automatic storage manager was unable
to reclaim enough memory to satisfy an object creation request.
362
--------------------------------------- 381
THE JAVA VIRTUAL MACHINE INSTRUCTION SETFormat of Instruction Descriptions6.4
StackOverflowError: The Java virtual machine implementation has run out of
stack space for a thread, typically because the thread is doing an unbounded
number of recursive invocations as a result of a fault in the executing program.
UnknownError: An exception or error has occurred, but the Java virtual machine
implementation is unable to report the actual exception or error.
6.4 Format of Instruction Descriptions
Java virtual machine instructions are represented in this chapter by entries of the
form shown below, in alphabetical order and each beginning on a new page.
363
--------------------------------------- 382
mnemonicTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
mnemonicmnemonic
Operation Short description of the instruction
Formatmnemonic
operand1
operand2
...
Formsmnemonic = opcode
Operand..., value1, value2 
Stack..., value3
DescriptionA longer description detailing constraints on operand stack
contents or constant pool entries, the operation performed, the type
of the results, etc.
LinkingIf any linking exceptions may be thrown by the execution of this
Exceptionsinstruction, they are set off one to a line, in the order in which they
must be thrown.
RuntimeIf any runtime exceptions can be thrown by the execution of an
instruction, they are set off one to a line, in the order in which they
Exceptions
must be thrown.
Other than the linking and runtime exceptions, if any, listed for an
instruction, that instruction must not throw any runtime exceptions
except for instances of VirtualMethodError or its subclasses.
NotesComments not strictly part of the specification of an instruction
are set aside as notes at the end of the description.
364
--------------------------------------- 383
THE JAVA VIRTUAL MACHINE INSTRUCTION SETmnemonic
Each cell in the instruction format diagram represents a single 8-bit byte. The
instruction's mnemonic is its name. Its opcode is its numeric representation and is
given in both decimal and hexadecimal forms. Only the numeric representation is
actually present in the Java virtual machine code in a class file.
Keep in mind that there are "operands" generated at compile-time and embedded
within Java virtual machine instructions, as well as "operands" calculated at
runtime and supplied on the operand stack. Although they are supplied from
several different areas, all these operands represent the same thing: values to be
operated upon by the Java virtual machine instruction being executed. By implicitly
taking many of its operands from its operand stack, rather than representing them
explicitly in its compiled code as additional operand bytes, register numbers, etc.,
the Java virtual machine's code stays compact.
Some instructions are presented as members of a family of related instructions
sharing a single description, format, and operand stack diagram. As such, a family
of instructions includes several opcodes and opcode mnemonics; only the family
mnemonic appears in the instruction format diagram, and a separate forms line
lists all member mnemonics and opcodes. For example, the Forms line for the
lconst_<l> family of instructions, giving mnemonic and opcode information for
the two instructions in that family (lconst_0 and lconst_1), is
lconst_0 = 9 (0x9)
lconst_1 = 10 (0xa)
In the description of the Java virtual machine instructions, the effect of an
instruction's execution on the 2.6.2operand ) of stack the current (2.6frame )(
is represented textually, with the stack growing from left to right and each value
represented separately. Thus,
..., value1, value2 
..., result
shows an operation that begins value2by  on having top of the operand stack with
value1 just beneath it. As a result of the execution value1 of andthe instruction, 
value2 are popped from the operand stack resultand  replaced value, which by has
been calculated by the instruction. The remainder of the operand stack, represented
by an ellipsis (...), is unaffected by the instruction's execution.
Values of types long and double are represented by a single entry on the operand
stack.
In the first edition The Java of Virtual Machine Specification, values on the operand
stack of types long and double were each represented in the stack diagram by two entries.
365
--------------------------------------- 384
6.5InstructionsTHE JAVA VIRTUAL MACHINE INSTRUCTION SET6.5 Instructions
366
--------------------------------------- 385
THE JAVA VIRTUAL MACHINE INSTRUCTION SETaaload
aaloadaaload
Operation Load reference from array
Formataaload
Formsaaload = 50 (0x32)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are referenceof type . The index must be of
type int. Both arrayref and index are popped from the operand
stack. The reference value in the component of the indexarray at 
is retrieved and pushed onto the operand stack.
RuntimeIf arrayref is null, aaload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the aaload instruction throws an
ArrayIndexOutOfBoundsException.
367
--------------------------------------- 386
aastoreTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
aastoreaastore
Operation Store into reference array
Formataastore
Formsaastore = 83 (0x53)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to
an array whose components are referenceof type . The index
must be of inttype  and value must be referenceof type . The
arrayref, index, and value are popped from the operand stack. The
reference value is stored as the component of indexthe .array at 
At runtime, the valuetype  must of be compatible with the type of
the components of the array referenced arrayref. Specifically,by 
assignment of a value of reference S (source) type to an array
component of reference type T (target) is allowed only if:
 If S is a class type, then:
If T is a class type, S must then be the same Tclass , or Sas 
must be a subclass of T;
If T is an interface type, then S must implement interface T.
 If S is an interface type, then:
If T is a class type, then T must be Object.
If T is an interface type, T must then be the same interface as
S or a superinterface of S.
 If S is an array type, namely, SC[], the that type is, an array of
components of type SC, then:
If T is a class type, then T must be Object.
If T is an interface type, T must then be one of the interfaces
implemented by arrays (JLS 4.10.3).
368
--------------------------------------- 387
THE JAVA VIRTUAL MACHINE INSTRUCTION SETaastore
If T is an array TC[]type , that is, an array of components of
type TC, then one of the following must be true:
VTC and SC are the same primitive type.
VTC and SC are reference types, SC and is assignable type to
TC by these runtime rules.
RuntimeIf arrayref is null, aastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the aastore instruction throws an
ArrayIndexOutOfBoundsException.
Otherwise, arrayrefif  is not null and the actual type of
value is not assignment compatible (JLS 5.2) with the actual
type of the components of the aastorearray,  throws an
ArrayStoreException.
369
--------------------------------------- 388
aconst_nullTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
aconst_nullaconst_null
Operation Push null
Formataconst_null
Formsaconst_null = 1 (0x1)
Operand... 
Stack..., null
DescriptionPush the null object reference onto the operand stack.
NotesThe Java virtual machine does not mandate a concrete value for
null.
370
--------------------------------------- 389
THE JAVA VIRTUAL MACHINE INSTRUCTION SETaload
aloadaload
Operation Load reference from local variable
Formataload
index
Formsaload = 25 (0x19)
Operand... 
Stack..., objectref
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). frame The local (variable at
index must contain referencea . The objectref in the local variable
at index is pushed onto the operand stack.
NotesThe aload instruction cannot be used to load a value of type
returnAddress from a local variable onto the operand stack. This
asymmetry with the astore instruction (astore) is intentional.
The aload opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
371
--------------------------------------- 390
aload_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
aload_<n>aload_<n>
Operation Load reference from local variable
Formataload_<n>
Formsaload_0 = 42 (0x2a)
aload_1 = 43 (0x2b)
aload_2 = 44 (0x2c)
aload_3 = 45 (0x2d)
Operand... 
Stack..., objectref
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The local variable n> must at contain <a
reference. The objectref in the local variable n> is pushedat <
onto the operand stack.
NotesAn aload_<n> instruction cannot be used to load a value of type
returnAddress from a local variable onto the operand stack.
This asymmetry with the corresponding astore_<n> instruction
(astore_<n>) is intentional.
Each of the aload_<n> instructions is the aloadsame  with as an
index of <n>, except that the operand <n> is implicit.
372
--------------------------------------- 391
THE JAVA VIRTUAL MACHINE INSTRUCTION SETanewarray
anewarrayanewarray
Operation Create new array of reference
Formatanewarray
indexbyte1
indexbyte2
Formsanewarray = 189 (0xbd)
Operand..., count 
Stack..., arrayref
DescriptionThe count must be of inttype . It is popped off the operand stack.
The count represents the number of components of the array to
be created. The unsigned indexbyte1 and indexbyte2 are used to
construct an index into the runtime constant pool of the current
class 2.6(), where the value of the indexbyte1index  <<is  8) ( |
indexbyte2. The runtime constant pool item at that index must be a
symbolic reference to a class, array, or interface type. The named
class, array, or interface type 5.4.3.1is ). resolved A new array(
with components of that type, countof , is length allocated from
the garbage-collected heap, referenceand  arrayrefa  to this new
array object is pushed onto the operand stack. All components
of the new array are initialized null, the default to value for
reference types (2.4).
LinkingDuring resolution of the symbolic reference to the class, array, or
interface type, any of the exceptions 5.4.3.1documented  canin 
Exceptionsbe thrown.
RuntimeOtherwise, countif  is less than zero, anewarraythe  instruction
Exceptionsthrows a NegativeArraySizeException.
NotesThe anewarray instruction is used to create a single dimension of
an array of object references or part of a multidimensional array.
373
--------------------------------------- 392
areturnTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
areturnareturn
Operation Return reference from method
Formatareturn
Formsareturn = 176 (0xb0)
Operand..., objectref 
Stack[empty]
DescriptionThe objectref must be of referencetype  and must refer to an
object of a type that is assignment compatible (JLS 5.2) with the
type represented by the return 4.3.3descriptor ) of the current(
method. If the current method synchronizedis a  method, the
monitor entered or reentered on invocation of the method is
updated and possibly exited as if by monitorexitexecution of a 
instruction monitorexit() in the current thread. If no exception is
thrown, objectref is popped from the operand stack of the current
frame 2.6( ) and pushed onto the operand stack of the frame of
the invoker. Any other values on the operand stack of the current
method are discarded.
The interpreter then reinstates the frame of the invoker and returns
control to the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
Exceptionsrules on structured locking 2.11.10described , then in if the
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, areturn throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then areturn throws an IllegalMonitorStateException.
374
--------------------------------------- 393
THE JAVA VIRTUAL MACHINE INSTRUCTION SETarraylength
arraylengtharraylength
Operation Get length of array
Formatarraylength
Formsarraylength = 190 (0xbe)
Operand..., arrayref 
Stack..., length
DescriptionThe arrayref must be of referencetype  and must refer to an array.
It is popped from the operand lengthstack.  of the The array it
references is determined. length is That pushed onto the operand
stack as an int.
RuntimeIf the arrayref is null, the arraylength instruction throws a
NullPointerException.
Exceptions
375
--------------------------------------- 394
astoreTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
astoreastore
Operation Store reference into local variable
Formatastore
index
Formsastore = 58 (0x3a)
Operand..., objectref 
Stack...
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). The frame objectref( on the top
of the operand stack must returnAddressbe of type  or of type
reference. It is popped from the operand stack, and the value of
the local variable at index is set to objectref.
NotesThe astore instruction is used objectrefwith  an of type
returnAddress when implementing finallythe  clause of the
Java programming language (3.13).
The aload instruction aload() cannot be used to load a value of
type returnAddress from a local variable onto the operand stack.
This asymmetry with the astore instruction is intentional.
The astore opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
376
--------------------------------------- 395
THE JAVA VIRTUAL MACHINE INSTRUCTION SETastore_<n>
astore_<n>astore_<n>
Operation Store reference into local variable
Formatastore_<n>
Formsastore_0 = 75 (0x4b)
astore_1 = 76 (0x4c)
astore_2 = 77 (0x4d)
astore_3 = 78 (0x4e)
Operand..., objectref 
Stack...
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The objectref on the top of the operand stack
must be of returnAddresstype  or of type reference. It is popped
from the operand stack, and the value of the n> local variable at <
is set to objectref.
NotesAn astore_<n> instruction is used objectrefwith  an of type
returnAddress when implementing finallythe  clauses of the
Java programming language (3.13).
An aload_<n> instruction aload_<n>() cannot be used to
load a value of returnAddresstype  from a local variable
onto the operand stack. This asymmetry with the corresponding
astore_<n> instruction is intentional.
Each of the astore_<n> instructions is the astoresame  with as an
index of <n>, except that the operand <n> is implicit.
377
--------------------------------------- 396
athrowTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
athrowathrow
Operation Throw exception or error
Formatathrow
Formsathrow = 191 (0xbf)
Operand..., objectref 
Stackobjectref
DescriptionThe objectref must be of referencetype  and must refer to an
object that is an instance Throwableof  class or of a subclass of
Throwable. It is popped from the operand objectrefstack.  isThe 
then thrown by searching the current 2.6) for method the (first
exception handler that matches objectrefthe , class as given of by
the algorithm in 2.10.
If an exception handler that objectrefmatches  is found, it contains
the location of the code intended to handle pc this exception. The 
register is reset to that location, the operand stack of the current
frame is cleared, objectref is pushed back onto the operand stack,
and execution continues.
If no matching exception handler is found in the current frame,
that frame is popped. If the current frame represents an invocation
of a synchronized method, the monitor entered or reentered
on invocation of the method is exited as if by execution of a
monitorexit instruction monitorexit(). Finally, the frame of its
invoker is reinstated, if such a frame objectrefexists,  isand the 
rethrown. If no such frame exists, the current thread exits.
RuntimeIf objectref is null, athrow throws NullPointerExceptiona 
instead of objectref.
Exceptions
Otherwise, if the Java virtual machine implementation does not
enforce the rules on structured locking 2.11.10described ,in 
then if the method of the current synchronizedframe is a 
method and the current thread is not the owner of the monitor
378
--------------------------------------- 397
THE JAVA VIRTUAL MACHINE INSTRUCTION SETathrow
entered or reentered on invocation of athrowthe method, 
throws IllegalMonitorStateExceptionan  instead of the object
previously being thrown. This can happen, for example, if an
abruptly completing synchronized method contains monitorexita 
instruction, monitorenterbut no  instruction, on the object on which
the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then athrow throws IllegalMonitorStateExceptionan  instead
of the object previously being thrown.
NotesThe operand stack diagram athrowfor  instruction the may be
misleading: If a handler for this exception is matched in the current
method, the athrow instruction discards all the values on the
operand stack, then pushes the thrown object onto the operand
stack. However, if no handler is matched in the current method
and the exception is thrown farther up the method invocation
chain, then the operand stack of the method (if any) that handles
the exception is cleared objectref and is pushed onto that empty
operand stack. All intervening frames from the method that threw
the exception up to, but not including, the method that handles the
exception are discarded.
379
--------------------------------------- 398
baloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
baloadbaload
Operation Load byte or boolean from array
Formatbaload
Formsbaload = 51 (0x33)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are byteof  type or of type boolean. The index
must be of inttype . Both arrayref and index are popped from the
operand stack. byteThe  value in the component of the array at
index is retrieved, sign-extended int value, to and an pushed onto
the top of the operand stack.
RuntimeIf arrayref is null, baload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the baload instruction throws an
ArrayIndexOutOfBoundsException.
NotesThe baload instruction is used to load values bytefrom both 
and boolean arrays. In Oracle's implementation of the Java
virtual machine, boolean arrays (arrays T_BOOLEANof type  2.2( ,
newarray)) are implemented as arrays of 8-bit values. Other
implementations may implement booleanpacked  arrays; the
baload instruction of such implementations must be used to access
those arrays.
380
--------------------------------------- 399
THE JAVA VIRTUAL MACHINE INSTRUCTION SETbastore
bastorebastore
Operation Store into byte or boolean array
Formatbastore
Formsbastore = 84 (0x54)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an
array whose components are byteof  or type of type boolean.
The index and the value must both be of inttype . The arrayref,
index, and value are popped from the operand intstack.  value The 
is truncated byteto  and a stored as the component of the array
indexed by index.
RuntimeIf arrayref is null, bastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the bastore instruction throws an
ArrayIndexOutOfBoundsException.
NotesThe bastore instruction is used to store values byteinto both 
and boolean arrays. In Oracle's implementation of the Java
virtual machine, boolean arrays (arrays T_BOOLEANof type  2.2( ,
newarray)) are implemented as arrays of 8-bit values. Other
implementations may implement booleanpacked  arrays; in such
implementations bastorethe  instruction must be able to store
boolean values into packed boolean arrays as well byte valuesas 
into byte arrays.
381
--------------------------------------- 400
bipushTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
bipushbipush
Operation Push byte
Formatbipush
byte
Formsbipush = 16 (0x10)
Operand... 
Stack..., value
DescriptionThe immediate byte is sign-extended int to valuean . That value
is pushed onto the operand stack.
382
--------------------------------------- 401
THE JAVA VIRTUAL MACHINE INSTRUCTION SETcaload
caloadcaload
Operation Load char from array
Formatcaload
Formscaload = 52 (0x34)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are charof type . The index must be of type
int. Both arrayref and index are popped from the operand stack.
The component of the indexarray  is at retrieved and zero-extended
to an int value. That value is pushed onto the operand stack.
RuntimeIf arrayref is null, caload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the caload instruction throws an
ArrayIndexOutOfBoundsException.
383
--------------------------------------- 402
castoreTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
castorecastore
Operation Store into char array
Formatcastore
Formscastore = 85 (0x55)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are charof . type The index and the value must
both be of inttype . The arrayref, index, and value are popped
from the operand stack. int valueThe  is truncated charto  anda 
stored as the component of the array indexed by index.
RuntimeIf arrayref is null, castore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the castore instruction throws an
ArrayIndexOutOfBoundsException.
384
--------------------------------------- 403
THE JAVA VIRTUAL MACHINE INSTRUCTION SETcheckcast
checkcastcheckcast
Operation Check whether object is of given type
Formatcheckcast
indexbyte1
indexbyte2
Formscheckcast = 192 (0xc0)
Operand..., objectref 
Stack..., objectref
DescriptionThe objectref must be of referencetype . The unsigned
indexbyte1 and indexbyte2 are used to construct an index into the
runtime constant pool of the 2.6current ), where class the ( value
of the index indexbyte1is ( << 8) indexbyte2| . The runtime constant
pool item at the index must be a symbolic reference to a class,
array, or interface type.
If objectref is null, then the operand stack is unchanged.
Otherwise, the named class, array, or interface type is resolved
(5.4.3.1). If objectref can be cast to the resolved class, array,
or interface type, the operand stack is unchanged; otherwise, the
checkcast instruction throws a ClassCastException.
The following rules are used to determine objectrefwhether an 
that is nullnot  can be cast to the resolved S is the type: class if of
the object referred objectrefto  by and T is the resolved class, array,
or interface checkcasttype,  determines whether objectref can be
cast to type T as follows:
 If S is an ordinary (nonarray) class, then:
If T is a class type, S must then be the same Tclass , or Sas 
must be a subclass of T;
If T is an interface type, then S must implement interface T.
 If S is an interface type, then:
385
--------------------------------------- 404
checkcastTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
If T is a class type, then T must be Object.
If T is an interface type, T must then be the same interface as
S or a superinterface of S.
 If S is a class representing the SC[], array that type is, an array
of components of type SC, then:
If T is a class type, then T must be Object.
If T is an interface type, T must then be one of the interfaces
implemented by arrays (JLS 4.10.3).
If T is an array TC[]type , that is, an array of components of
type TC, then one of the following must be true:
VTC and SC are the same primitive type.
VTC and SC are reference types, SC and can type be cast TCto 
by recursive application of these rules.
LinkingDuring resolution of the symbolic reference to the class, array, or
Exceptionsinterface type, any of the exceptions 5.4.3.1documented  canin 
be thrown.
RuntimeOtherwise, objectrefif  cannot be cast to the resolved class,
array, or interface checkcasttype,  the instruction throws a
Exception
ClassCastException.
NotesThe checkcast instruction is very similar instanceofto the 
instruction instanceof(). It differs in its nulltreatment , itsof 
behavior when its test checkcastfails  throws (an exception,
instanceof pushes a result code), and its effect on the operand
stack.
386
--------------------------------------- 405
THE JAVA VIRTUAL MACHINE INSTRUCTION SETd2f
d2fd2f
Operation Convert double to float
Formatd2f
Formsd2f = 144 (0x90)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack doublemust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ) resulting valuein '. Then value' is converted to
a float result using IEEE 754 round to nearest resultmode. The 
is pushed onto the operand stack.
Where an d2f instruction is FP-strict 2.8.2), the ( result of the
conversion is always rounded to the nearest representable value in
the float value set (2.3.2).
Where an d2f instruction is not FP-strict, the result of the
conversion may be taken from the float-extended-exponent
value set 2.3.2(); it is not necessarily rounded to the nearest
representable value in the float value set.
A finite value' too small to be represented float is as converteda 
to a zero of the same sign; value' a too finite large to be represented
as a float is converted to an infinity of doublethe same sign. A 
NaN is converted to a float NaN.
NotesThe d2f instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value' and may also lose precision.
387
--------------------------------------- 406
d2iTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
d2id2i
Operation Convert double to int
Formatd2i
Formsd2i = 142 (0x8e)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack doublemust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ) resulting valuein '. Then value' is converted to
an int. The result is pushed onto the operand stack:
 If the value' is NaN, the result of the conversion is an int 0.
 Otherwise, if valuethe ' is not an infinity, it is rounded to an
integer value V, rounding towards zero using IEEE 754 round
towards zero mode. If this Vinteger  can be value represented as
an int, then the result is the int value V.
 Otherwise, either value' the must be too small (a negative value
of large magnitude or negative infinity), result is theand the 
smallest representable value int, of or type the value' must
be too large (a positive value of large magnitude or positive
infinity), and resultthe  is the largest representable value of type
int.
NotesThe d2i instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value' and may also lose precision.
388
--------------------------------------- 407
THE JAVA VIRTUAL MACHINE INSTRUCTION SETd2l
d2ld2l
Operation Convert double to long
Formatd2l
Formsd2l = 143 (0x8f)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack doublemust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ) resulting valuein '. Then value' is converted to
a long. The result is pushed onto the operand stack:
 If the value' is NaN, the result of the conversion is a long 0.
 Otherwise, if valuethe ' is not an infinity, it is rounded to an
integer value V, rounding towards zero using IEEE 754 round
towards zero mode. If this Vinteger  can be value represented as
a long, then the result is the long value V.
 Otherwise, either value' the must be too small (a negative value
of large magnitude or negative infinity), result is theand the 
smallest representable value long, of or type the value' must
be too large (a positive value of large magnitude or positive
infinity), and resultthe  is the largest representable value of type
long.
NotesThe d2l instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value' and may also lose precision.
389
--------------------------------------- 408
daddTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
dadddadd
Operation Add double
Formatdadd
Formsdadd = 99 (0x63)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The double result is
value1' + value2'. The result is pushed onto the operand stack.
The result daddof  a instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 The sum of two infinities of opposite sign is NaN.
 The sum of two infinities of the same sign is the infinity of that
sign.
 The sum of an infinity and any finite value is equal to the
infinity.
 The sum of two zeroes of opposite sign is positive zero.
 The sum of two zeroes of the same sign is the zero of that sign.
 The sum of a zero and a nonzero finite value is equal to the
nonzero value.
 The sum of two nonzero finite values of the same magnitude and
opposite sign is positive zero.
 In the remaining cases, where neither operand is an infinity, a
zero, or NaN and the values have the same sign or have different
magnitudes, the sum is computed and rounded to the nearest
representable value using IEEE 754 round to nearest mode. If
390
--------------------------------------- 409
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdadd
the magnitude is too large to doublerepresent , we say as thea 
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small doubleto represent ,as a 
we say the operation underflows; the result is then a zero of
appropriate sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow, or
loss of precision may occur, daddexecution  instruction of a never
throws a runtime exception.
391
--------------------------------------- 410
daloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
daloaddaload
Operation Load double from array
Formatdaload
Formsdaload = 49 (0x31)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an
array whose components are doubleof . type The index must be
of type int. Both arrayref and index are popped from the operand
stack. The double value in the component of indexthe  isarray at 
retrieved and pushed onto the operand stack.
RuntimeIf arrayref is null, daload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the daload instruction throws an
ArrayIndexOutOfBoundsException.
392
--------------------------------------- 411
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdastore
dastoredastore
Operation Store into double array
Formatdastore
Formsdastore = 82 (0x52)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an
array whose components are doubleof . type The index must be of
type int, and value must be doubleof type . The arrayref, index,
and value are popped from the operand doublestack.  valueThe 
undergoes value set conversion 2.8.3), resulting (value', in which
is stored as the component of the array indexed by index.
RuntimeIf arrayref is null, dastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the dastore instruction throws an
ArrayIndexOutOfBoundsException.
393
--------------------------------------- 412
dcmp<op>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dcmp<op>dcmp<op>
Operation Compare double
Formatdcmp<op>
Formsdcmpg = 152 (0x98)
dcmpl = 151 (0x97)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values
are popped from the operand stack and undergo value set
conversion 2.8.3( ), resulting value1in ' and value2'. A floating-
point comparison is performed:
 If value1' is greater value2than ', the int value 1 is pushed onto
the operand stack.
 Otherwise, value1if ' is equal value2to ', the int value 0 is
pushed onto the operand stack.
 Otherwise, value1if ' is less value2than ', the int value -1 is
pushed onto the operand stack.
 Otherwise, at least value1one ' or of value2' is NaN. dcmpgThe 
instruction pushes int value the 1 onto the operand stack and
the dcmpl instruction pushes int value the -1 onto the operand
stack.
Floating-point comparison is performed in accordance with IEEE
754. All values other than NaN are ordered, with negative infinity
less than all finite values and positive infinity greater than all finite
values. Positive zero and negative zero are considered equal.
NotesThe dcmpg and dcmpl instructions differ only in their treatment of
a comparison involving NaN. NaN is unordered, doubleso any 
comparison fails if either or both of its operands are NaN. With
both dcmpg and dcmpl available, doubleany  comparison may
394
--------------------------------------- 413
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdcmp<op>
be compiled to push the resultsame  onto the operand stack
whether the comparison fails on non-NaN values or fails because
it encountered a NaN. For more information, see 3.5.
395
--------------------------------------- 414
dconst_<d>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dconst_<d>dconst_<d>
Operation Push double
Formatdconst_<d>
Formsdconst_0 = 14 (0xe)
dconst_1 = 15 (0xf)
Operand... 
Stack..., <d>
DescriptionPush the double constant d> <(0.0 or 1.0) onto the operand stack.
396
--------------------------------------- 415
THE JAVA VIRTUAL MACHINE INSTRUCTION SETddiv
ddivddiv
Operation Divide double
Formatddiv
Formsddiv = 111 (0x6f)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The double result is
value1' / value2'. The result is pushed onto the operand stack.
The result ddivof  a instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result is
positive if both values have the same sign, negative if the values
have different signs.
 Division of an infinity by an infinity results in NaN.
 Division of an infinity by a finite value results in a signed
infinity, with the sign-producing rule just given.
 Division of a finite value by an infinity results in a signed zero,
with the sign-producing rule just given.
 Division of a zero by a zero results in NaN; division of zero
by any other finite value results in a signed zero, with the sign-
producing rule just given.
 Division of a nonzero finite value by a zero results in a signed
infinity, with the sign-producing rule just given.
 In the remaining cases, where neither operand is an infinity,
a zero, or NaN, the quotient is computed and rounded to the
nearest double using IEEE 754 round to nearest mode. If the
397
--------------------------------------- 416
ddivTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
magnitude is too large to represent double, we as say a the
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small doubleto represent ,as a 
we say the operation underflows; the result is then a zero of
appropriate sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow,
division by zero, or loss of precision may occur, execution of a
ddiv instruction never throws a runtime exception.
398
--------------------------------------- 417
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdload
dloaddload
Operation Load double from local variable
Formatdload
index
Formsdload = 24 (0x18)
Operand... 
Stack..., value
DescriptionThe index is an unsigned byte. index Both and index+1 must be
indices into the local variable array of 2.6the ). current frame (
The local variable index must at contain doublea . The value of
the local variable at index is pushed onto the operand stack.
NotesThe dload opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
399
--------------------------------------- 418
dload_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dload_<n>dload_<n>
Operation Load double from local variable
Formatdload_<n>
Formsdload_0 = 38 (0x26)
dload_1 = 39 (0x27)
dload_2 = 40 (0x28)
dload_3 = 41 (0x29)
Operand... 
Stack..., value
DescriptionBoth n<> and n>+1 <must be indices into the local variable array
of the current 2.6frame ). The ( local variable n> must at contain<
a double. The value of the local variable n> is pushed at <onto
the operand stack.
NotesEach of the dload_<n> instructions is the dloadsame  with as an
index of <n>, except that the operand <n> is implicit.
400
--------------------------------------- 419
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdmul
dmuldmul
Operation Multiply double
Formatdmul
Formsdmul = 107 (0x6b)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The double result is
value1' * value2'. The result is pushed onto the operand stack.
The result dmulof  a instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result is
positive if both values have the same sign and negative if the
values have different signs.
 Multiplication of an infinity by a zero results in NaN.
 Multiplication of an infinity by a finite value results in a signed
infinity, with the sign-producing rule just given.
 In the remaining cases, where neither an infinity nor NaN is
involved, the product is computed and rounded to the nearest
representable value using IEEE 754 round to nearest mode. If
the magnitude is too large to doublerepresent , we say as thea 
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small doubleto represent ,as a 
we say the operation underflows; the result is then a zero of
appropriate sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow, or
401
--------------------------------------- 420
dmulTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
loss of precision may occur, dmulexecution  instruction of a never
throws a runtime exception.
402
--------------------------------------- 421
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdneg
dnegdneg
Operation Negate double
Formatdneg
Formsdneg = 119 (0x77)
Operand..., value 
Stack..., result
DescriptionThe value must be doubleof type . It is popped from the operand
stack and undergoes value set 2.8.3conversion ), resulting (in
value'. The double result is the arithmetic negation value'. Theof 
result is pushed onto the operand stack.
For double values, negation is not the same as subtraction from
zero. xIf  is +0.0, then 0.0-x equals +0.0, but -x equals -0.0.
Unary minus merely inverts the sign of a double.
Special cases of interest:
 If the operand is NaN, the result is NaN (recall that NaN has
no sign).
 If the operand is an infinity, the result is the infinity of opposite
sign.
 If the operand is a zero, the result is the zero of opposite sign.
403
--------------------------------------- 422
dremTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
dremdrem
Operation Remainder double
Formatdrem
Formsdrem = 115 (0x73)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The result is calculated
and pushed onto the operand stack as a double.
The result dremof  a instruction is not the same as that of the so-
called remainder operation defined by IEEE 754. The IEEE 754
"remainder" operation computes the remainder from a rounding
division, not a truncating division, and notso its behavior is 
analogous to that of the usual integer remainder operator. Instead,
the Java virtual machine dremdefines  to behave in a manner
analogous to that of the Java virtual machine integer remainder
instructions irem and ( lrem); this may be compared with the C
library function fmod.
The result of a drem instruction is governed by these rules:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result equals
the sign of the dividend.
 If the dividend is an infinity or the divisor is a zero or both, the
result is NaN.
 If the dividend is finite and the divisor is an infinity, the result
equals the dividend.
 If the dividend is a zero and the divisor is finite, the result equals
the dividend.
404
--------------------------------------- 423
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdrem
 In the remaining cases, where neither operand is an infinity,
a zero, or NaN, the floating-point result remainder from
a dividend value1' and a divisor value2' is defined by the
mathematical relation result = value1' - value2( ' * q), where
q is an integer that is negative value1' / value2only ' if is
negative, and positive value1only ' value2/ if ' is positive, and
whose magnitude is as large as possible without exceeding the
magnitude of the true mathematical value1quotient ' andof 
value2'.
Despite the fact that division by zero may occur, evaluation of
a drem instruction never throws a runtime exception. Overflow,
underflow, or loss of precision cannot occur.
NotesThe IEEE 754 remainder operation may be computed by the
library routine Math.IEEEremainder.
405
--------------------------------------- 424
dreturnTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
dreturndreturn
Operation Return double from method
Formatdreturn
Formsdreturn = 175 (0xaf)
Operand..., value 
Stack[empty]
DescriptionThe current method must have return double. The type value
must be of doubletype . If the current method synchronizedis a 
method, the monitor entered or reentered on invocation of the
method is updated and possibly exited as if by execution of a
monitorexit instruction monitorexit() in the current thread. If no
exception is thrown, value is popped from the operand stack of the
current frame 2.6) (and undergoes value set 2.8.3conversion ),(
resulting valuein '. The value' is pushed onto the operand stack of
the frame of the invoker. Any other values on the operand stack of
the current method are discarded.
The interpreter then returns control to the invoker of the method,
reinstating the frame of the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
Exceptionsrules on structured locking 2.11.10described , then in if the
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, dreturn throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then dreturn throws an IllegalMonitorStateException.
406
--------------------------------------- 425
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdstore
dstoredstore
Operation Store double into local variable
Formatdstore
index
Formsdstore = 57 (0x39)
Operand..., value 
Stack...
DescriptionThe index is an unsigned byte. index Both and index+1 must be
indices into the local variable array of 2.6the ). current frame (
The value on the top of the operand stack doublemust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ), resulting value'. in The local variables index at 
and index+1 are set to value'.
NotesThe dstore opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
407
--------------------------------------- 426
dstore_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dstore_<n>dstore_<n>
Operation Store double into local variable
Formatdstore_<n>
Formsdstore_0 = 71 (0x47)
dstore_1 = 72 (0x48)
dstore_2 = 73 (0x49)
dstore_3 = 74 (0x4a)
Operand..., value 
Stack...
DescriptionBoth n<> and n>+1 <must be indices into the local variable array
of the current 2.6frame ). The (value on the top of the operand
stack must be of doubletype . It is popped from the operand stack
and undergoes value set conversion 2.8.3), resulting (valuein '.
The local variables at <n> and <n>+1 are set to value'.
NotesEach of the dstore_<n> instructions is the dstoresame  with as an
index of <n>, except that the operand <n> is implicit.
408
--------------------------------------- 427
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdsub
dsubdsub
Operation Subtract double
Formatdsub
Formsdsub = 103 (0x67)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of doubletype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The double result is
value1' - value2'. The result is pushed onto the operand stack.
For double subtraction, it is always a-bthe  producescase that 
the same result a+(-b)as . However, for dsubthe  instruction,
subtraction from zero is not the same as xnegation,  isbecause if 
+0.0, then 0.0-x equals +0.0, but -x equals -0.0.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow, or
loss of precision may occur, dsubexecution  instruction of a never
throws a runtime exception.
409
--------------------------------------- 428
dupTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
dupdup
Operation Duplicate the top operand stack value
Formatdup
Formsdup = 89 (0x59)
Operand..., value 
Stack..., value, value
DescriptionDuplicate the top value on the operand stack and push the
duplicated value onto the operand stack.
The dup instruction must not be valueused  is unless a value of a
category 1 computational type (2.11.1).
410
--------------------------------------- 429
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdup_x1
dup_x1dup_x1
Operation Duplicate the top operand stack value and insert two values down
Formatdup_x1
Formsdup_x1 = 90 (0x5a)
Operand..., value2, value1 
Stack..., value1, value2, value1
DescriptionDuplicate the top value on the operand stack and insert the
duplicated value two values down in the operand stack.
The dup_x1 instruction must not be used value1unless  and both 
value2 are values of a category 1 computational type (2.11.1).
411
--------------------------------------- 430
dup_x2THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dup_x2dup_x2
Operation Duplicate the top operand stack value and insert two or three
values down
Formatdup_x2
Formsdup_x2 = 91 (0x5b)
OperandForm 1:
Stack..., value3, value2, value1 
..., value1, value3, value2, value1
where value1, value2, and value3 are all values of a category 1
computational type (2.11.1).
Form 2:
..., value2, value1 
..., value1, value2, value1
where value1 is a value of a category 1 computational type and
value2 is a value of a category 2 computational type (2.11.1).
DescriptionDuplicate the top value on the operand stack and insert the
duplicated value two or three values down in the operand stack.
412
--------------------------------------- 431
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdup2
dup2dup2
Operation Duplicate the top one or two operand stack values
Formatdup2
Formsdup2 = 92 (0x5c)
OperandForm 1:
Stack..., value2, value1 
..., value2, value1, value2, value1
where both value1 and value2 are values of a category 1
computational type (2.11.1).
Form 2:
..., value 
..., value, value
where value is a value of a category 2 computational type
(2.11.1).
DescriptionDuplicate the top one or two values on the operand stack and push
the duplicated value or values back onto the operand stack in the
original order.
413
--------------------------------------- 432
dup2_x1THE JAVA VIRTUAL MACHINE INSTRUCTION SET
dup2_x1dup2_x1
Operation Duplicate the top one or two operand stack values and insert two
or three values down
Formatdup2_x1
Formsdup2_x1 = 93 (0x5d)
OperandForm 1:
Stack..., value3, value2, value1 
..., value2, value1, value3, value2, value1
where value1, value2, and value3 are all values of a category 1
computational type (2.11.1).
Form 2:
..., value2, value1 
..., value1, value2, value1
where value1 is a value of a category 2 computational type and
value2 is a value of a category 1 computational type (2.11.1).
DescriptionDuplicate the top one or two values on the operand stack and insert
the duplicated values, in the original order, one value beneath the
original value or values in the operand stack.
414
--------------------------------------- 433
THE JAVA VIRTUAL MACHINE INSTRUCTION SETdup2_x2
dup2_x2dup2_x2
Operation Duplicate the top one or two operand stack values and insert two,
three, or four values down
Formatdup2_x2
Formsdup2_x2 = 94 (0x5e)
OperandForm 1:
Stack..., value4, value3, value2, value1 
..., value2, value1, value4, value3, value2, value1
where value1, value2, value3, and value4 are all values of a
category 1 computational type (2.11.1).
Form 2:
..., value3, value2, value1 
..., value1, value3, value2, value1
where value1 is a value of a category 2 computational type and
value2 and value3 are both values of a category 1 computational
type (2.11.1).
Form 3:
..., value3, value2, value1 
..., value2, value1, value3, value2, value1
where value1 and value2 are both values of a category 1
computational type value3and  is a value of a category 2
computational type (2.11.1).
Form 4:
..., value2, value1 
..., value1, value2, value1
where value1 and value2 are both values of a category 2
computational type (2.11.1).
415
--------------------------------------- 434
dup2_x2THE JAVA VIRTUAL MACHINE INSTRUCTION SET
DescriptionDuplicate the top one or two values on the operand stack and insert
the duplicated values, in the original order, into the operand stack.
416
--------------------------------------- 435
THE JAVA VIRTUAL MACHINE INSTRUCTION SETf2d
f2df2d
Operation Convert float to double
Formatf2d
Formsf2d = 141 (0x8d)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack floatmust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ), resulting valuein '. Then value' is converted
to a double result. This result is pushed onto the operand stack.
NotesWhere an f2d instruction is FP-strict 2.8.2) it (performs a
widening primitive conversion (JLS 5.1.2). Because all values of
the float value 2.3.2set ) are ( exactly representable by values of
the double value set (2.3.2), such a conversion is exact.
Where an f2d instruction is not FP-strict, the result of the
conversion may be taken from the double-extended-exponent
value set; it is not necessarily rounded to the nearest representable
value in the double value set. However, valueif  isthe operand 
taken from the float-extended-exponent value set and the target
result is constrained to the double value value mayset, rounding of 
be required.
417
--------------------------------------- 436
f2iTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
f2if2i
Operation Convert float to int
Formatf2i
Formsf2i = 139 (0x8b)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack floatmust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ), resulting valuein '. Then value' is converted
to an int result. This result is pushed onto the operand stack:
 If the value' is NaN, the result of the conversion is an int 0.
 Otherwise, if valuethe ' is not an infinity, it is rounded to an
integer value V, rounding towards zero using IEEE 754 round
towards zero mode. If this Vinteger  can be value represented as
an int, then the result is the int value V.
 Otherwise, either value' the must be too small (a negative value
of large magnitude or negative infinity), result is theand the 
smallest representable value int, of or type the value' must
be too large (a positive value of large magnitude or positive
infinity), and resultthe  is the largest representable value of type
int.
NotesThe f2i instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value' and may also lose precision.
418
--------------------------------------- 437
THE JAVA VIRTUAL MACHINE INSTRUCTION SETf2l
f2lf2l
Operation Convert float to long
Formatf2l
Formsf2l = 140 (0x8c)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack floatmust . be of type 
It is popped from the operand stack and undergoes value set
conversion 2.8.3( ), resulting valuein '. Then value' is converted
to a long result. This result is pushed onto the operand stack:
 If the value' is NaN, the result of the conversion is a long 0.
 Otherwise, if valuethe ' is not an infinity, it is rounded to an
integer value V, rounding towards zero using IEEE 754 round
towards zero mode. If this Vinteger  can be value represented as
a long, then the result is the long value V.
 Otherwise, either value' the must be too small (a negative value
of large magnitude or negative infinity), result is theand the 
smallest representable value long, of or type the value' must
be too large (a positive value of large magnitude or positive
infinity), and resultthe  is the largest representable value of type
long.
NotesThe f2l instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value' and may also lose precision.
419
--------------------------------------- 438
faddTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
faddfadd
Operation Add float
Formatfadd
Formsfadd = 98 (0x62)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The float result is
value1' + value2'. The result is pushed onto the operand stack.
The result faddof  an instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 The sum of two infinities of opposite sign is NaN.
 The sum of two infinities of the same sign is the infinity of that
sign.
 The sum of an infinity and any finite value is equal to the
infinity.
 The sum of two zeroes of opposite sign is positive zero.
 The sum of two zeroes of the same sign is the zero of that sign.
 The sum of a zero and a nonzero finite value is equal to the
nonzero value.
 The sum of two nonzero finite values of the same magnitude and
opposite sign is positive zero.
 In the remaining cases, where neither operand is an infinity, a
zero, or NaN and the values have the same sign or have different
magnitudes, the sum is computed and rounded to the nearest
representable value using IEEE 754 round to nearest mode. If
420
--------------------------------------- 439
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfadd
the magnitude is too large to floatrepresent , we say as thea 
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small floatto , represent we sayas a 
the operation underflows; the result is then a zero of appropriate
sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow,
or loss of precision may occur, faddexecution  instructionof an 
never throws a runtime exception.
421
--------------------------------------- 440
faloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
faloadfaload
Operation Load float from array
Formatfaload
Formsfaload = 48 (0x30)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are floatof type . The index must be of type
int. Both arrayref and index are popped from the operand stack.
The float value in the component of indexthe  is array retrievedat 
and pushed onto the operand stack.
RuntimeIf arrayref is null, faload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the faload instruction throws an
ArrayIndexOutOfBoundsException.
422
--------------------------------------- 441
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfastore
fastorefastore
Operation Store into float array
Formatfastore
Formsfastore = 81 (0x51)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are floatof type . The index must be of type
int, and the value must be of floattype . The arrayref, index,
and value are popped from the operand floatstack.  valueThe 
undergoes value set conversion 2.8.3), resulting (valuein ', and
value' is stored as the component of the array indexed by index.
RuntimeIf arrayref is null, fastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the fastore instruction throws an
ArrayIndexOutOfBoundsException.
423
--------------------------------------- 442
fcmp<op>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
fcmp<op>fcmp<op>
Operation Compare float
Formatfcmp<op>
Formsfcmpg = 150 (0x96)
fcmpl = 149 (0x95)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values
are popped from the operand stack and undergo value set
conversion 2.8.3( ), resulting value1in ' and value2'. A floating-
point comparison is performed:
 If value1' is greater value2than ', the int value 1 is pushed onto
the operand stack.
 Otherwise, value1if ' is equal value2to ', the int value 0 is
pushed onto the operand stack.
 Otherwise, value1if ' is less value2than ', the int value -1 is
pushed onto the operand stack.
 Otherwise, at least value1one ' or of value2' is NaN. fcmpgThe 
instruction pushes int value the 1 onto the operand stack and
the fcmpl instruction pushes int value the -1 onto the operand
stack.
Floating-point comparison is performed in accordance with IEEE
754. All values other than NaN are ordered, with negative infinity
less than all finite values and positive infinity greater than all finite
values. Positive zero and negative zero are considered equal.
NotesThe fcmpg and fcmpl instructions differ only in their treatment of
a comparison involving NaN. NaN is unordered, floatso any 
comparison fails if either or both of its operands are NaN. With
both fcmpg and fcmpl available, floatany  comparison may
424
--------------------------------------- 443
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfcmp<op>
be compiled to push the resultsame  onto the operand stack
whether the comparison fails on non-NaN values or fails because
it encountered a NaN. For more information, see 3.5.
425
--------------------------------------- 444
fconst_<f>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
fconst_<f>fconst_<f>
Operation Push float
Formatfconst_<f>
Formsfconst_0 = 11 (0xb)
fconst_1 = 12 (0xc)
fconst_2 = 13 (0xd)
Operand... 
Stack..., <f>
DescriptionPush the float constant f> (0.0, <1.0, or 2.0) onto the operand
stack.
426
--------------------------------------- 445
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfdiv
fdivfdiv
Operation Divide float
Formatfdiv
Formsfdiv = 110 (0x6e)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The float result is
value1' / value2'. The result is pushed onto the operand stack.
The result of fdiv an instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result is
positive if both values have the same sign, negative if the values
have different signs.
 Division of an infinity by an infinity results in NaN.
 Division of an infinity by a finite value results in a signed
infinity, with the sign-producing rule just given.
 Division of a finite value by an infinity results in a signed zero,
with the sign-producing rule just given.
 Division of a zero by a zero results in NaN; division of zero
by any other finite value results in a signed zero, with the sign-
producing rule just given.
 Division of a nonzero finite value by a zero results in a signed
infinity, with the sign-producing rule just given.
 In the remaining cases, where neither operand is an infinity,
a zero, or NaN, the quotient is computed and rounded to the
nearest float using IEEE 754 round to nearest mode. If the
427
--------------------------------------- 446
fdivTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
magnitude is too large to represent float, we as say a the
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small floatto , represent we sayas a 
the operation underflows; the result is then a zero of appropriate
sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow,
division by zero, or loss of precision may occur, execution of an
fdiv instruction never throws a runtime exception.
428
--------------------------------------- 447
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfload
floadfload
Operation Load float from local variable
Formatfload
index
Formsfload = 23 (0x17)
Operand... 
Stack..., value
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). frame The local (variable at
index must contain floata . The value of the local variable index at 
is pushed onto the operand stack.
NotesThe fload opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
429
--------------------------------------- 448
fload_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
fload_<n>fload_<n>
Operation Load float from local variable
Formatfload_<n>
Formsfload_0 = 34 (0x22)
fload_1 = 35 (0x23)
fload_2 = 36 (0x24)
fload_3 = 37 (0x25)
Operand... 
Stack..., value
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The local variable n> must at contain <a
float. The value of the local variable n> is pushed at <onto the
operand stack.
NotesEach of the fload_<n> instructions is the floadsame  with as an
index of <n>, except that the operand <n> is implicit.
430
--------------------------------------- 449
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfmul
fmulfmul
Operation Multiply float
Formatfmul
Formsfmul = 106 (0x6a)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The float result is
value1' * value2'. The result is pushed onto the operand stack.
The result fmulof  an instruction is governed by the rules of IEEE
arithmetic:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result is
positive if both values have the same sign, and negative if the
values have different signs.
 Multiplication of an infinity by a zero results in NaN.
 Multiplication of an infinity by a finite value results in a signed
infinity, with the sign-producing rule just given.
 In the remaining cases, where neither an infinity nor NaN is
involved, the product is computed and rounded to the nearest
representable value using IEEE 754 round to nearest mode. If
the magnitude is too large to floatrepresent , we say as thea 
operation overflows; the result is then an infinity of appropriate
sign. If the magnitude is too small floatto , represent we sayas a 
the operation underflows; the result is then a zero of appropriate
sign.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow,
431
--------------------------------------- 450
fmulTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
or loss of precision may occur, fmulexecution  instructionof an 
never throws a runtime exception.
432
--------------------------------------- 451
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfneg
fnegfneg
Operation Negate float
Formatfneg
Formsfneg = 118 (0x76)
Operand..., value 
Stack..., result
DescriptionThe value must be of floattype . It is popped from the operand
stack and undergoes value set 2.8.3conversion ), resulting (in
value'. The float result is the arithmetic negation value'. Thisof 
result is pushed onto the operand stack.
For float values, negation is not the same as subtraction from
zero. xIf  is +0.0, then 0.0-x equals +0.0, but -x equals -0.0.
Unary minus merely inverts the sign of a float.
Special cases of interest:
 If the operand is NaN, the result is NaN (recall that NaN has
no sign).
 If the operand is an infinity, the result is the infinity of opposite
sign.
 If the operand is a zero, the result is the zero of opposite sign.
433
--------------------------------------- 452
fremTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
fremfrem
Operation Remainder float
Formatfrem
Formsfrem = 114 (0x72)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The result is calculated
and pushed onto the operand stack as a float.
The result of an frem instruction is not the same as that of the so-
called remainder operation defined by IEEE 754. The IEEE 754
"remainder" operation computes the remainder from a rounding
division, not a truncating division, and notso its behavior is 
analogous to that of the usual integer remainder operator. Instead,
the Java virtual machine fremdefines  to behave in a manner
analogous to that of the Java virtual machine integer remainder
instructions irem and ( lrem); this may be compared with the C
library function fmod.
The result of an frem instruction is governed by these rules:
 If either value1' or value2' is NaN, the result is NaN.
 If neither value1' nor value2' is NaN, the sign of the result equals
the sign of the dividend.
 If the dividend is an infinity or the divisor is a zero or both, the
result is NaN.
 If the dividend is finite and the divisor is an infinity, the result
equals the dividend.
 If the dividend is a zero and the divisor is finite, the result equals
the dividend.
434
--------------------------------------- 453
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfrem
 In the remaining cases, where neither operand is an infinity,
a zero, or NaN, the floating-point result remainder from
a dividend value1' and a divisor value2' is defined by the
mathematical relation result = value1' - value2( ' * q), where
q is an integer that is negative value1' / value2only ' if is
negative and positive value1only ' value2/ if ' is positive, and
whose magnitude is as large as possible without exceeding the
magnitude of the true mathematical value1quotient ' andof 
value2'.
Despite the fact that division by zero may occur, evaluation of
an frem instruction never throws a runtime exception. Overflow,
underflow, or loss of precision cannot occur.
NotesThe IEEE 754 remainder operation may be computed by the
library routine Math.IEEEremainder.
435
--------------------------------------- 454
freturnTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
freturnfreturn
Operation Return float from method
Formatfreturn
Formsfreturn = 174 (0xae)
Operand..., value 
Stack[empty]
DescriptionThe current method must have return float. The type value
must be of floattype . If the current method synchronizedis a 
method, the monitor entered or reentered on invocation of the
method is updated and possibly exited as if by execution of a
monitorexit instruction monitorexit() in the current thread. If no
exception is thrown, value is popped from the operand stack of the
current frame 2.6) (and undergoes value set 2.8.3conversion ),(
resulting valuein '. The value' is pushed onto the operand stack of
the frame of the invoker. Any other values on the operand stack of
the current method are discarded.
The interpreter then returns control to the invoker of the method,
reinstating the frame of the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
Exceptionsrules on structured locking 2.11.10described , then in if the
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, freturn throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then freturn throws an IllegalMonitorStateException.
436
--------------------------------------- 455
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfstore
fstorefstore
Operation Store float into local variable
Formatfstore
index
Formsfstore = 56 (0x38)
Operand..., value 
Stack...
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). The frame value (on the top
of the operand stack must floatbe of . It type is popped from
the operand stack and undergoes value 2.8.3set ),conversion (
resulting valuein '. The value of the local indexvariable  is set at 
to value'.
NotesThe fstore opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
437
--------------------------------------- 456
fstore_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
fstore_<n>fstore_<n>
Operation Store float into local variable
Formatfstore_<n>
Formsfstore_0 = 67 (0x43)
fstore_1 = 68 (0x44)
fstore_2 = 69 (0x45)
fstore_3 = 70 (0x46)
Operand..., value 
Stack...
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The value on the top of the operand stack
must be of floattype . It is popped from the operand stack and
undergoes value set conversion 2.8.3), resulting (valuein '. The
value of the local variable at <n> is set to value'.
NotesEach of the fstore_<n> instructions is the fstoresame  with as an
index of <n>, except that the operand <n> is implicit.
438
--------------------------------------- 457
THE JAVA VIRTUAL MACHINE INSTRUCTION SETfsub
fsubfsub
Operation Subtract float
Formatfsub
Formsfsub = 102 (0x66)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of floattype . The values are
popped from the operand stack and undergo value set conversion
(2.8.3), resulting value1in ' and value2'. The float result is
value1' - value2'. The result is pushed onto the operand stack.
For float subtraction, it is always a-bthe  producescase that 
the same result a+(-b)as . However, for fsubthe  instruction,
subtraction from zero is not the same as xnegation,  isbecause if 
+0.0, then 0.0-x equals +0.0, but -x equals -0.0.
The Java virtual machine requires support of gradual underflow as
defined by IEEE 754. Despite the fact that overflow, underflow, or
loss of precision may occur, execution fsub instruction of an never
throws a runtime exception.
439
--------------------------------------- 458
getfieldTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
getfieldgetfield
Operation Fetch field from object
Formatgetfield
indexbyte1
indexbyte2
Formsgetfield = 180 (0xb4)
Operand..., objectref 
Stack..., value
DescriptionThe objectref, which must be of referencetype , is popped from
the operand stack. The indexbyte1unsigned  and indexbyte2 are
used to construct an index into the runtime constant pool of the
current class 2.6), (where the value of the indexbyte1index  <<is (
8) indexbyte2| . The runtime constant pool item at that index must
be a symbolic reference 5.1to ), a which field gives (the name and
descriptor of the field as well as a symbolic reference to the class
in which the field is to be found. The referenced field is resolved
(5.4.3.2). The value of the referenced objectreffield  is in fetched
and pushed onto the operand stack.
The type objectrefof  must not be an array type. If the field is
protected (4.6), and it is a member of a superclass of the current
class, and the field is not declared in the same runtime package
(5.3) as the current class, then objectrefthe  must class be of either
the current class or a subclass of the current class.
LinkingDuring resolution of the symbolic reference to the field, any of the
errors pertaining to field resolution (5.4.3.2) can be thrown.
Exceptions
Otherwise, if the resolved staticfield  field, is getfielda  throws
an IncompatibleClassChangeError.
RuntimeOtherwise, objectrefif  is null, the getfield instruction throws a
ExceptionNullPointerException.
440
--------------------------------------- 459
THE JAVA VIRTUAL MACHINE INSTRUCTION SETgetfield
NotesThe getfield instruction cannot be used lengthto access  fieldthe 
of an array. arraylengthThe  instruction arraylength() is used
instead.
441
--------------------------------------- 460
getstaticTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
getstaticgetstatic
Operation Get static field from class
Formatgetstatic
indexbyte1
indexbyte2
Formsgetstatic = 178 (0xb2)
Operand..., 
Stack..., value
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a 5.1field ), which (gives the name and descriptor of
the field as well as a symbolic reference to the class or interface
in which the field is to be found. The referenced field is resolved
(5.4.3.2).
On successful resolution of the field, the class or interface that
declared the resolved field 5.5is ) initialized if that class (or
interface has not already been initialized.
The value of the class or interface field is fetched and pushed onto
the operand stack.
LinkingDuring resolution of the symbolic reference to the class or
interface field, any of the exceptions pertaining to field resolution
Exceptions(5.4.3.2) can be thrown.
Otherwise, if the resolved field staticis not a 
(class) field or an interface getstatic field, throws an
IncompatibleClassChangeError.
442
--------------------------------------- 461
THE JAVA VIRTUAL MACHINE INSTRUCTION SETgetstatic
RuntimeOtherwise, if execution getstaticof  this instruction causes
initialization of the referenced class getstatic or mayinterface, 
Exceptionthrow an Error as detailed in 5.5.
443
--------------------------------------- 462
gotoTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
gotogoto
Operation Branch always
Formatgoto
branchbyte1
branchbyte2
Formsgoto = 167 (0xa7)
OperandNo change
Stack
DescriptionThe unsigned bytes branchbyte1 and branchbyte2 are used to
construct a signed branchoffset16-bit , where branchoffset is
(branchbyte1 << 8) branchbyte2| . Execution proceeds at that
offset from the address of the gotoopcode  instruction. of this The
target address must be that of an opcode of an instruction within
the method that contains this goto instruction.
444
--------------------------------------- 463
THE JAVA VIRTUAL MACHINE INSTRUCTION SETgoto_w
goto_wgoto_w
Operation Branch always (wide index)
Formatgoto_w
branchbyte1
branchbyte2
branchbyte3
branchbyte4
Formsgoto_w = 200 (0xc8)
OperandNo change
Stack
DescriptionThe unsigned bytes branchbyte1, branchbyte2, branchbyte3, and
branchbyte4 are used to construct a signed branchoffset32-bit ,
where branchoffset is branchbyte1( << 24) branchbyte2| ( << 16)
| branchbyte3( << 8) branchbyte4| . Execution proceeds at that
offset from the address of the goto_wopcode  instruction.of this 
The target address must be that of an opcode of an instruction
within the method that contains this goto_w instruction.
NotesAlthough the goto_w instruction takes a 4-byte branch offset, other
factors limit the size of a method 4.11to ). 65535 This bytes limit (
may be raised in a future release of the Java virtual machine.
445
--------------------------------------- 464
i2bTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
i2bi2b
Operation Convert int to byte
Formati2b
Formsi2b = 145 (0x91)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . Itbe of type 
is popped from the operand stack, bytetruncated , then sign-to a 
extended to intan  result. That result is pushed onto the operand
stack.
NotesThe i2b instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value. The result may also not have the same sign as value.
446
--------------------------------------- 465
THE JAVA VIRTUAL MACHINE INSTRUCTION SETi2c
i2ci2c
Operation Convert int to char
Formati2c
Formsi2c = 146 (0x92)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . Itbe of type 
is popped from the operand stack, chartruncated , then zero-to 
extended to intan  result. That result is pushed onto the operand
stack.
NotesThe i2c instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value. The result (which is always positive) may also not have
the same sign as value.
447
--------------------------------------- 466
i2dTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
i2di2d
Operation Convert int to double
Formati2d
Formsi2d = 135 (0x87)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . It be isof type 
popped from the operand stack and doubleconverted  result. to a 
The result is pushed onto the operand stack.
NotesThe i2d instruction performs a widening primitive conversion (JLS
5.1.2). Because all values int are of type exactly representable
by type double, the conversion is exact.
448
--------------------------------------- 467
THE JAVA VIRTUAL MACHINE INSTRUCTION SETi2f
i2fi2f
Operation Convert int to float
Formati2f
Formsi2f = 134 (0x86)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . It be isof type 
popped from the operand stack and converted float resultto the 
using IEEE 754 round to nearest resultmode.  is pushed The onto
the operand stack.
NotesThe i2f instruction performs a widening primitive conversion (JLS
5.1.2), but may result in a loss of precision because values of type
float have only 24 significand bits.
449
--------------------------------------- 468
i2lTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
i2li2l
Operation Convert int to long
Formati2l
Formsi2l = 133 (0x85)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . It be isof type 
popped from the operand stack and sign-extended long result.to a 
That result is pushed onto the operand stack.
NotesThe i2l instruction performs a widening primitive conversion (JLS
5.1.2). Because all values int are of type exactly representable
by type long, the conversion is exact.
450
--------------------------------------- 469
THE JAVA VIRTUAL MACHINE INSTRUCTION SETi2s
i2si2s
Operation Convert int to short
Formati2s
Formsi2s = 147 (0x93)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack intmust . Itbe of type 
is popped from the operand stack, shorttruncated , then sign-to a 
extended to intan  result. That result is pushed onto the operand
stack.
NotesThe i2s instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value. The result may also not have the same sign as value.
451
--------------------------------------- 470
iaddTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
iaddiadd
Operation Add int
Formatiadd
Formsiadd = 96 (0x60)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultThe  is value1 + value2. The
result is pushed onto the operand stack.
The result is the 32 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type int. If overflow occurs, then the sign of the result
may not be the same as the sign of the mathematical sum of the
two values.
Despite the fact that overflow may occur, iaddexecution of an 
instruction never throws a runtime exception.
452
--------------------------------------- 471
THE JAVA VIRTUAL MACHINE INSTRUCTION SETiaload
ialoadiaload
Operation Load int from array
Formatiaload
Formsiaload = 46 (0x2e)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are intof . type The index must be of inttype .
Both arrayref and index are popped from the operand stack. The
int value in the component of the indexarray  is retrieved at and
pushed onto the operand stack.
RuntimeIf arrayref is null, iaload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the iaload instruction throws an
ArrayIndexOutOfBoundsException.
453
--------------------------------------- 472
iandTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
iandiand
Operation Boolean AND int
Formatiand
Formsiand = 126 (0x7e)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . They are popped
from the operand stack. int resultAn  is calculated by taking the
bitwise AND (conjunction) value1 of and value2. The result is
pushed onto the operand stack.
454
--------------------------------------- 473
THE JAVA VIRTUAL MACHINE INSTRUCTION SETiastore
iastoreiastore
Operation Store into int array
Formatiastore
Formsiastore = 79 (0x4f)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are intof . type Both index and value must be
of type int. The arrayref, index, and value are popped from the
operand stack. intThe  value is stored as the component of the
array indexed by index.
RuntimeIf arrayref is null, iastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the iastore instruction throws an
ArrayIndexOutOfBoundsException.
455
--------------------------------------- 474
iconst_<i>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
iconst_<i>iconst_<i>
Operation Push int constant
Formaticonst_<i>
Formsiconst_m1 = 2 (0x2)
iconst_0 = 3 (0x3)
iconst_1 = 4 (0x4)
iconst_2 = 5 (0x5)
iconst_3 = 6 (0x6)
iconst_4 = 7 (0x7)
iconst_5 = 8 (0x8)
Operand... 
Stack..., <i>
DescriptionPush the int constant i> (-1, <0, 1, 2, 3, 4 or 5) onto the operand
stack.
NotesEach of this family of instructions bipushis  equivalent <i> forto 
the respective value i>, except of < that the ioperand > is implicit.<
456
--------------------------------------- 475
THE JAVA VIRTUAL MACHINE INSTRUCTION SETidiv
idividiv
Operation Divide int
Formatidiv
Formsidiv = 108 (0x6c)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultThe  is the value of the Java
programming language expression value1 / value2. The result is
pushed onto the operand stack.
An int division rounds towards 0; that is, the quotient produced
for int values n/in d is intan  value q whose magnitude is as large
as possible while satisfying d  q| d n||. Moreover, |q is positive
when n|| e d|| and n and d have the same sign, q is but negative
when |n| e |d| and n and d have opposite signs.
There is one special case that does not satisfy this rule: if the
dividend is the negative integer of largest possible magnitude for
the int type, and the divisor is -1, then overflow occurs, and the
result is equal to the dividend. Despite the overflow, no exception
is thrown in this case.
RuntimeIf the value of the divisor int division in an idivis  0, throws an
ExceptionArithmeticException.
457
--------------------------------------- 476
if_acmp<cond>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
if_acmp<cond>if_acmp<cond>
Operation Branch if reference comparison succeeds
Formatif_acmp<cond>
branchbyte1
branchbyte2
Formsif_acmpeq = 165 (0xa5)
if_acmpne = 166 (0xa6)
Operand..., value1, value2 
Stack...
DescriptionBoth value1 and value2 must be of referencetype . They are both
popped from the operand stack and compared. The results of the
comparison are as follows:
 if_acmpeq succeeds if and only if value1 = value2
 if_acmpne succeeds if and only if value1 ` value2
If the comparison succeeds, the branchbyte1unsigned  and
branchbyte2 are used to construct a signed 16-bit offset, where
the offset is calculated branchbyte1to be  << (8) branchbyte2| .
Execution then proceeds at that offset from the address of the
opcode of this if_acmp<cond> instruction. The target address
must be that of an opcode of an instruction within the method that
contains this if_acmp<cond> instruction.
Otherwise, if the comparison fails, execution proceeds at
the address of the instruction if_acmp<cond>following this 
instruction.
458
--------------------------------------- 477
THE JAVA VIRTUAL MACHINE INSTRUCTION SETif_icmp<cond>
if_icmp<cond>if_icmp<cond>
Operation Branch if int comparison succeeds
Formatif_icmp<cond>
branchbyte1
branchbyte2
Formsif_icmpeq = 159 (0x9f)
if_icmpne = 160 (0xa0)
if_icmplt = 161 (0xa1)
if_icmpge = 162 (0xa2)
if_icmpgt = 163 (0xa3)
if_icmple = 164 (0xa4)
Operand..., value1, value2 
Stack...
DescriptionBoth value1 and value2 must be of inttype . They are both popped
from the operand stack and compared. All comparisons are signed.
The results of the comparison are as follows:
 if_icmpeq succeeds if and only if value1 = value2
 if_icmpne succeeds if and only if value1 ` value2
 if_icmplt succeeds if and only if value1 < value2
 if_icmple succeeds if and only if value1 d value2
 if_icmpgt succeeds if and only if value1 > value2
 if_icmpge succeeds if and only if value1 e value2
If the comparison succeeds, the branchbyte1unsigned  and
branchbyte2 are used to construct a signed 16-bit offset, where
the offset is calculated branchbyte1to be  << (8) branchbyte2| .
Execution then proceeds at that offset from the address of the
opcode of if_icmp<cond>this  instruction. The target address must
459
--------------------------------------- 478
if_icmp<cond>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
be that of an opcode of an instruction within the method that
contains this if_icmp<cond> instruction.
Otherwise, execution proceeds at the address of the instruction
following this if_icmp<cond> instruction.
460
--------------------------------------- 479
THE JAVA VIRTUAL MACHINE INSTRUCTION SETif<cond>
if<cond>if<cond>
Operation Branch if int comparison with zero succeeds
Formatif<cond>
branchbyte1
branchbyte2
Formsifeq = 153 (0x99)
ifne = 154 (0x9a)
iflt = 155 (0x9b)
ifge = 156 (0x9c)
ifgt = 157 (0x9d)
ifle = 158 (0x9e)
Operand..., value 
Stack...
DescriptionThe value must be of inttype . It is popped from the operand
stack and compared against zero. All comparisons are signed. The
results of the comparisons are as follows:
 ifeq succeeds if and only if value = 0
 ifne succeeds if and only if value ` 0
 iflt succeeds if and only if value < 0
 ifle succeeds if and only if value d 0
 ifgt succeeds if and only if value > 0
 ifge succeeds if and only if value e 0
If the comparison succeeds, the branchbyte1unsigned  and
branchbyte2 are used to construct a signed 16-bit offset, where
the offset is calculated branchbyte1to be  << (8) branchbyte2| .
Execution then proceeds at that offset from the address of the
opcode of this if<cond> instruction. The target address must be
461
--------------------------------------- 480
if<cond>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
that of an opcode of an instruction within the method that contains
this if<cond> instruction.
Otherwise, execution proceeds at the address of the instruction
following this if<cond> instruction.
462
--------------------------------------- 481
THE JAVA VIRTUAL MACHINE INSTRUCTION SETifnonnull
ifnonnullifnonnull
Operation Branch if reference not null
Formatifnonnull
branchbyte1
branchbyte2
Formsifnonnull = 199 (0xc7)
Operand..., value 
Stack...
DescriptionThe value must be of referencetype . It is popped from the
operand stack. valueIf  is not null, the unsigned branchbyte1 and
branchbyte2 are used to construct a signed 16-bit offset, where
the offset is calculated branchbyte1to be  << (8) branchbyte2| .
Execution then proceeds at that offset from the address of the
opcode of this ifnonnull instruction. The target address must be
that of an opcode of an instruction within the method that contains
this ifnonnull instruction.
Otherwise, execution proceeds at the address of the instruction
following this ifnonnull instruction.
463
--------------------------------------- 482
ifnullTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
ifnullifnull
Operation Branch if reference is null
Formatifnull
branchbyte1
branchbyte2
Formsifnull = 198 (0xc6)
Operand..., value 
Stack...
DescriptionThe value must of type reference. It is popped from the operand
stack. valueIf  is null, the unsigned branchbyte1 and branchbyte2
are used to construct a signed 16-bit offset, where the offset is
calculated to branchbyte1be ( << 8) branchbyte2| . Execution then
proceeds at that offset from the address ifnullof the opcode of this 
instruction. The target address must be that of an opcode of an
instruction within the method that contains this ifnull instruction.
Otherwise, execution proceeds at the address of the instruction
following this ifnull instruction.
464
--------------------------------------- 483
THE JAVA VIRTUAL MACHINE INSTRUCTION SETiinc
iinciinc
Operation Increment local variable by constant
Formatiinc
index
const
Formsiinc = 132 (0x84)
OperandNo change
Stack
DescriptionThe index is an unsigned byte that must be an index into the
local variable array of the 2.6current ). The constframe  is (an
immediate signed byte. The local indexvariable  must containat 
an int. The value const is first sign-extended int, and to thenan 
the local variable at index is incremented by that amount.
NotesThe iinc opcode can be used in conjunction widewith the 
instruction wide() to access a local variable using a two-byte
unsigned index and to increment it by a two-byte immediate signed
value.
465
--------------------------------------- 484
iloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
iloadiload
Operation Load int from local variable
Formatiload
index
Formsiload = 21 (0x15)
Operand... 
Stack..., value
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). frame The local (variable at
index must contain int. an The value of the local variable index at 
is pushed onto the operand stack.
NotesThe iload opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
466
--------------------------------------- 485
THE JAVA VIRTUAL MACHINE INSTRUCTION SETiload_<n>
iload_<n>iload_<n>
Operation Load int from local variable
Formatiload_<n>
Formsiload_0 = 26 (0x1a)
iload_1 = 27 (0x1b)
iload_2 = 28 (0x1c)
iload_3 = 29 (0x1d)
Operand... 
Stack..., value
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The local variable n> must at contain <an
int. The value of the local variable n> is at pushed <onto the
operand stack.
NotesEach of the iload_<n> instructions is the iloadsame  with as an
index of <n>, except that the operand <n> is implicit.
467
--------------------------------------- 486
imulTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
imulimul
Operation Multiply int
Formatimul
Formsimul = 104 (0x68)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultThe  is value1 * value2. The
result is pushed onto the operand stack.
The result is the 32 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type int. If overflow occurs, then the sign of the result
may not be the same as the sign of the mathematical sum of the
two values.
Despite the fact that overflow may occur, imulexecution of an 
instruction never throws a runtime exception.
468
--------------------------------------- 487
THE JAVA VIRTUAL MACHINE INSTRUCTION SETineg
inegineg
Operation Negate int
Formatineg
Formsineg = 116 (0x74)
Operand..., value 
Stack..., result
DescriptionThe value must be of inttype . It is popped from the operand
stack. The int result is the arithmetic negation value, value- of .
The result is pushed onto the operand stack.
For int values, negation is the same as subtraction from
zero. Because the Java virtual machine uses two's-complement
representation for integers and the range of two's-complement
values is not symmetric, the negation of the maximum negative
int results in that same maximum negative number. Despite the
fact that overflow has occurred, no exception is thrown.
For all int values x, -x equals (~x)+1.
469
--------------------------------------- 488
instanceofTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
instanceofinstanceof
Operation Determine if object is of given type
Formatinstanceof
indexbyte1
indexbyte2
Formsinstanceof = 193 (0xc1)
Operand..., objectref 
Stack..., result
DescriptionThe objectref, which must be of referencetype , is popped from
the operand stack. The indexbyte1unsigned  and indexbyte2 are
used to construct an index into the runtime constant pool of the
current class 2.6), (where the value of the indexbyte1index  <<is (
8) indexbyte2| . The runtime constant pool item at the index must
be a symbolic reference to a class, array, or interface type.
If objectref is null, the instanceof instruction pushes int resultan 
of 0 as an int on the operand stack.
Otherwise, the named class, array, or interface type is resolved
(5.4.3.1). objectrefIf  is an instance of the resolved class or array
or implements the resolved interface, instanceof instructionthe 
pushes intan  result of 1 as intan  on the operand stack; otherwise,
it pushes an int result of 0.
The following rules are used to determine objectrefwhether an 
that is nullnot  is an instance of the resolved S is the type: classIf 
of the object referred objectrefto  and by T is the resolved class,
array, or interface instanceoftype,  determines whether objectref is
an instance of T as follows:
 If S is an ordinary (nonarray) class, then:
If T is a class type, S must then be the same Tclass , or Sas 
must be a subclass of T;
If T is an interface type, then S must implement interface T.
470
--------------------------------------- 489
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinstanceof
 If S is an interface type, then:
If T is a class type, then T must be Object.
If T is an interface type, T must then be the same interface as
S or a superinterface of S.
 If S is a class representing the SC[], array that type is, an array
of components of type SC, then:
If T is a class type, then T must be Object.
If T is an interface type, T must then be one of the interfaces
implemented by arrays (JLS 4.10.3).
If T is an array TC[]type , that is, an array of components of
type TC, then one of the following must be true:
VTC and SC are the same primitive type.
VTC and SC are reference types, SC and can type be cast TCto 
by these runtime rules.
LinkingDuring resolution of the symbolic reference to the class, array, or
interface type, any of the exceptions 5.4.3.1documented  canin 
Exceptions
be thrown.
NotesThe instanceof instruction is very similar checkcastto the 
instruction checkcast(). It differs in its nulltreatment , itsof 
behavior when its test checkcastfails  throws (an exception,
instanceof pushes a result code), and its effect on the operand
stack.
471
--------------------------------------- 490
invokedynamicTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
invokedynamicinvokedynamic
Operation Invoke dynamic method
Formatinvokedynamic
indexbyte1
indexbyte2
0
0
Formsinvokedynamic = 186 (0xba)
Operand..., [arg1, [arg2 ...]] 
Stack...
DescriptionEach specific lexical occurrence invokedynamicof  an instruction
is called a dynamic call site.
First, the unsigned indexbyte1 and indexbyte2 are used to construct
an index into the runtime constant pool 2.6of ),the current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a call site 5.1). specifier The values (of the third and
fourth operand bytes must always be zero.
The call site specifier is 5.4.3.6resolved ) for this(
specific dynamic call  to siteobtain referencea  to a
java.lang.invoke.MethodHandle instance, referencea  to a
java.lang.invoke.MethodType instance, referenceand s to
static arguments.
Next, as part of the continuing resolution of the call site specifier,
the bootstrap method is invoked as if by execution of an
invokevirtual instruction invokevirtual() that contains a runtime
constant pool index to a symbolic reference 5.1) to a method (
with the following properties:
 The method's name is invoke;
472
--------------------------------------- 491
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokedynamic
 The method's descriptor has a return type of
java.lang.invoke.CallSite;
 The method's descriptor has parameter types derived from the
items pushed on to the operand stack, as follows.
The first four parameter types in
the descriptor java.lang.invoke.MethodHandleare ,
java.lang.invoke.MethodHandles.Lookup, String, and
java.lang.invoke.MethodType, in that order.
If the call site specifier has any static arguments, then a
parameter type for each argument is appended to the parameter
types of the method descriptor in the order that the arguments
were pushed on to the operand stack. These parameter
types may be Class, java.lang.invoke.MethodHandle,
java.lang.invoke.MethodType, String, int, long, float, or
double.
 The method's symbolic reference to the class in
which the method is to be found indicates the class
java.lang.invoke.MethodHandle.
where it is as if the following items were pushed, in order, onto
the operand stack:
 the reference to the java.lang.invoke.MethodHandle object
for the bootstrap method;
 a reference to java.lang.invoke.MethodHandles.Lookupa 
object for the class in which this dynamic call site occurs;
 a reference to the String for the method name in the call site
specifier;
 the reference to the java.lang.invoke.MethodType object
obtained for the method descriptor in the call site specifier;
references to classes, method types, method handles, and
string literals denoted as static arguments in the call site
specifier, and numeric 2.3.1values , 2.3.2) ( denoted as static
arguments in the call site specifier, in the order in which they
appear in the call site specifier. (That is, no boxing occurs for
primitive values.)
473
--------------------------------------- 492
invokedynamicTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
As long as the bootstrap method can be correctly invoked
by the invoke method, its descriptor is arbitrary. For
example, the first parameter type Objectcould  instead be of
java.lang.invoke.MethodHandles.Lookup, and the return type
could also be Object instead of java.lang.invoke.CallSite.
If the bootstrap method is a variable arity method, then some or
all of the arguments on the operand stack specified above may be
collected into a trailing array parameter.
The invocation of a bootstrap method occurs within a thread
that is attempting resolution of the symbolic reference to the
call site specifier of this dynamic call . If sitethere are several
such threads, the bootstrap method may be invoked in several
threads concurrently. Therefore, bootstrap methods which access
global application data must take the usual precautions against race
conditions.
The result returned by the bootstrap referencemethod must be a 
to an object whose java.lang.invoke.CallSiteclass is  or a
subclass java.lang.invoke.CallSiteof . This object is known
as the call site . objectThe reference is popped from the operand
stack used as if in the execution of an invokevirtual instruction.
If several threads simultaneously execute the bootstrap method for
the same dynamic call site, the Java virtual machine must choose
one returned call site object and install it visibly to all threads. Any
other bootstrap methods executing for the dynamic call site are
allowed to complete, but their results are ignored, and the threads'
execution of the dynamic call site proceeds with the chosen call
site object.
The call site object has a type descriptor (an instance of
java.lang.invoke.MethodType) which must be semantically
equal to java.lang.invoke.MethodTypethe  object obtained for
the method descriptor in the call site specifier.
The result of successful call site specifier resolution is a call site
object which is permanently bound to the dynamic call site.
The method handle represented by the target of the bound call site
object is invoked. The invocation occurs as if by execution of an
invokevirtual instruction invokevirtual() that indicates a runtime
474
--------------------------------------- 493
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokedynamic
constant pool index to a symbolic reference 5.1) to a method (
with the following properties:
 The method's name is invokeExact;
 The method's descriptor is the method descriptor in the call site
specifier; and
 The method's symbolic reference to the class in
which the method is to be found indicates the class
java.lang.invoke.MethodHandle.
The operand stack will be interpreted referenceas containing a 
to the target of the call site object, nargs argumentfollowed by 
values, where the number, type, and order of the values must be
consistent with the method descriptor in the call site specifier.
LinkingIf resolution of the symbolic reference to the call site specifier
Exceptionsthrows an exception E, the invokedynamic instruction throws a
BootstrapMethodError that wraps E.
Otherwise, during the continuing resolution of the call site
specifier, if invocation of the bootstrap method completes
abruptly 2.6.5( ) because of a throw of Eexception , the
invokedynamic instruction throws BootstrapMethodErrora 
that wraps E. (This can occur if the bootstrap method
has the wrong arity, parameter type, or return type,
causing java.lang.invoke.MethodHandle . invoke to throw
java.lang.invoke.WrongMethodTypeException.)
Otherwise, during the continuing resolution of the call site
specifier, if the result from the bootstrap method invocation is not
a reference to an instance java.lang.invoke.CallSiteof , the
invokedynamic instruction throws a BootstrapMethodError.
Otherwise, during the continuing resolution of the call site
specifier, if the type descriptor of the target of the call site
object is not semantically equal to the method descriptor in
the call site specifier, invokedynamicthe  instruction throws a
BootstrapMethodError.
RuntimeIf this specific dynamic call site completed resolution of its call site
specifier, it implies nullthat  referencea non- to an instance of
Exceptions
java.lang.invoke.CallSite is bound to this dynamic call site.
475
--------------------------------------- 494
invokedynamicTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
Therefore, the operand stack item which referencerepresents  toa 
the target of the call site nullobject . Similarly, is never it implies
that the method descriptor in the call site specifier is semantically
equal to the type descriptor method of handle the to be  invokedas
if by execution of an invokevirtual instruction.
These invariants mean invokedynamicthat an  instruction which is
bound to a call site object NullPointerExceptionnever throws a 
or a java.lang.invoke.WrongMethodTypeException.
476
--------------------------------------- 495
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokeinterface
invokeinterfaceinvokeinterface
Operation Invoke interface method
Formatinvokeinterface
indexbyte1
indexbyte2
count
0
Formsinvokeinterface = 185 (0xb9)
Operand..., objectref, [arg1, [arg2 ...]] 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to an interface 5.1), method which ( gives the name and
descriptor 4.3.3() of the interface method as well as a symbolic
reference to the interface in which the interface method is to be
found. The named interface method 5.4.3.4is resolved ). The (
resolved interface method must not be an instance initialization
method 2.9( ) or the class or interface initialization 2.9).method (
The count operand is an unsigned byte that must not be zero. The
objectref must be of referencetype  and must be followed on the
operand stack nargsby  argument values, where the number, type,
and order of the values must be consistent with the descriptor of the
resolved interface method. The value of the fourth operand byte
must always be zero.
Let C be the class objectrefof . The actual method to be invoked is
selected by the following lookup procedure:
 If C contains a declaration for an instance method with the same
name and descriptor as the resolved method, then this is the
method to be invoked, and the lookup procedure terminates.
477
--------------------------------------- 496
invokeinterfaceTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
 Otherwise, C if has a superclass, this same lookup procedure
is performed recursively using the direct C; thesuperclass of 
method to be invoked is the result of the recursive invocation of
this lookup procedure.
 Otherwise, an AbstractMethodError is raised.
If the method synchronizedis , the monitor associated with
objectref is entered or reentered as if by execution of a
monitorenter instruction (monitorenter) in the current thread.
If the method is nativenot , the nargs argument values and
objectref are popped from the operand stack. A new frame is
created on the Java virtual machine stack for the method being
invoked. The objectref and the argument values are consecutively
made the values of local variables of the objectrefnew frame, with 
in local variable arg1 in 0, local variable arg11  (or, is ofif 
type long or double, in local variables 1 and 2), and so on. Any
argument value that is of a floating-point type undergoes value
set conversion 2.8.3) ( prior to being stored in a local variable.
The new frame is then made current, and the Java virtual machine
pc is set to the opcode of the first instruction of the method to
be invoked. Execution continues with the first instruction of the
method.
If the method nativeis  and the platform-dependent code that
implements it has not yet 5.6been ) into bound the ( Java virtual
machine, that is done. nargs The argument values objectrefand 
are popped from the operand stack and are passed as parameters
to the code that implements the method. Any argument value that
is of a floating-point type undergoes value 2.8.3)set conversion (
prior to being passed as a parameter. The parameters are passed
and the code is invoked in an implementation-dependent manner.
When the platform-dependent code returns:
 If the native method synchronizedis , the monitor associated
with objectref is updated and possibly exited as if by execution
of monitorexita  instruction monitorexit() in the current thread.
 If the native method returns a value, the return value of the
platform-dependent code is converted in an implementation-
dependent way to the return nativetype  of method the and
pushed onto the operand stack.
478
--------------------------------------- 497
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokeinterface
LinkingDuring resolution of the symbolic reference to the interface
method, any of the exceptions pertaining to interface method
Exceptionsresolution (5.4.3.4) can be thrown.
RuntimeOtherwise, objectrefif  is null, the invokeinterface instruction
Exceptionsthrows a NullPointerException.
Otherwise, if the class objectrefof  does not
implement the resolved interface, invokeinterface throws an
IncompatibleClassChangeError.
Otherwise, if no method matching the resolved name
and descriptor is selected, invokeinterface throws an
AbstractMethodError.
Otherwise, if the selected method public, invokeinterfaceis not 
throws an IllegalAccessError.
Otherwise, if the selected abstractmethod , invokeinterfaceis 
throws an AbstractMethodError.
Otherwise, if the selected nativemethod  and is the code that
implements the method cannot invokeinterfacebe bound,  throws
an UnsatisfiedLinkError.
NotesThe count operand of invokeinterfacethe  instruction records a
measure of the number of argument values, where an argument
value of type long or type double contributes two units to the
count value and an argument of any other type contributes one
unit. This information can also be derived from the descriptor of
the selected method. The redundancy is historical.
The fourth operand byte exists to reserve space for an additional
operand used in certain of Oracle's implementations, which
replace invokeinterfacethe  instruction by a specialized pseudo-
instruction at runtime. It must be retained for backwards
compatibility.
The nargs argument values objectrefand  are not one-to-one with
the first nargs+1 local variables. Argument values longof types 
and double must be stored in two consecutive local variables, thus
more than nargs local variables may be required nargs to pass 
argument values to the invoked method.
479
--------------------------------------- 498
invokespecialTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
invokespecialinvokespecial
Operation Invoke instance method; special handling for superclass, private,
and instance initialization method invocations
Formatinvokespecial
indexbyte1
indexbyte2
Formsinvokespecial = 183 (0xb7)
Operand..., objectref, [arg1, [arg2 ...]] 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a method 5.1), which (gives the name and descriptor
(4.3.3) of the method as well as a symbolic reference to the class
in which the method is to be found. The named method is resolved
(5.4.3.3). Finally, if the resolved protectedmethod  (4.6), is and
it is a member of a superclass of the current class, and the method
is not declared in the same runtime 5.3) as package the current(
class, then the objectrefclass  of must be either the current class or
a subclass of the current class.
Next, the resolved method is selected for invocation unless all of
the following conditions are true:
 The ACC_SUPER flag (Table 4.1) is set for the current class.
 The class of the resolved method is a superclass of the current
class.
 The resolved method is not an instance initialization method
(2.9).
480
--------------------------------------- 499
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokespecial
If the above conditions are true, the actual method to be invoked
is selected by the following lookup C be procedure. the directLet 
superclass of the current class:
 If C contains a declaration for an instance method with the same
name and descriptor as the resolved method, then this method
will be invoked. The lookup procedure terminates.
 Otherwise, C if has a superclass, this same lookup procedure
is performed recursively using the direct C. Thesuperclass of 
method to be invoked is the result of the recursive invocation of
this lookup procedure.
 Otherwise, an AbstractMethodError is raised.
The objectref must be of referencetype  and must be followed on
the operand stack nargsby  argument values, where the number,
type, and order of the values must be consistent with the descriptor
of the selected instance method.
If the method synchronizedis , the monitor associated with
objectref is entered or reentered as if by execution of a
monitorenter instruction (monitorenter) in the current thread.
If the method is nativenot , the nargs argument values and
objectref are popped from the operand stack. A new frame is
created on the Java virtual machine stack for the method being
invoked. The objectref and the argument values are consecutively
made the values of local variables of the objectrefnew frame, with 
in local variable arg1 in 0, local variable arg11  (or, is ofif 
type long or double, in local variables 1 and 2), and so on. Any
argument value that is of a floating-point type undergoes value
set conversion 2.8.3) ( prior to being stored in a local variable.
The new frame is then made current, and the Java virtual machine
pc is set to the opcode of the first instruction of the method to
be invoked. Execution continues with the first instruction of the
method.
If the method nativeis  and the platform-dependent code that
implements it has not yet 5.6been ) into bound the ( Java virtual
machine, that is done. nargs argument The values objectrefand  are
popped from the operand stack and are passed as parameters to the
code that implements the method. Any argument value that is of a
floating-point type undergoes value 2.8.3set ) conversion prior(
481
--------------------------------------- 500
invokespecialTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
to being passed as a parameter. The parameters are passed and the
code is invoked in an implementation-dependent manner. When
the platform-dependent code returns, the following take place:
 If the native method synchronizedis , the monitor associated
with objectref is updated and possibly exited as if by execution
of monitorexita  instruction monitorexit() in the current thread.
 If the native method returns a value, the return value of the
platform-dependent code is converted in an implementation-
dependent way to the return nativetype  of method the and
pushed onto the operand stack.
LinkingDuring resolution of the symbolic reference to the method, any of
Exceptionsthe exceptions pertaining to method 5.4.3.3resolution ) can be (
thrown.
Otherwise, if the resolved method is an instance initialization
method, and the class in which it is declared is not the class
symbolically referenced by the NoSuchMethodErrorinstruction, a 
is thrown.
Otherwise, if the resolved method is a class
(static) method, the invokespecial instruction throws an
IncompatibleClassChangeError.
RuntimeOtherwise, objectrefif  is null, the invokespecial instruction
throws a NullPointerException.
Exceptions
Otherwise, if no method matching the resolved name
and descriptor is selected, invokespecial throws an
AbstractMethodError.
Otherwise, if the selected abstractmethod , invokespecialis 
throws an AbstractMethodError.
Otherwise, if the selected nativemethod  and is the code that
implements the method cannot invokespecialbe bound,  throws an
UnsatisfiedLinkError.
NotesThe difference between invokespecialthe  instruction and the
invokevirtual instruction invokevirtual() is that invokevirtual
invokes a method based on the class of the object. The
invokespecial instruction is used to invoke instance initialization
482
--------------------------------------- 501
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokespecial
methods 2.9( ) as well privateas  methods and methods of a
superclass of the current class.
The invokespecial instruction was invokenonvirtualnamed  prior
to JDK release 1.0.2.
The nargs argument values objectrefand  are not one-to-one with
the first nargs+1 local variables. Argument values longof types 
and double must be stored in two consecutive local variables, thus
more than nargs local variables may be required nargs to pass 
argument values to the invoked method.
483
--------------------------------------- 502
invokestaticTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
invokestaticinvokestatic
Operation Invoke a class (static) method
Formatinvokestatic
indexbyte1
indexbyte2
Formsinvokestatic = 184 (0xb8)
Operand..., [arg1, [arg2 ...]] 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a method 5.1), which (gives the name and descriptor
(4.3.3) of the method as well as a symbolic reference to the
class in which the method is to be found. The named method
is resolved 5.4.3.3( ). The resolved method must not be an
instance initialization 2.9) method or the ( class or interface
initialization method 2.9). It ( must staticbe , and therefore
cannot be abstract.
On successful resolution of the method, the class that declared the
resolved method is initialized 5.5) if that ( class has not already
been initialized.
The operand stack must nargscontain  argument values, where the
number, type, and order of the values must be consistent with the
descriptor of the resolved method.
If the method synchronizedis , the monitor associated with the
resolved Class object is entered or reentered as if by execution of
a monitorenter instruction (monitorenter) in the current thread.
If the method nativeis not , the nargs argument values are popped
from the operand stack. A new frame is created on the Java virtual
machine stack for the method being nargsinvoked.  argumentThe 
484
--------------------------------------- 503
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokestatic
values are consecutively made the values of local variables of
the new frame, arg1with  in local variable arg10  (or, is ofif 
type long or double, in local variables 0 and 1) and so on. Any
argument value that is of a floating-point type undergoes value
set conversion 2.8.3) ( prior to being stored in a local variable.
The new frame is then made current, and the Java virtual machine
pc is set to the opcode of the first instruction of the method to
be invoked. Execution continues with the first instruction of the
method.
If the method nativeis  and the platform-dependent code that
implements it has not yet 5.6been ) into bound the ( Java virtual
machine, that is done. nargs argument The values are popped from
the operand stack and are passed as parameters to the code that
implements the method. Any argument value that is of a floating-
point type undergoes value set 2.8.3conversion ) prior to ( being
passed as a parameter. The parameters are passed and the code
is invoked in an implementation-dependent manner. When the
platform-dependent code returns, the following take place:
 If the native method synchronizedis , the monitor associated
with the resolved Class object is updated and possibly exited
as if by execution monitorexitof a  instruction monitorexit() in
the current thread.
 If the native method returns a value, the return value of the
platform-dependent code is converted in an implementation-
dependent way to the return nativetype  of method the and
pushed onto the operand stack.
LinkingDuring resolution of the symbolic reference to the method, any of
the exceptions pertaining to method 5.4.3.3resolution ) can be (
Exceptions
thrown.
Otherwise, if the resolved method is an instance
method, the invokestatic instruction throws an
IncompatibleClassChangeError.
RuntimeOtherwise, if execution invokestaticof this  instruction causes
Exceptionsinitialization of the referenced invokestatic class, may throw an
Error as detailed in 5.5.
485
--------------------------------------- 504
invokestaticTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
Otherwise, if the resolved nativemethod  and is the code that
implements the method cannot invokestaticbe bound,  throws an
UnsatisfiedLinkError.
NotesThe nargs argument values are not one-to-one nargswith the first 
local variables. Argument values long and of doubletypes  must
be stored in two consecutive local variables, nargs thus more than 
local variables may be required nargs argument to pass values to
the invoked method.
486
--------------------------------------- 505
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokevirtual
invokevirtualinvokevirtual
Operation Invoke instance method; dispatch based on class
Formatinvokevirtual
indexbyte1
indexbyte2
Formsinvokevirtual = 182 (0xb6)
Operand..., objectref, [arg1, [arg2 ...]] 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a method 5.1), which (gives the name and descriptor
(4.3.3) of the method as well as a symbolic reference to the
class in which the method is to be found. The named method is
resolved 5.4.3.3( ). The resolved method must not be an instance
initialization 2.9method ) or (the class or interface initialization
method 2.9( ). Finally, if the resolved protectedmethod is 
(4.6), and it is a member of a superclass of the current class, and
the method is not declared in the same 5.3runtime )package (
as the current class, then objectrefthe  class must be of either the
current class or a subclass of the current class.
If the resolved method is not signature  2.9( ), polymorphicthen
the invokevirtual instruction proceeds as follows.
Let C be the class objectrefof . The actual method to be invoked is
selected by the following lookup procedure:
 If C contains a declaration for an instance m thatmethod 
overrides 5.4.5( ) the resolved method, m is then the method to
be invoked, and the lookup procedure terminates.
 Otherwise, C if has a superclass, this same lookup procedure
is performed recursively using the direct C; thesuperclass of 
487
--------------------------------------- 506
invokevirtualTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
method to be invoked is the result of the recursive invocation of
this lookup procedure.
 Otherwise, an AbstractMethodError is raised.
The objectref must be followed on the operand nargsstack by 
argument values, where the number, type, and order of the values
must be consistent with the descriptor of the selected instance
method.
If the method synchronizedis , the monitor associated with
objectref is entered or reentered as if by execution of a
monitorenter instruction (monitorenter) in the current thread.
If the method is nativenot , the nargs argument values and
objectref are popped from the operand stack. A new frame is
created on the Java virtual machine stack for the method being
invoked. The objectref and the argument values are consecutively
made the values of local variables of the objectrefnew frame, with 
in local variable arg1 in 0, local variable arg11  (or, is ofif 
type long or double, in local variables 1 and 2), and so on. Any
argument value that is of a floating-point type undergoes value
set conversion 2.8.3) ( prior to being stored in a local variable.
The new frame is then made current, and the Java virtual machine
pc is set to the opcode of the first instruction of the method to
be invoked. Execution continues with the first instruction of the
method.
If the method nativeis  and the platform-dependent code that
implements it has not yet 5.6been ) into bound the ( Java virtual
machine, that is done. nargs argument The values objectrefand  are
popped from the operand stack and are passed as parameters to the
code that implements the method. Any argument value that is of a
floating-point type undergoes value 2.8.3set ) conversion prior(
to being passed as a parameter. The parameters are passed and the
code is invoked in an implementation-dependent manner. When
the platform-dependent code returns, the following take place:
 If the native method synchronizedis , the monitor associated
with objectref is updated and possibly exited as if by execution
of monitorexita  instruction monitorexit() in the current thread.
 If the native method returns a value, the return value of the
platform-dependent code is converted in an implementation-
488
--------------------------------------- 507
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokevirtual
dependent way to the return nativetype  of method the and
pushed onto the operand stack.
If the resolved method is signature  (2.9), polymorphicthen the
invokevirtual instruction proceeds as follows.
First, a reference to an instance of
java.lang.invoke.MethodType is obtained as if by resolution
of a symbolic reference to a 5.4.3.5method ) type with (the
same parameter and return types as the descriptor of the method
referenced by the invokevirtual instruction.
 If the named method invokeExactis , the instance of
java.lang.invoke.MethodType must be semantically equal to
the type descriptor of the receiving objectrefmethod . Thehandle 
method handle to be invoked is objectref.
 If the named method invokeis , and the instance of
java.lang.invoke.MethodType is semantically equal to the
type descriptor of the receiving objectrefmethod , thenhandle 
the method handle to be invoked is objectref.
 If the named method invokeis , and the instance of
java.lang.invoke.MethodType is not semantically equal to
the type descriptor of the receiving objectrefmethod ,handle 
then the Java virtual machine attempts to adjust the type
descriptor of the receiving method handle, as if by a call
to java.lang.invoke.MethodHandle.asType, to obtain an
exactly invokable method m. handle The method handle to be
invoked is m.
The objectref must be followed on the operand nargsstack by 
argument values, where the number, type, and order of the values
must be consistent with the type descriptor of the method handle
to be invoked. (This type descriptor will correspond to the method
descriptor appropriate for the kind of the method handle to be
invoked, as specified in 5.4.3.5.)
Then, if the method handle to be invoked has bytecode
behavior, the Java virtual machine invokes the method
handle as if by execution of the bytecode behavior
associated with the method handle's kind. If the kind
is 5 REF_invokeVirtual(), 6 REF_invokeStatic(), 7
(REF_invokeSpecial), 8 REF_newInvokeSpecial(), or 9
489
--------------------------------------- 508
invokevirtualTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
(REF_invokeInterface), then a frame will be created and made
current in the course of executing the bytecode ; when thebehavior
method invoked by the bytecode behavior completes (normally or
abruptly), frame the of its invoker is considered to be the frame for
the method containing this invokevirtual instruction.
The frame in which the bytecode behavior itself executes is not visible.
Otherwise, if the method handle to be invoked has no
bytecode behavior, the Java virtual machine invokes it in an
implementation-dependent manner.
LinkingDuring resolution of the symbolic reference to the method, any of
Exceptionsthe exceptions pertaining to method 5.4.3.3resolution ) can be (
thrown.
Otherwise, if the resolved method is a class
(static) method, the invokevirtual instruction throws an
IncompatibleClassChangeError.
Otherwise, if the resolved method is signature polymorphic, then
during resolution of the method type derived from the descriptor
in the symbolic reference to the method, any of the exceptions
pertaining to method type resolution (5.4.3.5) can be thrown.
RuntimeOtherwise, objectrefif  is null, the invokevirtual instruction
throws a NullPointerException.
Exceptions
Otherwise, if the resolved method is not signature polymorphic:
 If no method matching the resolved name and descriptor is
selected, invokevirtual throws an AbstractMethodError.
 Otherwise, if the selected abstractmethod , invokevirtualis 
throws an AbstractMethodError.
 Otherwise, if the selected nativemethod  and is the code that
implements the method cannot invokevirtualbe bound,  throws
an UnsatisfiedLinkError.
Otherwise, if the resolved method is signature polymorphic, then:
 If the method name invokeExactis , and the
obtained instance java.lang.invoke.MethodTypeof  is not
semantically equal to the type descriptor of the receiving
490
--------------------------------------- 509
THE JAVA VIRTUAL MACHINE INSTRUCTION SETinvokevirtual
method handle, invokevirtualthe  instruction throws a
java.lang.invoke.WrongMethodTypeException.
 If the method name invokeis , and the obtained instance of
java.lang.invoke.MethodType is not a valid argument to the
java.lang.invoke.MethodHandle.asType method invoked
on the receiving method handle, invokevirtualthe  instruction
throws a java.lang.invoke.WrongMethodTypeException.
NotesThe nargs argument values objectrefand  are not one-to-one with
the first nargs+1 local variables. Argument values longof types 
and double must be stored in two consecutive local variables, thus
more than nargs local variables may be required nargs to pass 
argument values to the invoked method.
491
--------------------------------------- 510
iorTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
iorior
Operation Boolean OR int
Formatior
Formsior = 128 (0x80)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . They are popped from
the operand stack. int resultAn  is calculated by taking the bitwise
inclusive OR value1of  and value2. The result is pushed onto the
operand stack.
492
--------------------------------------- 511
THE JAVA VIRTUAL MACHINE INSTRUCTION SETirem
iremirem
Operation Remainder int
Formatirem
Formsirem = 112 (0x70)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultThe  is value1 - value1( / value2)
* value2. The result is pushed onto the operand stack.
The result of iremthe  instruction is (a/b)*b such that + (a%b) is
equal ato . This identity holds even in the special case in which the
dividend is the negative int of largest possible magnitude for its
type and the divisor is -1 (the remainder is 0). It follows from this
rule that the result of the remainder operation can be negative only
if the dividend is negative and can be positive only if the dividend
is positive. Moreover, the magnitude of the result is always less
than the magnitude of the divisor.
RuntimeIf the value of the divisor int remainder for an operator iremis 0, 
throws an ArithmeticException.
Exception
493
--------------------------------------- 512
ireturnTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
ireturnireturn
Operation Return int from method
Formatireturn
Formsireturn = 172 (0xac)
Operand..., value 
Stack[empty]
DescriptionThe current method must have booleanreturn , bytetype , short,
char, or int. The value must be of inttype . If the current method
is synchronizeda  method, the monitor entered or reentered on
invocation of the method is updated and possibly exited as if by
execution monitorexitof a  instruction monitorexit() in the current
thread. If no exception valueis  is thrown, popped from the operand
stack of the current 2.6) frame and pushed (onto the operand stack
of the frame of the invoker. Any other values on the operand stack
of the current method are discarded.
The interpreter then returns control to the invoker of the method,
reinstating the frame of the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
rules on structured locking 2.11.10described , then in if the
Exceptions
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, ireturn throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then ireturn throws an IllegalMonitorStateException.
494
--------------------------------------- 513
THE JAVA VIRTUAL MACHINE INSTRUCTION SETishl
ishlishl
Operation Shift left int
Formatishl
Formsishl = 120 (0x78)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultAn  is calculated by shifting
value1 left s by bit positions, s is where the value of the low 5 bits
of value2. The result is pushed onto the operand stack.
NotesThis is equivalent (even if overflow occurs) to multiplication by
2 to the power s. The shift distance actually used is always in the
range 0 to 31, inclusive, value2 were as if subjected to a bitwise
logical AND with the mask value 0x1f.
495
--------------------------------------- 514
ishrTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
ishrishr
Operation Arithmetic shift right int
Formatishr
Formsishr = 122 (0x7a)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultAn  is calculated by shifting
value1 right s by bit positions, with sign extension, s is the where 
value of the low 5 value2bits . The of result is pushed onto the
operand stack.
s
NotesThe resulting value 
 value1is  /  2, where s is value2 & 0x1f. For
non-negative value1, this is equivalent to int truncating division
by 2 to the power s. The shift distance actually used is always in
the range 0 to 31, inclusive, value2 were as subjected if to a bitwise
logical AND with the mask value 0x1f.
496
--------------------------------------- 515
THE JAVA VIRTUAL MACHINE INSTRUCTION SETistore
istoreistore
Operation Store int into local variable
Formatistore
index
Formsistore = 54 (0x36)
Operand..., value 
Stack...
DescriptionThe index is an unsigned byte that must be an index into the local
variable array of the current 2.6). The frame value (on the top
of the operand stack must intbe . of It type is popped from the
operand stack, and the value of the indexlocal  is variable setat 
to value.
NotesThe istore opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
497
--------------------------------------- 516
istore_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
istore_<n>istore_<n>
Operation Store int into local variable
Formatistore_<n>
Formsistore_0 = 59 (0x3b)
istore_1 = 60 (0x3c)
istore_2 = 61 (0x3d)
istore_3 = 62 (0x3e)
Operand..., value 
Stack...
DescriptionThe <n> must be an index into the local variable array of the
current frame 2.6). ( The value on the top of the operand stack
must be of inttype . It is popped from the operand stack, and the
value of the local variable at <n> is set to value.
NotesEach of the istore_<n> instructions is the istoresame  with as an
index of <n>, except that the operand <n> is implicit.
498
--------------------------------------- 517
THE JAVA VIRTUAL MACHINE INSTRUCTION SETisub
isubisub
Operation Subtract int
Formatisub
Formsisub = 100 (0x64)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultThe  is value1 - value2. The
result is pushed onto the operand stack.
For int subtraction, a-b produces the same result a+(-b). as For
int values, subtraction from zero is the same as negation.
The result is the 32 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type int. If overflow occurs, then the sign of the result
may not be the same as the sign of the mathematical difference of
the two values.
Despite the fact that overflow may occur, isubexecution of an 
instruction never throws a runtime exception.
499
--------------------------------------- 518
iushrTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
iushriushr
Operation Logical shift right int
Formatiushr
Formsiushr = 124 (0x7c)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . The values are popped
from the operand stack. int resultAn  is calculated by shifting
value1 right s by bit positions, with zero extension, s is the where 
value of the low 5 value2bits . The of result is pushed onto the
operand stack.
NotesIf value1 is positive s is and value2 & 0x1f, the result is the same
as that value1of  >> s; if value1 is negative, the result is equal to
the value of the expression value1 >> s) (+ (2 << ~s). The addition
of the <<(2  ~s) term cancels out the propagated sign bit. The shift
distance actually used is always in the range 0 to 31, inclusive.
500
--------------------------------------- 519
THE JAVA VIRTUAL MACHINE INSTRUCTION SETixor
ixorixor
Operation Boolean XOR int
Formatixor
Formsixor = 130 (0x82)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of inttype . They are popped from
the operand stack. int resultAn  is calculated by taking the bitwise
exclusive OR value1of  and value2. The result is pushed onto the
operand stack.
501
--------------------------------------- 520
jsrTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
jsrjsr
Operation Jump subroutine
Formatjsr
branchbyte1
branchbyte2
Formsjsr = 168 (0xa8)
Operand... 
Stack..., address
DescriptionThe address of the opcode of the instruction immediately
following jsrthis  instruction is pushed onto the operand stack as
a value of returnAddresstype . The unsigned branchbyte1 and
branchbyte2 are used to construct a signed 16-bit offset, where
the offset branchbyte1is ( << 8) branchbyte2| . Execution proceeds
at that offset from the address jsr instruction. of this The target
address must be that of an opcode of an instruction within the
method that contains this jsr instruction.
NotesNote that jsr pushes the address onto the operand ret stack and 
(ret) gets it out of a local variable. This asymmetry is intentional.
In Oracle's implementation of a compiler for the Java
programming language prior to Java jsr instruction SE 6, the was
used with retthe  instruction in the implementation finallyof the 
clause (3.13, 4.10.2.5).
502
--------------------------------------- 521
THE JAVA VIRTUAL MACHINE INSTRUCTION SETjsr_w
jsr_wjsr_w
Operation Jump subroutine (wide index)
Formatjsr_w
branchbyte1
branchbyte2
branchbyte3
branchbyte4
Formsjsr_w = 201 (0xc9)
Operand... 
Stack..., address
DescriptionThe address of the opcode of the instruction immediately
following jsr_wthis  instruction is pushed onto the operand stack
as a value of returnAddresstype . The unsigned branchbyte1,
branchbyte2, branchbyte3, and branchbyte4 are used to construct
a signed 32-bit offset, where branchbyte1the offset  << 24) is |(
(branchbyte2 << 16) branchbyte3| ( << 8) branchbyte4| . Execution
proceeds at that offset from the jsr_waddress  instruction.of this 
The target address must be that of an opcode of an instruction
within the method that contains this jsr_w instruction.
NotesNote that jsr_w pushes the address onto the operand retstack and 
(ret) gets it out of a local variable. This asymmetry is intentional.
In Oracle's implementation of a compiler for the Java
programming language prior to Java jsr_wSE  instruction6, the 
was used with retthe  instruction in the implementation of the
finally clause (3.13, 4.10.2.5).
Although the jsr_w instruction takes a 4-byte branch offset, other
factors limit the size of a method 4.11to ). 65535 This bytes limit (
may be raised in a future release of the Java virtual machine.
503
--------------------------------------- 522
l2dTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
l2dl2d
Operation Convert long to double
Formatl2d
Formsl2d = 138 (0x8a)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack longmust . Itbe of type 
is popped from the operand stack and doubleconverted  result to a 
using IEEE 754 round to nearest resultmode.  is pushed The onto
the operand stack.
NotesThe l2d instruction performs a widening primitive conversion (JLS
5.1.2) that may lose precision because doublevalues  have of type 
only 53 significand bits.
504
--------------------------------------- 523
THE JAVA VIRTUAL MACHINE INSTRUCTION SETl2f
l2fl2f
Operation Convert long to float
Formatl2f
Formsl2f = 137 (0x89)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack longmust . Itbe of type 
is popped from the operand stack and floatconverted  result to a 
using IEEE 754 round to nearest resultmode.  is pushed The onto
the operand stack.
NotesThe l2f instruction performs a widening primitive conversion (JLS
5.1.2) that may lose precision because floatvalues  have of type 
only 24 significand bits.
505
--------------------------------------- 524
l2iTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
l2il2i
Operation Convert long to int
Formatl2i
Formsl2i = 136 (0x88)
Operand..., value 
Stack..., result
DescriptionThe value on the top of the operand stack longmust . Itbe of type 
is popped from the operand stack and intconverted  result to an 
by taking the low-order 32 longbits  value of the and discarding
the high-order 32 bits. result is The pushed onto the operand stack.
NotesThe l2i instruction performs a narrowing primitive conversion
(JLS 5.1.3). It may lose information about the overall magnitude
of value. The result may also not have the same sign as value.
506
--------------------------------------- 525
THE JAVA VIRTUAL MACHINE INSTRUCTION SETladd
laddladd
Operation Add long
Formatladd
Formsladd = 97 (0x61)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . The values are
popped from the operand stack. long resultThe  is value1 + value2.
The result is pushed onto the operand stack.
The result is the 64 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type long. If overflow occurs, the sign of the result may
not be the same as the sign of the mathematical sum of the two
values.
Despite the fact that overflow may occur, laddexecution of an 
instruction never throws a runtime exception.
507
--------------------------------------- 526
laloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
laloadlaload
Operation Load long from array
Formatlaload
Formslaload = 47 (0x2f)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are longof type . The index must be of type
int. Both arrayref and index are popped from the operand stack.
The long value in the component of the indexarray  is retrievedat 
and pushed onto the operand stack.
RuntimeIf arrayref is null, laload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the laload instruction throws an
ArrayIndexOutOfBoundsException.
508
--------------------------------------- 527
THE JAVA VIRTUAL MACHINE INSTRUCTION SETland
landland
Operation Boolean AND long
Formatland
Formsland = 127 (0x7f)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . They are popped
from the operand stack. long resultA  is calculated by taking the
bitwise AND value1of  and value2. The result is pushed onto the
operand stack.
509
--------------------------------------- 528
lastoreTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lastorelastore
Operation Store into long array
Formatlastore
Formslastore = 80 (0x50)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are longof type . The index must be of type
int, and value must be of longtype . The arrayref, index, and value
are popped from the operand longstack.  value is The stored as the
component of the array indexed by index.
RuntimeIf arrayref is null, lastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the lastore instruction throws an
ArrayIndexOutOfBoundsException.
510
--------------------------------------- 529
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlcmp
lcmplcmp
Operation Compare long
Formatlcmp
Formslcmp = 148 (0x94)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . They are both
popped from the operand stack, and a signed integer comparison
is performed. value1If  is greater value2than , the int value 1 is
pushed onto the operand value1stack.  is If equal value2to , the
int value 0 is pushed onto the operand value1 is stack. less thanIf 
value2, the int value -1 is pushed onto the operand stack.
511
--------------------------------------- 530
lconst_<l>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
lconst_<l>lconst_<l>
Operation Push long constant
Formatlconst_<l>
Formslconst_0 = 9 (0x9)
lconst_1 = 10 (0xa)
Operand... 
Stack..., <l>
DescriptionPush the long constant <l> (0 or 1) onto the operand stack.
512
--------------------------------------- 531
THE JAVA VIRTUAL MACHINE INSTRUCTION SETldc
ldcldc
Operation Push item from runtime constant pool
Formatldc
index
Formsldc = 18 (0x12)
Operand... 
Stack..., value
DescriptionThe index is an unsigned byte that must be a valid index into
the runtime constant pool of the 2.6current ). The runtimeclass (
constant pool entry index either at must be a runtime constant of
type int or float, or referencea  to a string literal, or a symbolic
reference to a class, method type, or method handle (5.1).
If the runtime constant pool entry is a runtime constant of type
int or float, the numeric value of that runtime constant is pushed
onto the operand stack as an int or float, respectively.
Otherwise, if the runtime constant referencepool entry  to anis a 
instance of Stringclass  representing a string 5.1), literal then (
a reference to that instance, value, is pushed onto the operand
stack.
Otherwise, if the runtime constant pool entry is a symbolic
reference to a 5.1class ), then (the named class is resolved
(5.4.3.1) and referencea  to the Class object representing that
class, value, is pushed onto the operand stack.
Otherwise, the runtime constant pool entry must be a symbolic
reference to a method type or a 5.1method ). The handle method(
type or method handle is 5.4.3.5resolved ) and (referencea 
to the resulting instance java.lang.invoke.MethodTypeof  or
java.lang.invoke.MethodHandle, value, is pushed onto the
operand stack.
513
--------------------------------------- 532
ldcTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
LinkingDuring resolution of a symbolic reference to a class, any of the
exceptions pertaining to class 5.4.3.1resolution ) can be thrown.(
Exceptions
During resolution of a symbolic reference to a method type or
method handle, any of the exception pertaining to method type or
method handle resolution (5.4.3.5) can be thrown.
NotesThe ldc instruction can only be used to push floata value of type 
taken from the float 2.3.2value ) because set (a constant of type
float in the constant 4.4.4pool ) must (be taken from the float
value set.
514
--------------------------------------- 533
THE JAVA VIRTUAL MACHINE INSTRUCTION SETldc_w
ldc_wldc_w
Operation Push item from runtime constant pool (wide index)
Formatldc_w
indexbyte1
indexbyte2
Formsldc_w = 19 (0x13)
Operand... 
Stack..., value
DescriptionThe unsigned indexbyte1 and indexbyte2 are assembled into an
unsigned 16-bit index into the runtime constant pool of the
current class 2.6), ( where the value of the index is calculated as
(indexbyte1 << 8) indexbyte2| . The index must be a valid index
into the runtime constant pool of the current class. The runtime
constant pool entry at the index either must be a runtime constant
of type int or float, or referencea  to a string literal, or a
symbolic reference to a class, method type, or method handle
(5.1).
If the runtime constant pool entry is a runtime constant of type
int or float, the numeric value of that runtime constant is pushed
onto the operand stack as an int or float, respectively.
Otherwise, if the runtime constant referencepool entry  to anis a 
instance of Stringclass  representing a string 5.1), literal then (
a reference to that instance, value, is pushed onto the operand
stack.
Otherwise, if the runtime constant pool entry is a symbolic
reference to a 4.4.1class ). The (named class is 5.4.3.1resolved )(
and referencea  to the Class object representing valuethat , class, 
is pushed onto the operand stack.
Otherwise, the runtime constant pool entry must be a symbolic
reference to a method type or a 5.1method ). The handle method(
type or method handle is 5.4.3.5resolved ) and (referencea 
515
--------------------------------------- 534
ldc_wTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
to the resulting instance java.lang.invoke.MethodTypeof  or
java.lang.invoke.MethodHandle, value, is pushed onto the
operand stack.
LinkingDuring resolution of the symbolic reference to a class, any of the
Exceptionsexceptions pertaining to class 5.4.3.1resolution ) can be thrown.(
During resolution of a symbolic reference to a method type or
method handle, any of the exception pertaining to method type or
method handle resolution (5.4.3.5) can be thrown.
NotesThe ldc_w instruction is identical ldc instruction to the ldc) (
except for its wider runtime constant pool index.
The ldc_w instruction can only be used to push a value of type
float taken from the float 2.3.2value ) because set (a constant
of type float in the constant 4.4.4pool ) must (be taken from the
float value set.
516
--------------------------------------- 535
THE JAVA VIRTUAL MACHINE INSTRUCTION SETldc2_w
ldc2_wldc2_w
Operation Push long or double from runtime constant pool (wide index)
Formatldc2_w
indexbyte1
indexbyte2
Formsldc2_w = 20 (0x14)
Operand... 
Stack..., value
DescriptionThe unsigned indexbyte1 and indexbyte2 are assembled into an
unsigned 16-bit index into the runtime constant pool of the
current class 2.6), ( where the value of the index is calculated as
(indexbyte1 << 8) indexbyte2| . The index must be a valid index
into the runtime constant pool of the current class. The runtime
constant pool entry at the index must be a runtime constant of type
long or double (5.1). The numeric value of that runtime constant
is pushed onto the operand longstack  or doubleas , a respectively.
NotesOnly a wide-index version ldc2_wof  instruction the exists; there
is no ldc2 instruction that longpushes  or doublea  with a single-
byte index.
The ldc2_w instruction can only be used to push a value of type
double taken from the double 2.3.2value ) because set (a constant
of type double in the constant 4.4.5pool ) must (be taken from
the double value set.
517
--------------------------------------- 536
ldivTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
ldivldiv
Operation Divide long
Formatldiv
Formsldiv = 109 (0x6d)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . The values are
popped from the operand stack. long resultThe  is the value of
the Java programming language value1expression  / value2. The
result is pushed onto the operand stack.
A long division rounds towards 0; that is, the quotient produced
for long values n in / d is longa  value q whose magnitude is
as large as possible while d  satisfying q| d n||. Moreover, | q is
positive when n| e d||| and n and d have the same sign, q is but 
negative when |n| e |d| and n and d have opposite signs.
There is one special case that does not satisfy this rule: if the
dividend is the negative integer of largest possible magnitude for
the long type and the divisor is -1, then overflow occurs and the
result is equal to the dividend; despite the overflow, no exception
is thrown in this case.
RuntimeIf the value of the divisor long division in a ldivis  0, throws an
ExceptionArithmeticException.
518
--------------------------------------- 537
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlload
lloadlload
Operation Load long from local variable
Formatlload
index
Formslload = 22 (0x16)
Operand... 
Stack..., value
DescriptionThe index is an unsigned byte. index Both and index+1 must be
indices into the local variable array of 2.6the ). current frame (
The local variable index must at contain long. a The value of the
local variable at index is pushed onto the operand stack.
NotesThe lload opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
519
--------------------------------------- 538
lload_<n>THE JAVA VIRTUAL MACHINE INSTRUCTION SET
lload_<n>lload_<n>
Operation Load long from local variable
Formatlload_<n>
Formslload_0 = 30 (0x1e)
lload_1 = 31 (0x1f)
lload_2 = 32 (0x20)
lload_3 = 33 (0x21)
Operand... 
Stack..., value
DescriptionBoth n<> and n>+1 <must be indices into the local variable array
of the current 2.6frame ). The ( local variable n> must at contain<
a long. The value of the local variable n> is pushed at <onto the
operand stack.
NotesEach of the lload_<n> instructions is the lloadsame  with as an
index of <n>, except that the operand <n> is implicit.
520
--------------------------------------- 539
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlmul
lmullmul
Operation Multiply long
Formatlmul
Formslmul = 105 (0x69)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . The values are
popped from the operand stack. long resultThe  is value1 * value2.
The result is pushed onto the operand stack.
The result is the 64 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type long. If overflow occurs, the sign of the result may
not be the same as the sign of the mathematical sum of the two
values.
Despite the fact that overflow may occur, lmulexecution of an 
instruction never throws a runtime exception.
521
--------------------------------------- 540
lnegTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lneglneg
Operation Negate long
Formatlneg
Formslneg = 117 (0x75)
Operand..., value 
Stack..., result
DescriptionThe value must be of longtype . It is popped from the operand
stack. The long result is the arithmetic negation value, value- of .
The result is pushed onto the operand stack.
For long values, negation is the same as subtraction from
zero. Because the Java virtual machine uses two's-complement
representation for integers and the range of two's-complement
values is not symmetric, the negation of the maximum negative
long results in that same maximum negative number. Despite the
fact that overflow has occurred, no exception is thrown.
For all long values x, -x equals (~x)+1.
522
--------------------------------------- 541
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlookupswitch
lookupswitchlookupswitch
Operation Access jump table by key match and jump
Formatlookupswitch
<0-3 byte pad>
defaultbyte1
defaultbyte2
defaultbyte3
defaultbyte4
npairs1
npairs2
npairs3
npairs4
match-offset pairs...
Formslookupswitch = 171 (0xab)
Operand..., key 
Stack...
DescriptionA lookupswitch is a variable-length instruction. Immediately after
the lookupswitch opcode, between zero and three bytes must act
as padding, such defaultbyte1that  begins at an address that is
a multiple of four bytes from the start of the current method
(the opcode of its first instruction). Immediately after the padding
follow a series of signed 32-bit default, npairsvalues: , and then
npairs pairs of signed 32-bit npairsvalues.  must The be greater
than or equal to 0. Each npairs of pairs the consists int of matchan 
and a signed 32-bit offset. Each of these signed 32-bit values is
constructed from four unsigned byte1bytes  << 24) as byte2| (( <<
16) | (byte3 << 8) | byte4.
The table match-offset pairs of lookupswitchthe  instruction must
be sorted in increasing numerical order by match.
523
--------------------------------------- 542
lookupswitchTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
The key must be of inttype  and is popped from the operand
stack. The key is compared against match the values. If it is equal
to one of them, then a target address is calculated by adding
the corresponding offset to the address of the opcode of this
lookupswitch instruction. keyIf  does the not match any of the
match values, the target address is calculated default by adding 
to the address of the opcode lookupswitchof this  instruction.
Execution then continues at the target address.
The target address that can be calculated offset of eachfrom the 
match-offset pair, as well as the one calculated default, mustfrom 
be the address of an opcode of an instruction within the method
that contains this lookupswitch instruction.
NotesThe alignment required of the 4-byte lookupswitchoperands of the 
instruction guarantees 4-byte alignment of those operands if and
only if the method that lookupswitchcontains  the is positioned on
a 4-byte boundary.
The match-offset pairs are sorted to support lookup routines that
are quicker than linear search.
524
--------------------------------------- 543
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlor
lorlor
Operation Boolean OR long
Formatlor
Formslor = 129 (0x81)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . They are popped
from the operand stack. long resultA  is calculated by taking the
bitwise inclusive value1OR  of and value2. The result is pushed
onto the operand stack.
525
--------------------------------------- 544
lremTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lremlrem
Operation Remainder long
Formatlrem
Formslrem = 113 (0x71)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . The values are
popped from the operand stack. long resultThe  is value1 - value1(
/ value2) * value2. The result is pushed onto the operand stack.
The result of lremthe  instruction is (a/b)*b such that + (a%b) is
equal ato . This identity holds even in the special case in which the
dividend is the negative long of largest possible magnitude for its
type and the divisor is -1 (the remainder is 0). It follows from this
rule that the result of the remainder operation can be negative only
if the dividend is negative and can be positive only if the dividend
is positive; moreover, the magnitude of the result is always less
than the magnitude of the divisor.
RuntimeIf the value of the divisor long remainder for a operator lremis 0, 
throws an ArithmeticException.
Exception
526
--------------------------------------- 545
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlreturn
lreturnlreturn
Operation Return long from method
Formatlreturn
Formslreturn = 173 (0xad)
Operand..., value 
Stack[empty]
DescriptionThe current method must have longreturn . The valuetype  must
be of type long. If the current method synchronizedis a  method,
the monitor entered or reentered on invocation of the method is
updated and possibly exited as if by monitorexitexecution of a 
instruction monitorexit() in the current thread. If no exception
is thrown, value is popped from the operand stack of the current
frame 2.6( ) and pushed onto the operand stack of the frame of
the invoker. Any other values on the operand stack of the current
method are discarded.
The interpreter then returns control to the invoker of the method,
reinstating the frame of the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
rules on structured locking 2.11.10described , then in if the
Exceptions
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, lreturn throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then lreturn throws an IllegalMonitorStateException.
527
--------------------------------------- 546
lshlTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lshllshl
Operation Shift left long
Formatlshl
Formslshl = 121 (0x79)
Operand..., value1, value2 
Stack..., result
DescriptionThe value1 must be of longtype , and value2 must be of inttype .
The values are popped from the operand long resultstack.  is A 
calculated by shifting value1 left s by bit positions, s is where the
low 6 bits of value2. The result is pushed onto the operand stack.
NotesThis is equivalent (even if overflow occurs) to multiplication by 2
to the power s. The shift distance actually used is therefore always
in the range 0 to 63, inclusive, value2 were as subjected if to a
bitwise logical AND with the mask value 0x3f.
528
--------------------------------------- 547
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlshr
lshrlshr
Operation Arithmetic shift right long
Formatlshr
Formslshr = 123 (0x7b)
Operand..., value1, value2 
Stack..., result
DescriptionThe value1 must be of longtype , and value2 must be of inttype .
The values are popped from the operand long resultstack.  is A 
calculated by shifting value1 right s by bit positions, with sign
extension, where s is the value of the low value26 . bits The of 
result is pushed onto the operand stack.
s
NotesThe resulting value 
 value1is  /  2, where s is value2 & 0x3f. For
non-negative value1, this is equivalent to longtruncating  division
by 2 to the power s. The shift distance actually used is therefore
always in the range 0 to 63, value2inclusive,  were subjectedas if 
to a bitwise logical AND with the mask value 0x3f.
529
--------------------------------------- 548
lstoreTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lstorelstore
Operation Store long into local variable
Formatlstore
index
Formslstore = 55 (0x37)
Operand..., value 
Stack...
DescriptionThe index is an unsigned byte. index Both and index+1 must be
indices into the local variable array of 2.6the ). current frame (
The value on the top of the operand stack longmust . Itbe of type 
is popped from the operand stack, and the indexlocal variables at 
and index+1 are set to value.
NotesThe lstore opcode can be used in conjunction wide with the 
instruction wide() to access a local variable using a two-byte
unsigned index.
530
--------------------------------------- 549
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlstore_<n>
lstore_<n>lstore_<n>
Operation Store long into local variable
Formatlstore_<n>
Formslstore_0 = 63 (0x3f)
lstore_1 = 64 (0x40)
lstore_2 = 65 (0x41)
lstore_3 = 66 (0x42)
Operand..., value 
Stack...
DescriptionBoth n<> and n>+1 <must be indices into the local variable array
of the current 2.6frame ). The (value on the top of the operand
stack must be of longtype . It is popped from the operand stack,
and the local variables at <n> and <n>+1 are set to value.
NotesEach of the lstore_<n> instructions is the lstoresame  with as an
index of <n>, except that the operand <n> is implicit.
531
--------------------------------------- 550
lsubTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lsublsub
Operation Subtract long
Formatlsub
Formslsub = 101 (0x65)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . The values are
popped from the operand stack. long resultThe  is value1 - value2.
The result is pushed onto the operand stack.
For long subtraction, a-b produces the same a+(-b)result . Foras 
long values, subtraction from zero is the same as negation.
The result is the 64 low-order bits of the true mathematical result
in a sufficiently wide two's-complement format, represented as a
value of type long. If overflow occurs, then the sign of the result
may not be the same as the sign of the mathematical sum of the
two values.
Despite the fact that overflow may occur, lsubexecution of an 
instruction never throws a runtime exception.
532
--------------------------------------- 551
THE JAVA VIRTUAL MACHINE INSTRUCTION SETlushr
lushrlushr
Operation Logical shift right long
Formatlushr
Formslushr = 125 (0x7d)
Operand..., value1, value2 
Stack..., result
DescriptionThe value1 must be of longtype , and value2 must be of inttype .
The values are popped from the operand long resultstack.  is A 
calculated by shifting value1 right logically (with zero extension)
by the amount indicated by the value2low . 6 The bits result of is
pushed onto the operand stack.
NotesIf value1 is positive s is and value2 & 0x3f, the result is the same
as that value1of  >> s; if value1 is negative, the result is equal to the
value of the expression value1 >> s) ( + (2L << ~s). The addition of
the (2L << ~s) term cancels out the propagated sign bit. The shift
distance actually used is always in the range 0 to 63, inclusive.
533
--------------------------------------- 552
lxorTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
lxorlxor
Operation Boolean XOR long
Formatlxor
Formslxor = 131 (0x83)
Operand..., value1, value2 
Stack..., result
DescriptionBoth value1 and value2 must be of longtype . They are popped
from the operand stack. long resultA  is calculated by taking the
bitwise exclusive value1OR  of and value2. The result is pushed
onto the operand stack.
534
--------------------------------------- 553
THE JAVA VIRTUAL MACHINE INSTRUCTION SETmonitorenter
monitorentermonitorenter
Operation Enter monitor for object
Formatmonitorenter
Formsmonitorenter = 194 (0xc2)
Operand..., objectref 
Stack...
DescriptionThe objectref must be of type reference.
Each object is associated with a monitor. A monitor is locked if
and only if it has an owner. The thread monitorenterthat executes 
attempts to gain ownership of the monitor associated with
objectref, as follows:
 If the entry count of the monitor objectrefassociated  iswith 
zero, the thread enters the monitor and sets its entry count to
one. The thread is then the owner of the monitor.
 If the thread already owns the monitor objectrefassociated ,with 
it reenters the monitor, incrementing its entry count.
 If another thread already owns the monitor associated with
objectref, the thread blocks until the monitor's entry count is
zero, then tries again to gain ownership.
RuntimeIf objectref is null, monitorenter throws a
ExceptionNullPointerException.
NotesA monitorenter instruction may be used with one or
more monitorexit instructions monitorexit() to implement a
synchronized statement in the Java programming language
(3.14). The monitorenter and monitorexit instructions are not
used in the implementation synchronizedof  methods, although
they can be used to provide equivalent locking semantics. Monitor
entry on invocation synchronizedof a  method, and monitor exit
535
--------------------------------------- 554
monitorenterTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
on its return, are handled implicitly by the Java virtual machine's
method invocation and return instructions, monitorenter andas if 
monitorexit were used.
The association of a monitor with an object may be managed in
various ways that are beyond the scope of this specification. For
instance, the monitor may be allocated and deallocated at the same
time as the object. Alternatively, it may be dynamically allocated
at the time when a thread attempts to gain exclusive access to the
object and freed at some later time when no thread remains in the
monitor for the object.
The synchronization constructs of the Java programming language
require support for operations on monitors besides entry and exit.
These include waiting on Object.waita monitor ) (and notifying
other threads waiting on Object.notifyAlla monitor ( and
Object.notify). These operations are supported in the standard
package java.lang supplied with the Java virtual machine. No
explicit support for these operations appears in the instruction set
of the Java virtual machine.
536
--------------------------------------- 555
THE JAVA VIRTUAL MACHINE INSTRUCTION SETmonitorexit
monitorexitmonitorexit
Operation Exit monitor for object
Formatmonitorexit
Formsmonitorexit = 195 (0xc3)
Operand..., objectref 
Stack...
DescriptionThe objectref must be of type reference.
The thread that executes monitorexit must be the owner of the
monitor associated with the instance referenced by objectref.
The thread decrements the entry count of the monitor associated
with objectref. If as a result the value of the entry count is zero, the
thread exits the monitor and is no longer its owner. Other threads
that are blocking to enter the monitor are allowed to attempt to do
so.
RuntimeIf objectref is null, monitorexit throws NullPointerExceptiona .
ExceptionsOtherwise, if the thread that monitorexitexecutes  is not the owner
of the monitor associated with the instance objectref,referenced by 
monitorexit throws an IllegalMonitorStateException.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and in 
if the second of those rules is violated by the execution
of this monitorexit instruction, monitorexitthen  throws an
IllegalMonitorStateException.
NotesOne or more monitorexit instructions may be used with
a monitorenter instruction monitorenter() to implement a
synchronized statement in the Java programming language
(3.14). The monitorenter and monitorexit instructions are not
used in the implementation synchronizedof  methods, although
they can be used to provide equivalent locking semantics.
537
--------------------------------------- 556
monitorexitTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
The Java virtual machine supports exceptions thrown within
synchronized methods and synchronized statements differently:
 Monitor exit on normal synchronized method completion
is handled by the Java virtual machine's return instructions.
Monitor exit on abrupt synchronized method completion
is handled implicitly by the Java virtual athrow machine's 
instruction.
 When an exception is thrown from synchronizedwithin a 
statement, exit from the monitor entered prior to the execution of
the synchronized statement is achieved using the Java virtual
machine's exception handling mechanism (3.14).
538
--------------------------------------- 557
THE JAVA VIRTUAL MACHINE INSTRUCTION SETmultianewarray
multianewarraymultianewarray
Operation Create new multidimensional array
Formatmultianewarray
indexbyte1
indexbyte2
dimensions
Formsmultianewarray = 197 (0xc5)
Operand..., count1, [count2, ...] 
Stack..., arrayref
DescriptionThe dimensions operand is an unsigned byte that must be greater
than or equal to 1. It represents the number of dimensions of the
array to be created. The operand stack dimensionsmust contain 
values. Each such value represents the number of components in
a dimension of the array to be created, int, must and be of type 
must be non-negative. count1The  is the desired length in the first
dimension, count2 in the second, etc.
All of the count values are popped off the operand stack. The
unsigned indexbyte1 and indexbyte2 are used to construct an index
into the runtime constant pool of 2.6the ), current where theclass (
value of the index indexbyte1is  (<< 8) indexbyte2| . The runtime
constant pool item at the index must be a symbolic reference to a
class, array, or interface type. The named class, array, or interface
type is resolved 5.4.3.1). ( The resulting entry must be an array
class type of dimensionality greater than or equal to dimensions.
A new multidimensional array of the array type is allocated
from the garbage-collected heap. count value If any is zero, no
subsequent dimensions are allocated. The components of the array
in the first dimension are initialized to subarrays of the type of the
second dimension, and so on. The components of the last allocated
dimension of the array are initialized to the default initial value
539
--------------------------------------- 558
multianewarrayTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
(2.3, 2.4) for the element type of the referencearray type. A 
arrayref to the new array is pushed onto the operand stack.
LinkingDuring resolution of the symbolic reference to the class, array, or
Exceptionsinterface type, any of the exceptions 5.4.3.1documented  canin 
be thrown.
Otherwise, if the current class does not have permission to access
the element type of the resolved multianewarrayarray class, 
throws an IllegalAccessError.
RuntimeOtherwise, if any dimensionsof the  values on the operand
stack are less than multianewarrayzero, the  instruction throws a
ExceptionNegativeArraySizeException.
NotesIt may be more efficient newarrayto  use or anewarray
(newarray, anewarray) when creating an array of a single
dimension.
The array class referenced via the runtime constant pool may
have more dimensions than dimensionsthe  operand of the
multianewarray instruction. In that case, dimensionsonly the first 
of the dimensions of the array are created.
540
--------------------------------------- 559
THE JAVA VIRTUAL MACHINE INSTRUCTION SETnew
newnew
Operation Create new object
Formatnew
indexbyte1
indexbyte2
Formsnew = 187 (0xbb)
Operand... 
Stack..., objectref
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at the index must be a symbolic
reference to a class or interface type. The named class or interface
type is resolved 5.4.3.1) ( and should result in a class type.
Memory for a new instance of that class is allocated from the
garbage-collected heap, and the instance variables of the new
object are initialized to their default 2.3, 2.4initial ). The values (
objectref, a reference to the instance, is pushed onto the operand
stack.
On successful resolution of the class, 5.5) it if is it initialized has(
not already been initialized.
LinkingDuring resolution of the symbolic reference to the class, array, or
Exceptionsinterface type, any of the exceptions 5.4.3.1documented  canin 
be thrown.
Otherwise, if the symbolic reference to the class, array, or interface
type resolves to an interface abstractor  class, is newan  throws
an InstantiationError.
541
--------------------------------------- 560
newTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
RuntimeOtherwise, if execution new instruction of this causes initialization
of the referenced newclass,  may throw Erroran  as detailed in JLS
Exception15.9.4.
NotesThe new instruction does not completely create a new instance;
instance creation is not completed until an instance initialization
method (2.9) has been invoked on the uninitialized instance.
542
--------------------------------------- 561
THE JAVA VIRTUAL MACHINE INSTRUCTION SETnewarray
newarraynewarray
Operation Create new array
Formatnewarray
atype
Formsnewarray = 188 (0xbc)
Operand..., count 
Stack..., arrayref
DescriptionThe count must be of inttype . It is popped off the operand stack.
The count represents the number of elements in the array to be
created.
The atype is a code that indicates the type of array to create. It must
take one of the following values:
Table 6.1. Array type codes
Array Typeatype
T_BOOLEAN4
T_CHAR5
T_FLOAT6
T_DOUBLE7
T_BYTE8
T_SHORT9
T_INT10
T_LONG11
A new array whose components are atypeof  and type of length
count is allocated from the garbage-collected reference heap. A 
arrayref to this new array object is pushed into the operand stack.
Each of the elements of the new array is initialized to the default
initial value (2.3, 2.4) for the element type of the array type.
543
--------------------------------------- 562
newarrayTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
RuntimeIf count is less than newarrayzero,  throws a
NegativeArraySizeException.
Exception
NotesIn Oracle's implementation of the Java virtual machine, arrays
of type boolean atype( is T_BOOLEAN) are stored as arrays of
8-bit values and are manipulated baloadusing  and bastorethe 
instructions baload(, bastore) which also access arrays of type
byte. Other implementations may implement booleanpacked 
arrays; baloadthe  and bastore instructions must still be used to
access those arrays.
544
--------------------------------------- 563
THE JAVA VIRTUAL MACHINE INSTRUCTION SETnop
nopnop
Operation Do nothing
Formatnop
Formsnop = 0 (0x0)
OperandNo change
Stack
DescriptionDo nothing.
545
--------------------------------------- 564
popTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
poppop
Operation Pop the top operand stack value
Formatpop
Formspop = 87 (0x57)
Operand..., value 
Stack...
DescriptionPop the top value from the operand stack.
The pop instruction must not be valueused  is unless a value of a
category 1 computational type (2.11.1).
546
--------------------------------------- 565
THE JAVA VIRTUAL MACHINE INSTRUCTION SETpop2
pop2pop2
Operation Pop the top one or two operand stack values
Formatpop2
Formspop2 = 88 (0x58)
OperandForm 1:
Stack..., value2, value1 
...
where each value1of  and value2 is a value of a category 1
computational type (2.11.1).
Form 2:
..., value 
...
where value is a value of a category 2 computational type
(2.11.1).
DescriptionPop the top one or two values from the operand stack.
547
--------------------------------------- 566
putfieldTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
putfieldputfield
Operation Set field in object
Formatputfield
indexbyte1
indexbyte2
Formsputfield = 181 (0xb5)
Operand..., objectref, value 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a 5.1field ), which (gives the name and descriptor of
the field as well as a symbolic reference to the class in which the
field is to be found. objectrefThe class  must of not be an array. If
the field protectedis  4.6( ), and it is a member of a superclass of
the current class, and the field is not declared in the same runtime
package 5.3( ) as the current class, then objectrefthe  mustclass of 
be either the current class or a subclass of the current class.
The referenced field is 5.4.3.2resolved ). The ( type valueof a 
stored by putfielda  instruction must be compatible with the
descriptor of the referenced 4.3.2). field If the ( field descriptor
type booleanis , byte, char, short, or int, then valuethe  must
be an int. If the field descriptor float, longtype , or is double,
then the value must be floata , long, or double, respectively. If
the field descriptor type is a reference value musttype, then the 
be of a type that is assignment compatible (JLS 5.2) with the
field descriptor type. If finalthe , it field must is be declared in
the current class, and the instruction must occur in an instance
initialization method (<init>) of the current class (2.9).
The value and objectref are popped from the operand stack. The
objectref must be of referencetype . The value undergoes value
548
--------------------------------------- 567
THE JAVA VIRTUAL MACHINE INSTRUCTION SETputfield
set conversion 2.8.3), ( resulting value', in and the referenced field
in objectref is set to value'.
LinkingDuring resolution of the symbolic reference to the field, any of the
Exceptionsexceptions pertaining to field 5.4.3.2resolution ) can be thrown.(
Otherwise, if the resolved staticfield  field, is putfielda  throws
an IncompatibleClassChangeError.
Otherwise, if the finalfield , it is must be declared in the
current class, and the instruction must occur in an instance
initialization <init>method ) of ( the current class. Otherwise, an
IllegalAccessError is thrown.
RuntimeOtherwise, objectrefif  is null, the putfield instruction throws a
ExceptionNullPointerException.
549
--------------------------------------- 568
putstaticTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
putstaticputstatic
Operation Set static field in class
Formatputstatic
indexbyte1
indexbyte2
Formsputstatic = 179 (0xb3)
Operand..., value 
Stack...
DescriptionThe unsigned indexbyte1 and indexbyte2 are used to construct an
index into the runtime constant pool of 2.6the ), current class (
where the value of the indexbyte1index  is << (8) indexbyte2| .
The runtime constant pool item at that index must be a symbolic
reference to a 5.1field ), which (gives the name and descriptor of
the field as well as a symbolic reference to the class or interface
in which the field is to be found. The referenced field is resolved
(5.4.3.2).
On successful resolution of the field, the class or interface that
declared the resolved field 5.5is ) initialized if that class (or
interface has not already been initialized.
The type of valuea  stored by putstatica  instruction must be
compatible with the descriptor of the 4.3.2referenced ). Iffield (
the field descriptor booleantype , byteis , char, short, or int,
then the value must be intan . If the field descriptor float, type is 
long, or double, then valuethe  must be floata , long, or double,
respectively. If the field descriptor type is a reference type, then
the value must be of a type that is assignment compatible (JLS
5.2) with the field descriptor type. final, If it the must field beis 
declared in the current class, and the instruction must occur in the
<clinit> method of the current class (2.9).
550
--------------------------------------- 569
THE JAVA VIRTUAL MACHINE INSTRUCTION SETputstatic
The value is popped from the operand stack and undergoes value
set conversion 2.8.3), ( resulting valuein '. The class field is set
to value'.
LinkingDuring resolution of the symbolic reference to the class or
Exceptionsinterface field, any of the exceptions pertaining to field resolution
(5.4.3.2) can be thrown.
Otherwise, if the resolved field staticis not a 
(class) field or an interface putstatic field, throws an
IncompatibleClassChangeError.
Otherwise, if the finalfield , it is must be declared in the current
class, and the instruction must <clinit>occur  method in the of
the current class. Otherwise, an IllegalAccessError is thrown.
RuntimeOtherwise, if execution putstaticof  this instruction causes
initialization of the referenced class putstatic or mayinterface, 
Exceptionthrow an Error as detailed in 5.5.
NotesA putstatic instruction may be used only to set the value of an
interface field on the initialization of that field. Interface fields
may be assigned to only once, on execution of an interface variable
initialization expression when the interface 5.5, JLSis initialized (
9.3.1).
551
--------------------------------------- 570
retTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
retret
Operation Return from subroutine
Formatret
index
Formsret = 169 (0xa9)
OperandNo change
Stack
DescriptionThe index is an unsigned byte between 0 and 255, inclusive.
The local variable index at in the current 2.6frame ) must(
contain a value returnAddressof type . The contents of the local
variable are written into the Java pcvirtual  register, machine's and
execution continues there.
NotesNote that jsr (jsr) pushes the address onto the operand stack and
ret gets it out of a local variable. This asymmetry is intentional.
In Oracle's implementation of a compiler for the Java
programming language prior to Java ret SE instruction6, the 
was used with jsrthe  and jsr_w instructions jsr, jsr_w( ) in the
implementation of the finally clause (3.13, 4.10.2.5).
The ret instruction should not be confused returnwith the 
instruction return(). A return instruction returns control from
a method to its invoker, without passing any value back to the
invoker.
The ret opcode can be used in conjunction widewith the 
instruction wide() to access a local variable using a two-byte
unsigned index.
552
--------------------------------------- 571
THE JAVA VIRTUAL MACHINE INSTRUCTION SETreturn
returnreturn
Operation Return void from method
Formatreturn
Formsreturn = 177 (0xb1)
Operand... 
Stack[empty]
DescriptionThe current method must have return void. If type the
current method synchronizedis a  method, the monitor entered
or reentered on invocation of the method is updated and
possibly exited as if by execution monitorexit of instructiona 
(monitorexit) in the current thread. If no exception is thrown,
any values on the operand stack of the 2.6current ) areframe (
discarded.
The interpreter then returns control to the invoker of the method,
reinstating the frame of the invoker.
RuntimeIf the Java virtual machine implementation does not enforce the
Exceptionsrules on structured locking 2.11.10described , then in if the
current method synchronizedis a  method and the current thread is
not the owner of the monitor entered or reentered on invocation of
the method, return throws IllegalMonitorStateExceptionan .
This can happen, for example, synchronizedif  a method contains
a monitorexit instruction, monitorenterbut no  instruction, on the
object on which the method is synchronized.
Otherwise, if the Java virtual machine implementation enforces
the rules on structured locking 2.11.10described  and if in the first
of those rules is violated during invocation of the current method,
then return throws an IllegalMonitorStateException.
553
--------------------------------------- 572
saloadTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
saloadsaload
Operation Load short from array
Formatsaload
Formssaload = 53 (0x35)
Operand..., arrayref, index 
Stack..., value
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are shortof type . The index must be of type
int. Both arrayref and index are popped from the operand stack.
The component of the indexarray  is at retrieved and sign-extended
to an int value. That value is pushed onto the operand stack.
RuntimeIf arrayref is null, saload throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the saload instruction throws an
ArrayIndexOutOfBoundsException.
554
--------------------------------------- 573
THE JAVA VIRTUAL MACHINE INSTRUCTION SETsastore
sastoresastore
Operation Store into short array
Formatsastore
Formssastore = 86 (0x56)
Operand..., arrayref, index, value 
Stack...
DescriptionThe arrayref must be of referencetype  and must refer to an array
whose components are shortof type . Both index and value must
be of type int. The arrayref, index, and value are popped from the
operand stack. intThe  value is truncated shortto  and a stored as
the component of the array indexed by index.
RuntimeIf arrayref is null, sastore throws a NullPointerException.
ExceptionsOtherwise, indexif  is not within the bounds of the array
referenced arrayrefby , the sastore instruction throws an
ArrayIndexOutOfBoundsException.
555
--------------------------------------- 574
sipushTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
sipushsipush
Operation Push short
Formatsipush
byte1
byte2
Formssipush = 17 (0x11)
Operand... 
Stack..., value
DescriptionThe immediate unsigned byte1 and byte2 values are assembled into
an intermediate short where the value shortof  the is byte1( <<
8) byte2| . The intermediate value is then sign-extended intto an 
value. That value is pushed onto the operand stack.
556
--------------------------------------- 575
THE JAVA VIRTUAL MACHINE INSTRUCTION SETswap
swapswap
Operation Swap the top two operand stack values
Formatswap
Formsswap = 95 (0x5f)
Operand..., value2, value1 
Stack..., value1, value2
DescriptionSwap the top two values on the operand stack.
The swap instruction must not be value1used  and unless value2
are both values of a category 1 computational type (2.11.1).
NotesThe Java virtual machine does not provide an instruction
implementing a swap on operands of category 2 computational
types.
557
--------------------------------------- 576
tableswitchTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
tableswitchtableswitch
Operation Access jump table by index and jump
Formattableswitch
<0-3 byte pad>
defaultbyte1
defaultbyte2
defaultbyte3
defaultbyte4
lowbyte1
lowbyte2
lowbyte3
lowbyte4
highbyte1
highbyte2
highbyte3
highbyte4
jump offsets...
Formstableswitch = 170 (0xaa)
Operand..., index 
Stack...
DescriptionA tableswitch is a variable-length instruction. Immediately after
the tableswitch opcode, between zero and three bytes must act
as padding, such defaultbyte1that  begins at an address that is a
multiple of four bytes from the start of the current method (the
opcode of its first instruction). Immediately after the padding are
bytes constituting three signed default32-bit , low, values: and
high. Immediately following are bytes constituting higha series of 
- low + 1 signed 32-bit offsets. low must The value be less than or
equal highto . The high - low + 1 signed 32-bit offsets are treated
558
--------------------------------------- 577
THE JAVA VIRTUAL MACHINE INSTRUCTION SETtableswitch
as a 0-based jump table. Each of these signed 32-bit values is
constructed as (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4.
The index must be of inttype  and is popped from the operand
stack. indexIf  is less lowthan  or index is greater highthan , then
a target address is calculated defaultby  to adding the address of
the opcode of tableswitchthis  instruction. Otherwise, the offset
at position index - low of the jump table is extracted. The target
address is calculated by adding that offset to the address of the
opcode of tableswitchthis  instruction. Execution then continues
at the target address.
The target address that can be calculated from each jump table
offset, as well as the one that can defaultbe calculated , mustfrom 
be the address of an opcode of an instruction within the method
that contains this tableswitch instruction.
NotesThe alignment required of the 4-byte tableswitchoperands of the 
instruction guarantees 4-byte alignment of those operands if and
only if the method that tableswitchcontains  starts the on a 4-byte
boundary.
559
--------------------------------------- 578
wideTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
widewide
Operation Extend local variable index by additional bytes
Format 1wide
<opcode>
indexbyte1
indexbyte2
where <opcode> is one iloadof , fload, aload, lload, dload, istore,
fstore, astore, lstore, dstore, or ret
Format 2wide
iinc
indexbyte1
indexbyte2
constbyte1
constbyte2
Formswide = 196 (0xc4)
OperandSame as modified instruction
Stack
DescriptionThe wide instruction modifies the behavior of another instruction.
It takes one of two formats, depending on the instruction being
modified. The first form wide instruction of the modifies one of the
instructions iload, fload, aload, lload, dload, istore, fstore, astore,
lstore, dstore, or ret (iload, fload, aload, lload, dload,
istore, fstore, astore, lstore, dstore, ret). The second form
applies only to the iinc instruction (iinc).
In either case, wide the opcode itself is followed in the compiled
code by the opcode of the wideinstruction  modifies. In either
form, two unsigned indexbyte1bytes  and indexbyte2 follow the
modified opcode and are assembled into a 16-bit unsigned index
to a local variable in the 2.6current ), where frame the ( value
560
--------------------------------------- 579
THE JAVA VIRTUAL MACHINE INSTRUCTION SETwide
of the index indexbyte1is ( << 8) indexbyte2| . The calculated
index must be an index into the local variable array of the current
frame. Where widethe  instruction modifies lload, dloadan , lstore,
or dstore instruction, the index following the calculated index
(index + 1) must also be an index into the local variable array. In
the second form, two immediate unsigned constbyte1 bytes and
constbyte2 follow indexbyte1 and indexbyte2 in the code stream.
Those bytes are also assembled into a signed 16-bit constant,
where the constant is (constbyte1 << 8) | constbyte2.
The widened bytecode operates as normal, except for the use of
the wider index and, in the case of the second form, the larger
increment range.
NotesAlthough we say widethat  "modifies the behavior of another
instruction," widethe  instruction effectively treats the bytes
constituting the modified instruction as operands, denaturing the
embedded instruction in the process. In the iinccase of a modified 
instruction, one of the logical iincoperands  is not of even the at
the normal offset from the opcode. The embedded instruction must
never be executed directly; its opcode must never be the target of
any control transfer instruction.
561
--------------------------------------- 580
wideTHE JAVA VIRTUAL MACHINE INSTRUCTION SET
562
--------------------------------------- 581
CHAPTER7
Opcode Mnemonics by
Opcode
THIS chapter gives the mapping from Java virtual machine instruction opcodes,
including the reserved 6.2opcodes ), to (the mnemonics for the instructions
represented by those opcodes.
Opcode value 186 was not used prior to Java SE 7.
563
--------------------------------------- 582
OPCODE MNEMONICS BY OPCODE
ConstantsLoadsStores
00 (0x00)    nop21 (0x15)    iload54 (0x36)    istore
01 (0x01)    aconst_null22 (0x16)    lload55 (0x37)    lstore
02 (0x02)    iconst_m123 (0x17)    fload56 (0x38)    fstore
03 (0x03)    iconst_024 (0x18)    dload57 (0x39)    dstore
04 (0x04)    iconst_125 (0x19)    aload58 (0x3a)    astore
05 (0x05)    iconst_226 (0x1a)    iload_059 (0x3b)    istore_0
06 (0x06)    iconst_327 (0x1b)    iload_160 (0x3c)    istore_1
07 (0x07)    iconst_428 (0x1c)    iload_261 (0x3d)    istore_2
08 (0x08)    iconst_529 (0x1d)    iload_362 (0x3e)    istore_3
09 (0x09)    lconst_030 (0x1e)    lload_063 (0x3f)    lstore_0
10 (0x0a)    lconst_131 (0x1f)    lload_164 (0x40)    lstore_1
11 (0x0b)    fconst_032 (0x20)    lload_265 (0x41)    lstore_2
12 (0x0c)    fconst_133 (0x21)    lload_366 (0x42)    lstore_3
13 (0x0d)    fconst_234 (0x22)    fload_067 (0x43)    fstore_0
14 (0x0e)    dconst_035 (0x23)    fload_168 (0x44)    fstore_1
15 (0x0f)    dconst_136 (0x24)    fload_269 (0x45)    fstore_2
16 (0x10)    bipush37 (0x25)    fload_370 (0x46)    fstore_3
17 (0x11)    sipush38 (0x26)    dload_071 (0x47)    dstore_0
18 (0x12)    ldc39 (0x27)    dload_172 (0x48)    dstore_1
19 (0x13)    ldc_w40 (0x28)    dload_273 (0x49)    dstore_2
20 (0x14)    ldc2_w41 (0x29)    dload_374 (0x4a)    dstore_3
42 (0x2a)    aload_075 (0x4b)    astore_0
43 (0x2b)    aload_176 (0x4c)    astore_1
44 (0x2c)    aload_277 (0x4d)    astore_2
45 (0x2d)    aload_378 (0x4e)    astore_3
46 (0x2e)    iaload79 (0x4f)    iastore
47 (0x2f)    laload80 (0x50)    lastore
48 (0x30)    faload81 (0x51)    fastore
49 (0x31)    daload82 (0x52)    dastore
50 (0x32)    aaload83 (0x53)    aastore
51 (0x33)    baload84 (0x54)    bastore
52 (0x34)    caload85 (0x55)    castore
53 (0x35)    saload86 (0x56)    sastore
564
--------------------------------------- 583
OPCODE MNEMONICS BY OPCODE
StackMathConversions
87 (0x57)    pop 96 (0x60)    iadd133 (0x85)    i2l
88 (0x58)    pop2 97 (0x61)    ladd134 (0x86)    i2f
89 (0x59)    dup 98 (0x62)    fadd135 (0x87)    i2d
90 (0x5a)    dup_x1 99 (0x63)    dadd136 (0x88)    l2i
91 (0x5b)    dup_x2100 (0x64)    isub137 (0x89)    l2f
92 (0x5c)    dup2101 (0x65)    lsub138 (0x8a)    l2d
93 (0x5d)    dup2_x1102 (0x66)    fsub139 (0x8b)    f2i
94 (0x5e)    dup2_x2103 (0x67)    dsub140 (0x8c)    f2l
95 (0x5f)    swap104 (0x68)    imul141 (0x8d)    f2d
105 (0x69)    lmul142 (0x8e)    d2i
106 (0x6a)    fmul143 (0x8f)    d2l
107 (0x6b)    dmul144 (0x90)    d2f
108 (0x6c)    idiv145 (0x91)    i2b
109 (0x6d)    ldiv146 (0x92)    i2c
110 (0x6e)    fdiv147 (0x93)    i2s
111 (0x6f)    ddiv
112 (0x70)    irem
113 (0x71)    lrem
114 (0x72)    frem
115 (0x73)    drem
116 (0x74)    ineg
117 (0x75)    lneg
118 (0x76)    fneg
119 (0x77)    dneg
120 (0x78)    ishl
121 (0x79)    lshl
122 (0x7a)    ishr
123 (0x7b)    lshr
124 (0x7c)    iushr
125 (0x7d)    lushr
126 (0x7e)    iand
127 (0x7f)    land
128 (0x80)    ior
129 (0x81)    lor
130 (0x82)    ixor
131 (0x83)    lxor
132 (0x84)    iinc
565
--------------------------------------- 584
OPCODE MNEMONICS BY OPCODE
ComparisonsReferences
148 (0x94)    lcmp178 (0xb2)    getstatic
149 (0x95)    fcmpl179 (0xb3)    putstatic
150 (0x96)    fcmpg180 (0xb4)    getfield
151 (0x97)    dcmpl181 (0xb5)    putfield
152 (0x98)    dcmpg182 (0xb6)    invokevirtual
153 (0x99)    ifeq183 (0xb7)    invokespecial
154 (0x9a)    ifne184 (0xb8)    invokestatic
155 (0x9b)    iflt185 (0xb9)    invokeinterface
156 (0x9c)    ifge186 (0xba)    invokedynamic
157 (0x9d)    ifgt187 (0xbb)    new
158 (0x9e)    ifle188 (0xbc)    newarray
159 (0x9f)    if_icmpeq189 (0xbd)    anewarray
160 (0xa0)    if_icmpne190 (0xbe)    arraylength
161 (0xa1)    if_icmplt191 (0xbf)    athrow
162 (0xa2)    if_icmpge192 (0xc0)    checkcast
163 (0xa3)    if_icmpgt193 (0xc1)    instanceof
164 (0xa4)    if_icmple194 (0xc2)    monitorenter
165 (0xa5)    if_acmpeq195 (0xc3)    monitorexit
166 (0xa6)    if_acmpneExtended
Control
196 (0xc4)    wide
167 (0xa7)    goto197 (0xc5)    multianewarray
168 (0xa8)    jsr198 (0xc6)    ifnull
169 (0xa9)    ret199 (0xc7)    ifnonnull
170 (0xaa)    tableswitch200 (0xc8)    goto_w
171 (0xab)    lookupswitch201 (0xc9)    jsr_w
172 (0xac)    ireturnReserved
173 (0xad)    lreturn202 (0xca)    breakpoint
174 (0xae)    freturn254 (0xfe)    impdep1
175 (0xaf)    dreturn255 (0xff)    impdep2
176 (0xb0)    areturn
177 (0xb1)    return
566
--------------------------------------- 585
Index
array class loading
creation and loading, 339
Aloading constraints, 343
a bit of history, 1array type codes, 543
aaload, 367, 176arraylength, 375, 183
aastore, 177, 368getfield, 441
abrupt method invocation completion, 18arrays, 55
Exceptions, 24assumptions: the meaning of "must", 361
invokedynamic, 475astore, 184, 376
synchronization, 67aload, 371
abstract and native methods, 163wide, 560
access control, 356astore_<n>, 377, 185
class and interface resolution, 349aload_<n>, 372
field resolution, 350athrow, 378, 186
method resolution, 351abrupt method invocation completion, 18
accessing the runtime constant pool, 46Exceptions, 23
accessors, 159attributes, 101
verification by type checking, 151, 152ClassFile structure, 74, 74
aconst_null, 370, 178Code attribute, 108
aload, 179, 371fields, 97, 97
astore, 376methods, 100, 100
wide, 560
aload_<n>, 180, 372B
astore_<n>, 377
anewarray, 373, 181baload, 187, 380
multianewarray, 540boolean type, 10
AnnotationDefault attribute, 138newarray, 544
methods, 101, 101bastore, 188, 381
annotations, 67boolean type, 10
areturn, 374, 182newarray, 544
arithmetic, 45binary class and interface names, 75
arithmetic instructions, 30annotations, 67
control transfer instructions, 35CONSTANT_Class_info structure, 85
567
--------------------------------------- 586
INDEX
creation and loading, 339ClassFile structure, 71, 72, 72
element_value structure, 133invokespecial, 480
field descriptors, 77class and interface resolution, 348
runtime constant pool, 336, 336anewarray, 373, 373
binding native method implementations, 360checkcast, 386, 385
invokeinterface, 478class and interface resolution, 349
invokespecial, 481deriving a class from a class file
invokestatic, 485representation, 344, 345
invokevirtual, 488field resolution, 349
bipush, 189, 382instanceof, 470, 471
boolean type, 10interface method resolution, 351
primitive types and values, 6ldc, 514, 513
structural constraints, 145ldc_w, 516, 515
bootstrap loadermethod resolution, 350, 350
creation and loading, 339method type and method handle resolution,
loading constraints, 343352, 354
notation, 4multianewarray, 539, 540
virtual machine start-up, 338new, 541, 541
BootstrapMethods attribute, 139class file format, 69, 5
ClassFile structure, 74, 74assumptions: the meaning of "must", 361
CONSTANT_InvokeDynamic_infocreation and loading, 339
structure, 95reserved opcodes, 362
bytecode behaviors for method handles, 353class libraries, 37
method type and method handle resolution,attributes, 102, 102
352creation and loading, 338
bytecode verifier, 325initialization, 357
class loading
access control, 356
Cclass and interface resolution, 348
call site specifier resolution, 355creating array classes, 342
invokedynamic, 472format checking, 141
caload, 190, 383getfield, 440
castore, 191, 384invokespecial, 480
checkcast, 192, 385invokevirtual, 487
instanceof, 471putfield, 548
checking Code, 163runtime constant pool, 14, 335
StackMapTable attribute, 110verification, 346
class access and property modifiers, 71ClassFile structure, 70
568
--------------------------------------- 587
INDEX
annotations, 67, 67astore_<n>, 377
attributes, 101Code attribute, 108
BootstrapMethods attribute, 139jsr, 502
Deprecated attribute, 129jsr_w, 503
deriving a class from a class more control examples, file47
representation, 344, 344ret, 552
EnclosingMethod attribute, 120compiling for the Java virtual machine, 39
format checking, 141compiling switches, 57
InnerClasses attribute, 117more control examples, 47
limitations of the Java virtual 333, constant poolmachine, , 83
332, 332, 332ClassFile structure, 71
loading using a user-defined 341class getfield, loader, 440
RuntimeInvisibleAnnotations attribute, 134getstatic, 442
RuntimeVisibleAnnotations attribute, 129invokedynamic, 472, 474, 472
Signature attribute, 121invokeinterface, 477
SourceDebugExtension attribute, 123invokespecial, 480
SourceFile attribute, 122invokestatic, 484
Synthetic attribute, 121invokevirtual, 487
Code attribute, 105ldc, 513, 513, 513, 513
attributes, 101ldc2_w, 517
constraints on Java virtual 141machine ldc_w, code, 515, 515, 515
Exceptions, 25method type and method handle resolution,
frames, 15353
limitations of the Java virtual 333, machine, putfield, 548
333putstatic, 550
LineNumberTable attribute, 124resolution, 348
local variables, 16runtime constant pool, 14, 335
LocalVariableTable attribute, 125constant pool tags, 84
LocalVariableTypeTable attribute, 127constant pool, 84
methods, 101, 101constant value attribute types, 105
operand stacks, 17ConstantValue attribute, 105
StackMapTable attribute, 108, 116CONSTANT_Class_info structure, 84
throwing and handling Exceptions, 60, 63arrays, 56
verification of class files, 149binary class and interface names, 75
combining streams of stack maps BootstrapMethods attribute, and140
instructions, 167ClassFile structure, 72, 72, 73
compiling finally, 63Code attribute, 108
astore, 376
569
--------------------------------------- 588
INDEX
CONSTANT_Fieldref_info,CONSTANT_MethodType_info structure,
CONSTANT_Methodref_info, and94
CONSTANT_InterfaceMethodref_infoBootstrapMethods attribute, 140
structures, 86runtime constant pool, 337
EnclosingMethod attribute, 120CONSTANT_NameAndType_info structure,
Exceptions attribute, 11790
InnerClasses attribute, 118, 118binary class and interface names, 75
ldc_w, 515CONSTANT_Fieldref_info,
runtime constant pool, 336CONSTANT_Methodref_info, and
StackMapTable attribute, 115CONSTANT_InterfaceMethodref_info
CONSTANT_Fieldref_info,structures, 86
CONSTANT_Methodref_info, andCONSTANT_InvokeDynamic_info
CONSTANT_InterfaceMethodref_infostructure, 95
structures, 85EnclosingMethod attribute, 120
CONSTANT_MethodHandle_info structure,runtime constant pool, 338
94, 94, 94CONSTANT_String_info structure, 87
runtime constant pool, 336, 336, 336BootstrapMethods attribute, 140
CONSTANT_Integer_info andruntime constant pool, 337
CONSTANT_Float_info structures, 87CONSTANT_Utf8_info structure, 91
BootstrapMethods attribute, 140AnnotationDefault attribute, 138
floating-point types, value sets, 9and attributes, values, 101
ldc, 514binary class and interface names, 75
ldc_w, 516BootstrapMethods attribute, 139
runtime constant pool, 338, 338Code attribute, 106
CONSTANT_InvokeDynamic_info
CONSTANT_Class_info structure, 85
structure, 95CONSTANT_MethodType_info structure,
BootstrapMethods attribute, 13995
runtime constant pool, 337CONSTANT_NameAndType_info
CONSTANT_Long_info andstructure, 91, 91
CONSTANT_Double_info structures, 89CONSTANT_String_info structure, 87
BootstrapMethods attribute, 140ConstantValue attribute, 105
ClassFile structure, 71Deprecated attribute, 129
floating-point types, value sets, 9and descriptors and signatures, values, 75
ldc2_w, 517element_value structure, 133, 133, 133
runtime constant pool, 338, 338EnclosingMethod attribute, 120
CONSTANT_MethodHandle_info structure,
Exceptions attribute, 116
93fields, 97, 97
BootstrapMethods attribute, 140, 140, 140InnerClasses attribute, 118, 117
runtime constant pool, 336
570
--------------------------------------- 589
INDEX
limitations of the Java virtual machine, 333loading constraints, 343
LineNumberTable attribute, 124creation and loading, 338
LocalVariableTable attribute, 125, 126, 126access control, 356
LocalVariableTypeTable attribute, 127, 128,class and interface resolution, 348
128creating array classes, 342
methods, 100, 100format checking, 141
runtime constant pool, 338getfield, 440
RuntimeInvisibleAnnotations attribute, 134invokespecial, 480
RuntimeInvisibleParameterAnnotationsinvokevirtual, 487
attribute, 137putfield, 548
RuntimeVisibleAnnotations attribute, 131,runtime constant pool, 14, 335
131, 130verification, 346
RuntimeVisibleParameterAnnotations
attribute, 136
D
Signature attribute, 122, 122
SourceDebugExtension attribute, 123, 124d2f, 387, 193
SourceFile attribute, 122, 123d2i, 388, 194
StackMapTable attribute, 109d2l, 389, 195
Synthetic attribute, 121dadd, 196, 390
ConstantValue attribute, 104daload, 392, 197
fields, 97, 97
initialization, 358dastore, 198, 393
data types, 6
limitations of the Java virtual machine, 333baload, 380
constraintsbastore, 381
creating array classes, 342dcmp<op>, 199, 394
deriving a class from a class filedconst_<d>, 200, 396
representation, 345ddiv, 201, 397
field resolution, 350defineclass
interface method resolution, 352
loading using a user-defined 341class loader, creation and loading, 340
loading constraints, 343
method resolution, 351loading using a user-defined 341class loader, 
preparation, 346loading using the bootstrap class loader, 341
constraints on Java virtual machine , 141codedefining and naming new attributes, 103
Code attribute, 107ClassFile structure, 74
verification, 346, 346Code attribute, 108
control transfer instructions, 34
creating array classes, 342fields, 98
creation and loading, 339methods, 101
Deprecated attribute, 129
571
--------------------------------------- 590
INDEX
ClassFile structure, 74abrupt method invocation completion, 18
fields, 97athrow, 378
methods, 101Code attribute, 107
deriving a class from a class normal method invocation completion, file18
representation, 344synchronization, 67
creation and loading, 340throwing and handling Exceptions, 60, 62
loading constraints, 343virtual machine errors, 362
loading using a user-defined 341class Exceptions and finallyloader, , 330
loading using the bootstrap class loader, 341compiling finally, 63
descriptors and signatures, 75jsr, 502
binary class and interface names, 75jsr_w, 503
dload, 202, 399ret, 552
wide, 560Exceptions attribute, 116
dload_<n>, 400, 203methods, 101, 101
dmul, 204, 401
dneg, 205, 403
drem, 206, 404F
dreturn, 406, 207f2d, 417, 218
dstore, 208, 407f2i, 418, 219
wide, 560f2l, 419, 220
dstore_<n>, 408, 209fadd, 420, 221
dsub, 210, 409faload, 222, 422
dup, 211, 410fastore, 423, 223
operand stacks, 17fcmp<op>, 424, 224
dup2, 413, 214fconst_<f>, 426, 225
dup2_x1, 215, 414fdiv, 427, 226
dup2_x2, 216, 415field access and property flags, 96
dup_x1, 411, 212ConstantValue attribute, 104
dup_x2, 412, 213fields, 97, 97, 97, 96
dynamic linking, 18field descriptors, 76
CONSTANT_Fieldref_info,
CONSTANT_Methodref_info, and
E
CONSTANT_InterfaceMethodref_info
element_value structure, 131structures, 87
EnclosingMethod attribute, 120CONSTANT_NameAndType_info
structure, 91
ClassFile structure, 74
exception handling, 168element_value structure, 133
Exceptions, 23fields, 96, 97
572
--------------------------------------- 591
INDEX
LocalVariableTable attribute, 126CONSTANT_Long_info and
method type and method handle resolution,CONSTANT_Double_info structures, 90
352d2f, 387, 387
putfield, 548f2d, 417
putstatic, 550floating-point modes, 20
runtime constant pool, 336invokedynamic, 473
RuntimeVisibleAnnotations attribute, 131ldc, 514
structural constraints, 147ldc2_w, 517
field resolution, 349ldc_w, 516
getfield, 440, 440more control examples, 48
getstatic, 442, 442primitive types and values, 6
loading constraints, 343floating-point value set parameters, 9
method type and method handle resolution,floating-point types, value sets, 8,and values, 
3549, 9
putfield, 549, 548fmul, 229, 431
putstatic, 550, 551fneg, 433, 230
resolution, 348format checking, 141
fields, 96deriving a class from a class file
attributes, 101representation, 344
ClassFile structure, 73, 73format of examples, 39
ConstantValue attribute, 104format of instruction descriptions, 363
Deprecated attribute, 129frames, 15
RuntimeInvisibleAnnotations attribute, 134aload, 371
RuntimeVisibleAnnotations attribute, 129aload_<n>, 372
Signature attribute, 121anewarray, 373
Synthetic attribute, 121areturn, 374
fload, 227, 429astore, 376
types and the Java virtual machine, 26astore_<n>, 377
wide, 560athrow, 378
fload_<n>, 430, 228checkcast, 385
floating-point arithmetic, 19dload, 399
floating-point modes, 20dload_<n>, 400
d2f, 387dreturn, 406
f2d, 417dstore, 407
type conversion instructions, 32dstore_<n>, 408
floating-point types, value sets, and values, 8dynamic linking, 18
CONSTANT_Integer_info andfload, 429
CONSTANT_Float_info structures, 88fload_<n>, 430
573
--------------------------------------- 592
INDEX
format of instruction descriptions, 365ret, 552
freturn, 436return, 553
fstore, 437use of constants, local variables, and control
fstore_<n>, 438constructs, 41
getfield, 440wide, 560
getstatic, 442frem, 434, 231
iinc, 465freturn, 436, 232
iload, 466fstore, 437, 233
iload_<n>, 467wide, 560
instanceof, 470fstore_<n>, 438, 234
invokedynamic, 472fsub, 235, 439
invokeinterface, 477
invokespecial, 480
invokestatic, 484G
invokevirtual, 487getfield, 236, 440
ireturn, 494getstatic, 442, 239
istore, 497initialization, 357
istore_<n>, 498goto, 240, 444
Java virtual machine stacks, 12goto_w, 241, 445
ldc, 513grammar notation, 76
ldc2_w, 517
ldc_w, 515
limitations of the Java virtual 333, machine, H
333heap, 13
lload, 519
lload_<n>, 520
load and store instructions, 29I
local variables, 16
lreturn, 527i2b, 446, 242
i2c, 447, 243
lstore, 530i2d, 448, 244
lstore_<n>, 531i2f, 449, 245
multianewarray, 539i2l, 450, 246
new, 541i2s, 451, 247
normal method invocation completion, 18iadd, 248, 452
operand stacks, 17operand stacks, 17
pc register, 12iaload, 453, 249
putfield, 548iand, 454, 250
putstatic, 550iastore, 455, 251
574
--------------------------------------- 593
INDEX
iconst_<i>, 456invokeinterface, 477, 479
idiv, 457loading constraints, 343
if<cond>, 254, 461method type and method handle resolution,
if_acmp<cond>, 252, 458354
if_icmp<cond>, 253, 459internal form of names, 75
ifnonnull, 255, 463interpretation of additional tag values, 132
ifnull, 256, 464element_value structure, 132, 132
iinc, 465, 257interpretation of basetype characters, 78
wide, 560element_value structure, 132
iload, 258, 466field descriptors, 77
types and the Java virtual machine, 26type hierarchy, 154
wide, 560introduction, 1
iload_<n>, 467, 259invokedynamic, 472, 263
imul, 468, 260BootstrapMethods attribute, 139
ineg, 469, 261CONSTANT_InvokeDynamic_info
initialization, 357structure, 95
ConstantValue attribute, 104runtime constant pool, 337
creation and loading, 340invokeinterface, 477, 264
getstatic, 442, 443invokespecial, 480, 265
invokestatic, 485, 484ClassFile structure, 72
new, 541special methods, 21
preparation, 346invokestatic, 484, 268
putstatic, 551, 550, 551initialization, 357
special methods, 22invokevirtual, 269, 487
InnerClasses attribute, 117invokedynamic, 472, 474
ClassFile structure, 74invokespecial, 482
instance initialization methods and special methods, newly22
created objects, 329invoking methods, 50
structural constraints, 146, 146ior, 492, 270
instanceof, 262, 470irem, 271, 493
checkcast, 386ireturn, 494, 272
instruction set summary, 25ishl, 273, 495
instructions, 170, 366ishr, 274, 496
static constraints, 142isomorphic instructions, 170
integral types and values, 7istore, 275, 497
invokedynamic, 473wide, 560
primitive types and values, 6istore_<n>, 498, 276
interface method resolution, 351isub, 499, 277
575
--------------------------------------- 594
INDEX
iushr, 500, 278limitations of the Java virtual machine, 332
ixor, 279, 501goto_w, 445
jsr_w, 503
JLineNumberTable attribute, 124
Code attribute, 108
Java virtual machine, 2linking, 345
Java virtual machine actual verification of class files, and149
computational types, 29list of all instructions, 175
types and the Java virtual machine, 29, 29lload, 519, 293
Java virtual machine floating-pointwide, 560
arithmetic and IEEE 754, 19lload_<n>, 294, 520
Java virtual machine instruction set, 361lmul, 295, 521
Java virtual machine stacks, 12lneg, 296, 522
frames, 15load and store instructions, 29
jsr, 502loading constraints, 342
ret, 552, 552creating array classes, 342
returnaddress type and values, 10deriving a class from a class file
jsr_w, 503representation, 345
ret, 552field resolution, 350
returnaddress type and values, 10interface method resolution, 352
loading using a user-defined 341class loader, 
method resolution, 351
Lpreparation, 346
l2d, 504, 280loading using a user-defined , class 341loader
l2f, 505, 281creation and loading, 339
l2i, 506, 282loading constraints, 343
ladd, 283, 507loading using the bootstrap class loader, 340
laload, 284, 508creation and loading, 339
land, 285, 509loading constraints, 343
lastore, 286, 510notation, 4
lcmp, 287, 511virtual machine start-up, 338
lconst_<l>, 512, 288loading, linking, and initializing, 335
ldc, 513, 289loads, 172
call site specifier resolution, 355local variables, 16
ldc_w, 516Code attribute, 106
ldc2_w, 517, 291frames, 15
ldc_w, 515, 290load and store instructions, 29
ldiv, 518, 292LocalVariableTable attribute, 125
576
--------------------------------------- 595
INDEX
Code attribute, 108invokeinterface, 477
LocalVariableTypeTable attribute, 127invokespecial, 480
Code attribute, 108invokestatic, 484
lookupswitch, 297, 523invokevirtual, 487
instruction set summary, 25invoking methods, 50
lor, 525, 298limitations of the Java virtual machine, 333
lrem, 299, 526method type and method handle resolution,
lreturn, 527, 300352, 354
lshl, 301, 528methods, 98, 100
lshr, 302, 529RuntimeInvisibleParameterAnnotations
lstore, 303, 530attribute, 137
wide, 560RuntimeVisibleParameterAnnotations
lstore_<n>, 531, 304attribute, 136
lsub, 305, 532special methods, 22
structural constraints, 147, 146
lushr, 306, 533
lxor, 534, 307method descriptors for method handles, 354
method type and method handle resolution,
354
Mmethod invocation and return instructions, 35
manipulating the operand stack, 170normal method invocation completion, 18
method access and property flags, 99synchronization, 36
method overriding, 357
methods, 98, 100, 100, 99, 100
method area, 13invokevirtual, 487
creation and loading, 338preparation, 346
verification of class files, 149
runtime constant pool, 14method resolution, 350
method descriptors, 78
areturn, 374invokespecial, 480, 482
CONSTANT_Fieldref_info,invokestatic, 484, 485
invokevirtual, 487, 490
CONSTANT_Methodref_info, and
CONSTANT_InterfaceMethodref_infoinvoking methods, 52
structures, 87loading constraints, 343
CONSTANT_InvokeDynamic_infomethod type and method handle resolution,
354
structure, 95
CONSTANT_MethodType_info structure,method type and method handle resolution,
95352
CONSTANT_NameAndType_infocall site specifier resolution, 355, 355, 356
structure, 91CONSTANT_MethodHandle_info structure,
element_value structure, 13394
577
--------------------------------------- 596
INDEX
initialization, 357athrow, 378
invokevirtual, 489, 489, 490dreturn, 406
ldc, 514, 513freturn, 436
ldc_w, 516, 515invokeinterface, 478
special methods, 22invokespecial, 482
methods, 98invokestatic, 485
AnnotationDefault attribute, 138invokevirtual, 488
attributes, 101ireturn, 494
ClassFile structure, 73lreturn, 527
Code attribute, 105monitorenter, 535
Deprecated attribute, 129return, 553
Exceptions attribute, 116more control examples, 47
floating-point modes, 20dcmp<op>, 394
getfield, 440fcmp<op>, 424
invokespecial, 480multianewarray, 539, 310
invokevirtual, 487
method type and method handle resolution,N
354
putfield, 548native method stacks, 14
RuntimeInvisibleAnnotations attribute, 134native methods
RuntimeInvisibleParameterAnnotationsinvokeinterface, 478
attribute, 137invokespecial, 481
RuntimeVisibleAnnotations attribute, 129invokestatic, 485
RuntimeVisibleParameterAnnotationsinvokevirtual, 488
attribute, 135nested class access and property flags, 119
Signature attribute, 121InnerClasses attribute, 119, 119
special methods, 22new, 311, 541
synchronization, 36initialization, 357
Synthetic attribute, 121StackMapTable attribute, 116
mnemonic, 364
monitorenter, 535, 308newarray, 543, 312
invokeinterface, 478baload, 380
bastore, 381
invokespecial, 481boolean type, 10
invokestatic, 484multianewarray, 540
invokevirtual, 488nop, 545, 313
monitorexit, 537normal method invocation completion, 18
monitorexit, 309, 537synchronization, 67
areturn, 374notation, 3
578
--------------------------------------- 597
INDEX
Oinitialization, 357
Object creation and manipulation, 34
load and store instructions, 29R
opcode mnemonics by opcode, 563
operand stack, 413, 412, 414, 415, 547receiving arguments, 49
operand stack management instructions, 34invoking methods, 52
operand stacks, 17reference types and values, 11
anewarray, 373
Code attribute, 106control transfer instructions, 35
format of instruction descriptions, 365field resolution, 350
frames, 15interface method resolution, 352, 352
load and store instructions, 29method resolution, 351, 351
structural constraints, 145, 145multianewarray, 539
operations on the operand stack, 58new, 541
overriding
invokevirtual, 487newarray, 543
preparation, 346preparation, 346, 346, 346, 347, 347
verification of class files, 149representation of objects, 19
reserved opcodes, 362
static constraints, 142
Presolution, 347
creation and loading, 340
pc register, 12loading constraints, 343
pop, 314, 546ret, 552
pop2, 547, 315jsr, 502
predefined class file attributes, 103jsr_w, 503
attributes, 102returnaddress type and values, 10
preparation, 346wide, 560
loading constraints, 343, 343return, 553, 318
primitive types and values, 6
multianewarray, 539ret, 552
new, 541returnaddress type and values, 10
newarray, 543primitive types and values, 6
preparation, 346runtime constant pool, 14, 335
process of verification by type inference, 324dynamic linking, 18
public design, private implementation, 37frames, 15
getfield, 440
reserved opcodes, 362getstatic, 442
putfield, 316, 548invokedynamic, 472, 474, 472
putstatic, 550, 317invokeinterface, 477
579
--------------------------------------- 598
INDEX
invokespecial, 480signatures, 79
invokestatic, 484LocalVariableTypeTable attribute, 128
invokevirtual, 487Signature attribute, 122
ldc, 513, 513, 513, 513sipush, 321, 556
ldc2_w, 517SourceDebugExtension attribute, 123
ldc_w, 515, 515, 515ClassFile structure, 74
method type and method handle resolution,SourceFile attribute, 122
353ClassFile structure, 74
putfield, 548special methods, 21
putstatic, 550ClassFile structure, 74
resolution, 348Code attribute, 105
runtime constant pool, 335CONSTANT_Fieldref_info,
runtime data areas, 11CONSTANT_Methodref_info, and
RuntimeInvisibleAnnotations attribute, 134CONSTANT_InterfaceMethodref_info
annotations, 67, 67structures, 87
ClassFile structure, 74, 74CONSTANT_MethodHandle_info structure,
fields, 97, 9794
CONSTANT_NameAndType_info
methods, 101, 101structure, 91
RuntimeInvisibleParameterAnnotations
attribute, 136ConstantValue attribute, 104
methods, 101, 101constraints on Java virtual 141machine code, 
RuntimeVisibleAnnotations attribute, 129initialization, 357
instance initialization methods and newly
annotations, 67, 67created objects, 329
ClassFile structure, 74, 74
fields, 97, 97invokeinterface, 477
methods, 101, 101invokespecial, 480, 482
RuntimeVisibleParameterAnnotationsinvokestatic, 484
attribute, 135invokevirtual, 489, 487, 487
method area, 13
methods, 101, 101
method invocation and return 35instructions, 
method resolution, 350
Smethods, 98, 100, 100, 100
new, 542
saload, 319, 554
sastore, 555, 320putfield, 548
Signature attribute, 121putstatic, 550
ClassFile structure, 74, 74static constraints, 143
fields, 97, 97structural constraints, 146, 146, 146
Synthetic attribute, 121
methods, 101, 101
580
--------------------------------------- 599
INDEX
unqualified names, 75Exceptions, 25
working with class instances, 53more control examples, 47
StackMapTable attribute, 108throwing Exceptions, 36
Code attribute, 108, 108type conversion instructions, 32
verification by type checking, 151type hierarchy, 154
startupaccessors, 159, 159
initialization, 358type support in the Java virtual machine
static constraints, 141instruction set, 28
limitations of the Java virtual machine, 333types and the Java virtual machine, 26, 26
stores, 172use of constants, local variables, and control
structural constraints, 145constructs, 43
limitations of the Java virtual machine, 333typechecking rules, 159
structure of the Java virtual machine, 5types and the Java virtual machine, 26
subtyping rules, 155arithmetic instructions, 30
summary of chapters, 3control transfer instructions, 35
swap, 557, 322data types, 6
operand stacks, 17dup, 410
synchronization, 66, 36dup_x1, 411
areturn, 374, 374load and store instructions, 30
athrow, 378, 379operand stack, 415, 415, 414, 413, 412,
dreturn, 406, 406412, 415, 415, 547, 547, 413, 414
freturn, 436, 436pop, 546
ireturn, 494, 494structural constraints, 145
lreturn, 527, 527swap, 557
monitorenter, 535type conversion instructions, 32
monitorexit, 537, 538, 537
return, 553, 553
U
synchronization, 66, 36
Synthetic attribute, 121unqualified names, 75
ClassFile structure, 74binary class and interface names, 75
fields, 97CONSTANT_NameAndType_info
methods, 99, 101structure, 91
fields, 97
LocalVariableTable attribute, 126
TLocalVariableTypeTable attribute, 128
tableswitch, 558, 323methods, 100
instruction set summary, 25use of constants, local variables, and control
throwing and handling Exceptions, 59constructs, 40
581
--------------------------------------- 600
INDEX
accessing the runtime constant pool, 46invokeinterface, 478, 478
more control examples, 47invokespecial, 481, 481
user-defined class loadersinvokestatic, 484, 485
creation and loading, 339invokevirtual, 488, 488
loading constraints, 343putfield, 548
putstatic, 551
Vvalues of types long and double, 328
verification, 346
value set conversion, 20access control, 356
d2f, 387creation and loading, 340
d2i, 388verification by type checking, 150
d2l, 389accessors, 159
dadd, 390StackMapTable attribute, 108, 109
dastore, 393verification by type inference, 324
dcmp<op>, 394verification of class files, 148
ddiv, 397assumptions: the meaning of "must", 361
dmul, 401operand stacks, 17
dneg, 403verification, 346
drem, 404virtual machine errors, 362
dreturn, 406Exceptions, 23
dstore, 407virtual machine exit, 360
dstore_<n>, 408virtual machine start-up, 338
dsub, 409initialization, 358
f2d, 417
f2i, 418
f2l, 419W
fadd, 420wide, 560, 324
fastore, 423aload, 371
fcmp<op>, 424astore, 376
fdiv, 427dload, 399
floating-point modes, 20dstore, 407
fmul, 431fload, 429
fneg, 433fstore, 437
frem, 434iinc, 465
freturn, 436iload, 466
fstore, 437istore, 497
fstore_<n>, 438lload, 519
fsub, 439lstore, 530
582
--------------------------------------- 601
INDEX
ret, 552
working with class instances, 53
accessing the runtime constant pool, 46
invoking methods, 52
583
